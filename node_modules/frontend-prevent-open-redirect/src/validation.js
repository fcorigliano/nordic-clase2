const domains = require('frontend-platform_detection/config/domains.json'); // eslint-disable-line
const config = require('../config/defaults');

const webviewsProtocols = ['meli:', 'mercadopago:'];
const defaultWhitelist = [
  'mercadolibre.com',
];

function isWebviewsProtocol(protocol) {
  return webviewsProtocols.some(webviewProtocol => webviewProtocol === protocol);
}

function isValidProtocol(protocol, protocols) {
  return protocols.some(proto => proto === protocol);
}

// TODO agregar cache?
function isValidDomain(hostname, validDomains = domains) {
  return validDomains.some((validDomain) => {
    let domain = validDomain;

    if (validDomain.domain) {
      domain = validDomain.domain;
    }

    return (hostname.endsWith(`.${domain}`) || hostname === domain);
  });
}

/**
 * Determine is the provided combination of hostname and path can be considered as a valid path for webviews.
 * url.parse() has no full support for webview URIs but it is still useful for URI scheme validation in general,
 * with a single difference that webviews does not have a hostname and contains only the path.
 *
 * @param hostname {string}
 * @param path {string}
 * @returns {boolean}
 */
function isValidWebviewsPath(hostname, path) {
  return /^([-_a-z0-9]\/?)+$/i.test([hostname, path].filter(Boolean).join(''));
}

function parseUri(uri) {
  const decodeUri = uri.toString();
  // Avoid the parsing of URLs that contains forbidden symbols after decoding such as the escape `\`
  const hasForbiddenSymbols = /\\/.test(decodeUri);
  return new URL(hasForbiddenSymbols ? '' : decodeUri);
}

function isValidUri(uri, protocols) {
  if (uri && typeof uri === 'string') {
    const { protocol, hostname, pathname } = parseUri(uri);

    if (!isValidProtocol(protocol, protocols) || hostname === null) {
      return false;
    }

    if (isWebviewsProtocol(protocol)) {
      return isValidWebviewsPath(hostname, pathname);
    }

    return isValidDomain(hostname) && pathname.startsWith('/');
  }

  return false;
}

function isWhitelist(uri, whitelist) {
  const { hostname } = parseUri(uri);
  const mergeWhitelists = defaultWhitelist.concat(whitelist);

  return hostname !== null
      && isValidDomain(hostname, mergeWhitelists);
}

exports.isValid = function isValid(uri, whitelist = config.whitelist, protocols = config.protocols) {
  try {
    return isWhitelist(uri, whitelist) || isValidUri(uri, protocols);
  } catch (e) {
    return false;
  }
};
