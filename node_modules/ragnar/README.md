# Ragnar

> Give your node.js front-ends some extra weapons.

# Table of Contents
  - [About Ragnar](#An-Express-Instance)
  - [Middlewares](#Middlewares)
  - [Mounted Routers](#Mounted-Routers)
    - [API Example](#Ejemplo-de-API-endpoint)
    - [Custom Middlewares](#custom-middlewares)
      - [Shared middlewares](#shared-middlewares)
  - [Configuration](#Configuration)
    - [basePath](#basePath)
    - [apiBasePath](#apiBasePath)
    - [server](#server)
    - [version](#version)
    - [middlewares](#middlewares-1)
    - [session](#session)
    - [cluster](#cluster)
  - [Development certificates](#development-certificates)
  - [Fast refresh client side + Hot reload server side](#fast-refresh-client-side--hot-reload-server-side)

## About Ragnar

Ragnar ofrece una instancia de Express "aumentada", es decir, que cuenta con todo lo necesario para crear front-ends en las diferentes plataformas de Mercado Libre.

Por otro lado, nos permite tener control de las dependencias y middlewares comunes a todos los front-ends, una configuración por defecto y realizar actualizaciones de forma rápida impactando en los diferentes proyectos sin la necesidad que cada uno tenga que hacerlo.

<div align="center">
  <img src="https://cldup.com/38jV4OWRbY-3000x3000.jpeg" alt="Ragnar"/> 
</div>

## Middlewares

Se ofrecen un conjunto de middlewares comunes y configurables:

- logger
- compression
- [helmet](https://helmetjs.github.io/)
- bodyParser
- cookieParser
- hpp
- [Auth](https://github.com/mercadolibre/fury_frontend-authentication)
- [Device detection](https://github.com/mercadolibre/fury_frontend-device-detection)
- [Mshops detection](https://github.com/mercadolibre/fury_frontend-mshops-detection)
- [CBT detection](https://github.com/mercadolibre/fury_cbt-users-middleware)
- [First Party detection](https://github.com/mercadolibre/fury_first-party-detection)
- [Platform detection](https://github.com/mercadolibre/fury_frontend-platform-detection)
- [Fury Session](https://github.com/mercadolibre/fury_node-express-session/blob/master/README.md)
- Error handlers (App y API)
- ping-pong (/ping route)
- [Flash Messages](https://github.com/jaredhanson/connect-flash)
- [blockSuspiciousTraffic](#blockSuspiciousTraffic)
- [showPrettyErrors](#showPrettyErrors)
- [preventRenderByEtag](#preventRenderByEtag)
- [Cookie Response Handler](#CookieSameSiteHandler)
- [Outdated Browser](#outdated-browser)
- [CSRF](#csrf)

## Mounted Routers

Vamos a  estar utilizando [Routers de Express](http://expressjs.com/en/guide/routing.html#express-router) para modularizar las aplicaciones en "sub-aplicaciones". Cada instancia de Ragnar, va a contar con la posiblidad de montar dos routers: uno para `api` y otro para `app`.

En cada router, se va definir las rutas y middlewares de la aplicación, es decir, toda la lógica de la aplicación.


### Ejemplo de API endpoint
```js
// apiRouter.js

/**
 * Module dependencies
 */
const router = require('ragnar').router();

/**
 * endpoint route (/api/endpoint).
 */
router.get('/endpoint', (req, res, next) => {
  res.status(200).json({
    api: true,
  });
});

/**
 * Expose api router
 */
module.exports = router;
```

```js
// Entry point: index.js

/**
 * Module dependencies
 */
const ragnar = require('ragnar');

/**
 * Config
 */
const config = require('./config');

/**
 * API Router
 */
const apiRouter = require('./apiRouter');

/**
 * App Router
 */
const appRouter = require('./appRouter');

/**
 * Expose ragnar instance
 */
module.exports = ragnar({
  config,
  apiRouter,
  appRouter,
})
```

Ragnar recibe por configuración ambos routers (`apiRouter` y `appRouter`) y los monta dentro de la aplicación principal, junto con los middlewares comunes.

```js
/**
 * API routes
 */
if (config.apiRouter) {
  this.app.use(
    '/api',
    middlewares.api.before(config),
    config.apiRouter,
    middlewares.api.after(config)
  );
}
```

Esto nos permite luego acceder a la ruta `/endpoint` que definimos para nuestra API, a través de `/api/endpoint`.


### Custom Middlewares

En los mounted routers, tenemos la posibilidad de agregar middlewares custom, para satifacer las necesidades propias de cada aplicación.

```js
// apiRouter.js

/**
 * Module dependencies
 */
const router = require('ragnar').router();

/**
 * Custom Middleware
 */
router.use('/', (req, res, next) => {
  req.api = true;
  next();
});

/**
 * Endpoint
 */
router.get('/endpoint', (req, res, next) => {
  res.status(200).json({
    api: req.api,
  });
});

/**
 * Expose api router
 */
module.exports = router;
```

#### Shared Middlewares
En ciertos casos necesitamos middlewares que ejecuten tanto en nuestro `apiRouter` como en nuestro `appRouter`. Para esto podemos configurar middlewares con `sharedPreMiddlewares` y `sharedPostMiddlewares`, de la siguiente forma:

```js
/**
 * Expose ragnar instance
 */
module.exports = ragnar({
  config,
  sharedPreMiddlewares: [ // Array of middlewares
    (req, res, next) => {
      console.log('Shared middleware that will execute before all your other middlewares');
      next();
    }
  ],
  sharedPostMiddlewares: [ // Array of middlewares
    (req, res, next) => {
      console.log('Shared middleware that will execute after all your other middlewares');
      next();
    }
  ]
  apiRouter,
  appRouter,
})
```

## Configuration

La configuraciones de Ragnar se deben configurar dentro de `config/default.json` y `config/default-production.json` para los ambientes de desarrollo y producción respectivamente.

```json
{
  "basePath": "/",
  "server": {
    "port": 8080,
    "securePort": 8443,
    "host": "0.0.0.0",
    "static": "./public"
  },
  "version": "1.0.0",
  "middlewares": {
    "authenticate": false,
  },
  "session": {
    "name": "project_session",
    "cookie": {
      "maxAge": 1800000, // 30 minutes
      "secure": true
    },
    "ttl": 1800, // 30 minutes
    "max_retries": 2,
    "retry_delay": 40,
    "secret": null
  },
}
```

### `basePath`
Se indica el valor del `basePath` principal donde se va a estar montando la aplicación. En development siempre utilizamos `/`.

```json
"basePath": "/foo/test",
```

```
https://www.meradolibre.com.ar/foo/test
```

### `apiBasePath`
Se indica el valor del `apiBasePath` que es donde se va a estar montando la API. En caso de no indicarlo se montará sobre `basePath + /api`.

```json
"apiBasePath": "/fooapi/test/api",
```

```
https://www.meradolibre.com.ar/fooapi/test/api
```

### `server`

#### `server.port`
#### `server.securePort`
#### `server.host`
#### `server.static`
#### `server.keepAliveTimeout` - The number of milliseconds of inactivity a server needs to wait for additional incoming data, default is `75000`

### `version`
Se indica la versión de la aplicación en la que se está trabajando. Lo recomentable es utitilizar el mismo valor que en el `package.json`.

```js
version: require(`${__dirname}/../package.json`).version,
```

### `middlewares`
Se configura que middlewares se quieren deshabilitar o habilitar.

Actualmente los middlewares que se pueden configurar son:
- `forwardTraceRequestId`
- [`device`](https://github.com/mercadolibre/fury_frontend-device-detection)
- [`mshopsDetection`](https://github.com/mercadolibre/fury_frontend-mshops-detection)
- [`platform`](https://github.com/mercadolibre/fury_frontend-platform-detection)
- [`authenticate`](https://github.com/mercadolibre/fury_frontend-authentication)
- `csp`
- `blockSuspiciousTraffic`
- `showPrettyErrors`
- [`cbtDetection`](https://github.com/mercadolibre/fury_cbt-users-middleware)
- [`firstPartyDetection`](https://github.com/mercadolibre/fury_first-party-detection)
- `outdatedBrowser`
- [`httpCookiesTracking`](https://github.com/mercadolibre/fury_frontend-cookies-manager/tree/master/packages/http-cookies-middleware)
- `csrf`

Los valores por default de los middlewares son
```json
{
  "basePath": "/",
  "middlewares": {
    "forwardTraceRequestId": true,
    "device": true,
    "mshopsDetection": false,
    "platform": true,
    "authenticate": true,
    "csp": false,
    "blockSuspiciousTraffic": false,
    "showPrettyErrors": true,
    "cbtDetection": false,
    "firstPartyDetection": true,
    "outdatedBrowser": true,
    "httpCookiesTracking": true,
    "csrf": true
  }
}
```

### `session`
Se configura el servicio de Fury sessions basado en [connect-kvs](https://github.com/mercadolibre/fury_node-connect-kvs/). Para más información sobre uso del servicio leer [documentación oficial](http://docs.furycloud.io/?lang=esp&section=sess).

Los valores por defecto de la session son los siguientes:

> Se recomienda cambiar la propiedad `name` por una asociada a la aplicación que esta haciendo uso de la sesion para evitar colisiones con otras aplicaciones, por ejemplo se puede usar el nombre de la aplicación.

```json
{
  "session": {
    "name": "NSESSIONID",
    "ttl": 1800, // 30 minutes
    "max_retries": 2,
    "retry_delay": 40,
    "secret": null,
    "cookie": {
      "maxAge": 1800000, // 30 minutes
      "secure": true 
    },
  }
}
```

#### Configuración requerida para activar `session.cookie.secure` en la capa de tráfico

Para que la cookie segura pueda ser creada efectivamente es necesario agregar a las **reglas de nginx** de la aplicación el header `X-Forwarded-Proto` con valor `https` ya sea a nivel server o location. Puedes hacerlo con la sentencia:

```nginx
proxy_set_header X-Forwarded-Proto https
```

En caso de que ya este definido con el valor `$real_scheme` reemplazar el valor por `https`.

> **NOTA:** Es importante verificar que el cambio aplica solo a la aplicación deseada, de no hacerlo se puede generar afectación no deseada sobre otras aplicaciones. 

#### Deshabilitar el servicio de sesiones

Para deshabilitar el servicio de sesiones hay que agregar `ENV SESSION_MANAGER=FALSE` a Dockerfile.runtime del proyecto.

### `flash-messages`
Flash se usa para guardar mensajes en session, una vez usados se eliminan de la misma.

###### `Configuración:`
Habilitar flash en /config
```json
  ragnar: {
    ...
    session: {
     ...
      flash: true,
    },
  },
```
###### `Ejemplo:`
Guardar un mensaje en una ruta y mostrarlo en otra.
```js
  router.get('/flash', function(req, res){
    // Setear mensaje usando una KEY seguida del VALOR (String o Object).
    req.flash('info', 'Message Flash!');
    req.flash('errors', { userId: 1234, message: 'Error in process file!' });
    res.redirect('/');
  });

  router.get('/', function(req, res){
    // Obtenemos un array de mensajes por KEY.
    res.render('index', {
      messages: req.flash('info'),
      errors: req.flash('errors'),
    });
  });
```

### `blockSuspiciousTraffic`

BlockSuspiciousTraffic es un middleware que realiza una llamada interna a *Abuse Prevention API* para filtrar a los clientes
 sospechosos y no deseados. En el caso positivo se redirecciona al usuario a una página *trampa* donde estamos ofreciendo
 login o registro. Para los usuarios logueados middleware nunca se ejecuta.

#### `Configuración:`

Su funcionamiento depende de dos partes de configuración: config de Ragnar donde se puede activar o desactivar el middleware
 a nivel global y config del proyecto donde se puede activar middleware por plataforma y/o site. Por ejemplo para habilitar
 middleware para Mercado Libre Brazil hay que agregar `blockSuspiciousTraffic: true` a `./config/default.js`:

```js
module.exports = {
  ML: {
    MLB: {
      blockSuspiciousTraffic: true,
      ...,
    }
  }
};
```

Y también activar el middeware en la sección `middlewares` de la configuración de Ragnar:

```js
  ragnar: {
    middlewares: {
      blockSuspiciousTraffic: true,
      ...,
    },
  },
```

### `showPrettyErrors`

`showPrettyErrors` es un middleware **solo para desarrollo** que permite ver los stack trace de la terminal directamente en el navegador y abrir rapidamente a los archivos en tu IDE.

<div align="center">
  <img src="https://cldup.com/nf6p6j_DwV-1200x1200.png" alt="showPrettyErrors"/> 
</div>

La opción para abrir el archivo en el editor es [compatible con los siguientes IDEs](https://github.com/yyx990803/launch-editor#supported-editors).

**Se puede deshabilitar el middleware mediante una configuración.**

Cuando tengas que implementar el middleware de error de tu aplicación va a ser necesario que deshabilites el middleware `showPrettyErrors` como se indica a continuación.

```js
  ragnar: {
    middlewares: {
      showPrettyErrors: false,
      ...,
    },
  },
```

### `preventRenderByEtag`

`preventRenderByEtag` es un middleware que se encarga de cortar la ejecución y evitar procesamientos innecesarios utilizando el status code 304 en caso de que el ETAG no haya variado y sea una webview.

#### ¿Por qué se agregó este middleware?
El middleware nace por una necesidad de generar skeletons cuando es una webview, por lo que el primer request devuelve el html con el skeleton, se cachea y se versiona a través de un ETAG para obtener mejor performance.
Este middleware se complementa con [CSR PreRender](https://github.com/mercadolibre/fury_frontend-csr-prerender) por lo que se deberá implementar dentro de las rutas que se requiera utilizar skeleton

El ETAG se setea según tres variables:
  - Versión de Fury
  - Versión de aplicación nativa
  - Site Id

**El middleware por defecto se encuentra apagado y se puede habilitar mediante configuración.**

```js
  ragnar: {
    middlewares: {
      preventRenderByEtag: true,
      ...,
    },
  },
```
### `CookieSameSiteHandler`

CookieSameSiteHandler es un middleware que resuelve el uso del atributo `SameSite` para la creación de cookies, permitiendo 3 usos diferentes de control `SameSite=Lax`, `SameSite=Strict` ó `SameSite=None`, [según corresponda](https://web.dev/samesite-cookies-explained/).

- Las Cookies sin atributo `SameSite` serán ajustadas por el middleware como `SameSite=None` aunque es posible que no obtengas el comportamiento esperado, por ello, es recomendable que sea configurado manualmente.
- En las Cookies con `SameSite=None` es requerido incluir el atributo `Secure` ya que sólo pueden ser enviadas sobre HTTPS.

Ejemplo de uso:
```js
function saludoController(req, res) {
  res.cookie('hola', 'mundo', { sameSite: 'strict' });
  res.status(200).send('Hola mundo');
}
> Set-Cookie: hola=mundo; SameSite=Strict
```

```js
function saludoController(req, res) {
  res.cookie('hola', 'mundo', { sameSite: 'none', secure: true });
  res.status(200).send('Hola mundo');
}
> Set-Cookie: hola=mundo; SameSite=None; Secure
```

> Chrome implementa estos comportamientos a partir de la versión 80. [Firefox](https://groups.google.com/d/msg/mozilla.dev.platform/nx2uP0CzA9k/BNVPWDHsAQAJ) los tiene disponibles para probar a partir de Firefox 69 y los convertirá en comportamientos predeterminados en el futuro. Para probar estos comportamientos en Firefox, abra `about:config` y configure `network.cookie.sameSite.laxByDefault`. [Edge](https://groups.google.com/a/chromium.org/d/msg/blink-dev/AknSSyQTGYs/8lMmI5DwEAAJ) también planea cambiar sus comportamientos predeterminados.

### `Outdated Browser`

Outdated Browser es un middleware que redirecciona el tráfico a una [landing page](https://www.mercadolibre.com.ar/sentry/update-browser) que invita a actualizar tu navegador en caso que sea detectado como outdated.

PCI Compliant y Outdated browser tienen un comportamiento similar, redireccionar al usuario a una landing que te invita a actualizar el navegador. La idea es no mostrar ambas pantallas, si PCI es false dejamos que el el flujo de PCI se encargue de esto, en caso que PCI sea true pero el navegador lo marcamos como Outdated, entonces lo llevamos por el flujo de Outdated Browser.

Consideraciones:
- El feature PCI Compliant tiene prioridad sobre este middleware.
- Se evita la redirección si la primera visita viene de un referer externo.
- Cuando un usuario decide no actualizar se almacena una cookie de sesión marcando `ub_skip=1`.

#### `Configuración:`
**El middleware por defecto se encuentra encendido y se puede deshabilitar mediante configuración.**

```js
  ragnar: {
    middlewares: {
      outdatedBrowser: false,
      ...,
    },
  },
```

### `CSRF`

CSRF es un middleware que implementa por detrás la librería [csurf](https://github.com/expressjs/csurf) para ofrecer una solución por defecto a la vulnerabilidad [Cross-Site Request Forgery](https://portswigger.net/web-security/csrf).

#### `Configuración:`
**El middleware se encuentra encendido por defecto y se puede deshabilitar mediante configuración.**

```js
{
  ragnar: {
    middlewares: {
      csrf: false,
      ...,
    },
  },
}
```

**También es posible cambiar parámetros sobre la cookie generada y como llegan los tokens al servidor. Los valores por defecto son:**

```js
{
  server: {
    csrf: {
      cookie: {
        key: '_csrf',
        path: '/',
        sameSite: false,
        secure: true,
        httpOnly: true,
        domain: '', # defaults to current domain
      },
      value: req => ( # places where token may come
        (req.body && req.body._csrf)
        || (req.query && req.query._csrf)
        || (req.headers['csrf-token'])
        || (req.headers['xsrf-token'])
        || (req.headers['x-csrf-token'])
        || (req.headers['x-xsrf-token'])
      ),
      ignorePaths: [],
    },
  },
}
```

**Para poder ignorar una o más rutas específicas dentro de nuestra app, por ejemplo un endpoint de consumer o de job, se puede hacer uso del campo `ignorePaths` de la config de csrf:**

```js
{
  server: {
    csrf: {
      ignorePaths: ['/jobs/loadRecentPayments', '/jobs/sendNotifications'],
    },
  },
}
```

**Tambien se podría resolver el ejemplo anterior de manera mas genérica usando expresiones regulares. Esto nos puede ser muy útil si tenemos varios endpoints a ignorar que cumplen cierto patrón:**
```js
{
  server: {
    csrf: {
      ignorePaths: [
        new RegExp('^/jobs/.*'), // matches /jobs/*
        '/bq/anotherCustomIgnore',
      ],
    },
  },
}
```

> El endpoint /refresh_config viene por defecto ignorado, por lo que no es necesario agregarlo a mano.

### cluster

Ragnar has clustering enabled only in production environments. In case you need to shut it down (not recommended) you can use an env variable:

`DISABLE_NODEJS_CLUSTER=true node index.js`

## Development certificates

> This feature is provided since Ragnar@2.4.0.

### Web

In non-production environment Ragnar, when running over HTTPS, provides a self-signed SSL certificates which by default are not trusted by the operating system.

To make them valid, run for a **single time** the following command from any application which contain a Ragnar module.

```bash
  ./node_modules/.bin/install-devcert-ca
```

This command installs our certificate authority (CA), which is used to sign all certificates provided by Ragnar, to a system's keychain. Please note that `sudo` password is required for this operation.

However, some HTTP clients, such as Firefox, use their own CA stores instead of the operating system's keychain. As a result these clients still have a problem with a certificates' validity, but this will be fixed in the feature releases.

### Webviews

Since the end-user client who is responsible for certificates validation, in many contexts, such as webviews, there is no direct access to the client's system keychain. To provide the possibility of CA installation in these contexts Ragnar runs an alternative web server to make available the CA over non-secure connection.

#### CA Installations on iOS systems
- Open in Safari `http://localhost.com.ar:8080/melidev.cer`. Any valid Meli domain may be used, but port and path are constant.
- Allow to download a configuration profile by pressing `Allow`.
- Open settings.
- Go to `General` -> `Profile` -> `MeliDev CA`.
- Select `Install`, a few confirmation prompts will appear.
- Open settings.
- Go to `General` -> `About` -> `Certificate Trust Settings`.
- Enable `MeliDev CA` and confirm it by pressing `Continue`.
- Ready.

#### CA Installations on Android
- Go to `http://localhost.com.ar:8080/melidev.cer` on your Android device and download the certificate to filesystem. In case when the mobile device has no Chrome installed, just download `melidev.cer` to your desktop computer and copy it to the Android device with drag-n-drop. Any valid Meli domain may be used, but port and path are constant.
- Open settings.
- Go to `Security`, in some systems `Security & Location`.
- Go to `Encryption & Credentials`.
- Go to `Install from storage`, in some systems `Install from SD card`.
- Select `CA Certificate` from the list of types available, not always is present.
- Accept a large scary warning.
- Browse to the certificate file on the device and open it.
- Some systems may ask for a certificate name, enter `MeliDeev CA`.
- Confirm the certificate install.
- Ready.

**Note**: any CA installation process is required only once per device.

:memo: Please note, that this behaviour may be disabled by defining the environment variable `DISABLE_DEVCERT_SERVER=true`.

## Fast refresh client side + Hot reload server side

> This feature is provided since Ragnar@2.4.0.

Nordic allows you to use Fast Refresh client side + Hot Reload server side.
All new Nordic and Odin applications are configured with this feature by default since **nordic && nordic-dev v6.12.0**

If you want to enable this feature, please follow this instructions:

**1.** Modify the `dev` script in order to use `node` instead of `nodemon`.

`package.json`
```js
  {
    "scripts": {
      "dev": "NODE_ENV=development NODE_HTTPS=true node ./index.js"
    }
  }
```

Running `npm run dev` you will be able to build your project (in memory) and start the application. You no longer have to run npm run watch or npm run build commands.

⚠️ **Important**: if you execute `npm run dev` along with `npm run watch` or `npm run build`, the application build will fail.

**2.** Set up your config in order to use this feature only for the development environment.

`config/default-development.js`
```js
module.exports = {
  ...,
  hotReload: {
    enabled: true,
  },
};
```

See the [fast refresh documentation](https://nordic.adminml.com/v6.16.0/docs/fast-refresh) for more information about configuration options and limitations / considerations.

## License

Copyright © 2021.
