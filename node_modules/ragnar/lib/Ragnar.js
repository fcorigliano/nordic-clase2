/* eslint-disable global-require */
/**
 * Module dependencies
 */
const express = require('express');
const cluster = require('cluster');
const flash = require('connect-flash');
const numCPUs = require('os').cpus().length;
const { normalize, resolve } = require('path');
const merge = require('lodash.merge');
const http = require('http');
const https = require('https');
const tls = require('tls');
const session = require('fury-session');
const {
  SECURE, PRODUCTION, DEVELOPMENT, SESSION_MANAGER, DISABLE_NODEJS_CLUSTER, DISABLE_DEVCERT_SERVER,
} = require('frontend-env');
const feConfig = require('frontend-config');
const chokidar = require('chokidar');
const launchEditorMiddleware = require('launch-editor-middleware');
const { certificateFor, getCACertificate } = require('frontend-devcert');
const Telemetry = require('nordic-telemetry');
const moduleAvailable = require('module-available');
const middlewares = require('./middlewares');
const staticMiddleware = require('./static');
const ping = require('./ping');
const defaults = require('../config/defaults');
const logger = require('./logger');
const prettyErrorLayer = require('./prettyErrorLayer');
const attachNordicPagesToAppRouter = require('./nordicPage/attach-to-app-router');

const telemetry = new Telemetry({ envRaw: process.env });

// eslint-disable-next-line no-underscore-dangle
const importDefault = (module) => ((module && module.__esModule) ? module.default : module);

/**
 * Ragnar Class
 */
class Ragnar {
  constructor({
    config, apiRouter, appRouter, sharedPreMiddlewares, sharedPostMiddlewares,
  }) {
    /**
     * Merge configurable middlewares
     */
    const configurableMiddlewares = { ...defaults.middlewares, ...config.middlewares };
    config.middlewares = configurableMiddlewares;

    /**
     * Merge defaults with the given config
     */
    this.config = merge({}, defaults, config);

    this.sharedPreMiddlewares = sharedPreMiddlewares;

    this.sharedPostMiddlewares = sharedPostMiddlewares;

    /**
     * Create express instance
     */
    this.app = express();

    this.attachCommonConfig();

    this.hotReload(apiRouter, appRouter);

    this.attachRoutes(apiRouter, appRouter);

    /**
     * Run Server
     */
    if (PRODUCTION) {
      this.cluster();
    } else {
      this.startDev();
    }
  }

  attachCommonConfig() {
    /**
     * Set express trust proxy
     */
    this.app.set('trust proxy', true);

    /**
     * Ping route
     */
    this.app.get('/ping', ping);

    /**
     * Fury sessions middleware
     * `SESSION_MANAGER` is a common env variable that is used across all platforms to disable the sessions
     */
    if (SESSION_MANAGER !== 'FALSE') {
      this.app.use(session(this.config.session));

      /**
       * Middleware Flash Connect
       * to use in req.flash()
       */
      if (this.config.session.flash) {
        this.app.use(flash());
      }
    }
  }

  attachAppRoutesIfApplies(appRouter) {
    if (appRouter) {
      /**
      * Attach nordic pages
      */
      attachNordicPagesToAppRouter(appRouter);

      /**
     * Static middleware
     */
      if (!PRODUCTION) {
        this.app.use(staticMiddleware(this.config));
      }

      /**
     * Add Pretty Error Layer (middleware)
     */
      if (DEVELOPMENT && this.config.middlewares.showPrettyErrors) {
        this.app.get('/favicon.ico', (req, res) => res.status(204).end());
        this.app.get('/__open-in-editor', launchEditorMiddleware());
        const errorMiddlewareArguments = 4;
        const index = appRouter.stack.findIndex((layer) => (
          layer.handle.length === errorMiddlewareArguments
        && layer.name !== 'onPageError'));
        if (index !== -1) {
          appRouter.stack.splice(index, 0, prettyErrorLayer);
        } else {
          appRouter.stack.push(prettyErrorLayer);
        }
      }

      this.app.use(
        this.config.basePath,
        middlewares.app.before(this.config, this.sharedPreMiddlewares),
        appRouter,
        middlewares.app.after(this.config, this.sharedPostMiddlewares),
      );
    }
  }

  attachApiRoutesIfApplies(apiRouter) {
    if (apiRouter) {
      const apiRoute = this.config.apiBasePath || normalize(`${this.config.basePath}/api`);
      this.app.use(
        // Avoid "//ping" if basePath is "/".
        apiRoute,
        middlewares.api.before(this.config, this.sharedPreMiddlewares),
        apiRouter,
        middlewares.api.after(this.config, this.sharedPostMiddlewares),
      );
    }
  }

  attachRoutes(apiRouter, appRouter) {
    /**
     * API routes
     */
    this.attachApiRoutesIfApplies(apiRouter);

    /**
     * App Routes
     */
    this.attachAppRoutesIfApplies(appRouter);
  }

  instanceWebpackMiddlewares() {
    /* eslint-disable global-require,  import/no-dynamic-require */
    const webpackFilePath = resolve(feConfig.get('hotReload.client.webpackConfig') || 'webpack.config.js');
    const webpackConfig = require(webpackFilePath);
    const webpack = require('webpack'); // eslint-disable-line import/no-extraneous-dependencies
    const compiler = webpack(webpackConfig);
    const writeToDiskPaths = feConfig.get('hotReload.writeToDiskPaths');

    const devMiddleware = require('webpack-dev-middleware')(compiler, {
      publicPath: webpackConfig.output.publicPath,
      stats: 'errors-only',
      ...writeToDiskPaths && {
        writeToDisk: (filepath) => writeToDiskPaths.some((pathRegex) => pathRegex.test(filepath)),
      },
    });
    const hotMiddleware = require('webpack-hot-middleware')(compiler, {
      reload: true,
      noInfo: true,
    });
    /* eslint-disable global-require,  import/no-dynamic-require */

    return { devMiddleware, hotMiddleware, publicPath: webpackConfig.output.publicPath };
  }

  rebuildServer({
    apiRouter, appRouter, devMiddleware, hotMiddleware,
  }) {
    Object.keys(require.cache).forEach((id) => {
      if (!(/node_modules/.test(id))) delete require.cache[id];
    });

    let actualApi;
    let actualApp;
    this.app._router = null; // eslint-disable-line no-underscore-dangle

    if (apiRouter) {
      actualApi = importDefault(require(resolve(feConfig.get('hotReload.server.apiRouter') || './api')));
    }

    if (appRouter) {
      actualApp = importDefault(require(resolve(feConfig.get('hotReload.server.appRouter') || './app/server')));
    }

    this.app.use(devMiddleware);
    this.app.use(hotMiddleware);

    // rebuild server with changes
    this.attachCommonConfig();
    this.attachRoutes(actualApi, actualApp);
  }

  hotReload(apiRouter, appRouter) {
    /**
     * Enable client fast refresh and server hot build for development purpose only
     */
    if (DEVELOPMENT && feConfig.get('hotReload.enabled') === true && moduleAvailable('webpack')) {
      /**
       * Client config
       */
      const { devMiddleware, hotMiddleware, publicPath } = this.instanceWebpackMiddlewares();
      const ignoredFiles = feConfig.get('hotReload.ignoredFiles');
      this.app.use(devMiddleware);
      this.app.use(hotMiddleware);
      /**
       * Server config
       */
      const ignored = [
        publicPath,
        /(^|[\/\\])\../, // eslint-disable-line no-useless-escape
        /.+\.scss$/,
        /.+\.css$/,
        /node_modules/,
        /.+\.spec.js$/,
        ...(ignoredFiles ? ignoredFiles : []), // eslint-disable-line no-unneeded-ternary
      ];
      const watcher = chokidar.watch(resolve('.'), {
        ignored,
        persistent: true,
        awaitWriteFinish: {
          stabilityThreshold: 500,
          pollInterval: 100,
        },
        ignoreInitial: true,
      });
      watcher.on('ready', () => {
        watcher.on('all', () => this.rebuildServer({
          apiRouter, appRouter, devMiddleware, hotMiddleware,
        }));
      });

      telemetry.trackEvent('HMR', 'SERVER');
    }
  }

  /**
   * Start server
   */
  /* istanbul ignore next */
  start() {
    const { port, host, keepAliveTimeout } = this.config.server;
    this.server = http.createServer(this.app).listen(port, host, () => {
      logger.info(`App listening on port ${port}.`);
    });

    /**
     * In node v8.x (@see https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_server_keepalivetimeout)
     * the default value of keepAliveTimeout was changed from 0 (disabled) to 5000 (5 seconds) that can produces
     * 502 errors while HTTP Middleware communicating with the app's server. For stable communication must be greater than 60s
     */
    this.server.keepAliveTimeout = typeof keepAliveTimeout === 'undefined' ? 75000 : Number(keepAliveTimeout);

    return this;
  }

  /**
   * Start Devcert server
   *
   * Should be used only for development and when main development server is running over HTTPS, e.g. the variable SECURE is defined
   * Can be disabled with a DISABLE_DEVCERT_SERVER env variable
   */
  startDevcertServer() {
    const devcertApp = express();
    devcertApp.get('/melidev.cer', (req, res) => {
      res.set('Content-Type', 'application/x-x509-ca-cert');
      res.status(200).send(getCACertificate());
    });

    this.devcertServer = http.createServer(devcertApp);
    this.devcertServer.listen(8080, '0.0.0.0', () => {
      logger.info(`Devcert server for webviews is listening on port 8080.
        Go to http://localhost.com.ar:8080/melidev.cer to download the development Certificate of Authority from your mobile device. 
        If you donâ€™t need this, you can disable it by defining the environment variable DISABLE_DEVCERT_SERVER = true`);
    });
  }

  async getCertificateFor(domain) {
    const cert = await certificateFor(domain);
    return cert;
  }

  async handleSNICallback(domain, cb) {
    let ssl;
    let err;

    try {
      ssl = await this.getCertificateFor(domain);
    } catch (ex) {
      err = ex;
    }

    cb(err, tls.createSecureContext(ssl));
  }

  /**
   * Start dev server
   */
  startDev() {
    let port;

    // Creates https server
    if (SECURE) {
      port = this.config.server.securePort;

      const options = {
        SNICallback: async (domain, cb) => this.handleSNICallback(domain, cb),
      };

      this.server = https.createServer(options, this.app);

      if (!DISABLE_DEVCERT_SERVER && DEVELOPMENT) {
        this.startDevcertServer();
      }
    // Creates http server
    } else {
      port = this.config.server.port; // eslint-disable-line prefer-destructuring
      this.server = http.createServer(this.app);
    }

    // Configure server port and host
    this.server.listen(port, this.config.server.host, () => {
      logger.info(`App listening on port ${port}.`);
    });

    if (typeof this.config.server.keepAliveTimeout !== 'undefined') {
      this.server.keepAliveTimeout = this.config.server.keepAliveTimeout;
    }

    return this;
  }

  /**
   * Stop server
   */
  stop() {
    this.server.close();
    if (this.devcertServer) {
      this.devcertServer.close();
    }

    return this;
  }

  /**
   * Use cluster to start server
   */
  cluster() {
    if (cluster.isMaster && DISABLE_NODEJS_CLUSTER !== 'true') {
      for (let i = 0; i < numCPUs; i += 1) {
        cluster.fork();
      }

      cluster.on('online', (worker) => {
        logger.info(`Worker ${worker.process.pid} is online`);
      });

      cluster.on('exit', (worker) => {
        logger.info(`Worker ${worker.process.pid} died`);
        logger.info('Starting a new worker');
        cluster.fork();
      });
    } else {
      this.start();
    }
    return this;
  }
}

/**
 * Expose Ragnar
 */
module.exports = Ragnar;
