const { join } = require('path');
const { APPLICATION, npm_package_name } = require('frontend-env'); // eslint-disable-line camelcase
const statsd = require('frontend-statsd/internal');
const sessionClient = require('./client/session-client');
const userClient = require('./client/user-client');
const {
  MIDDLEWARE_HEADERS,
} = require('./constants');
const {
  getSessionCookie,
  isHandledByMiddleware,
  isSecureAccessToken,
  isValidClientId,
  isValidAccessToken,
  clearSessionCookie,
  getTokenFromRequest,
} = require('./helpers');
const logger = require('./logger');

/**
 * getSessionFromToken
 */
const getSessionFromToken = ({
  req,
  allowWebviewAuthentication,
  token,
  tokenSource,
}) => {
  const isWebview = req.device && req.device.webView;
  if (!isWebview || !allowWebviewAuthentication) {
    return Promise.resolve(null);
  }

  if (!isValidAccessToken(token)) {
    return Promise.resolve(null);
  }

  return sessionClient.getSessionFromToken({ req, token, tokenSource })
    .then((userSession) => {
      if (isSecureAccessToken(userSession)) {
        return userSession;
      }
      return null;
    });
};

/**
 * getSessionFromCookie
 */
const getSessionFromCookie = (req, res) => {
  const sessionCookie = getSessionCookie(req);
  if (!sessionCookie) {
    return Promise.resolve(null);
  }

  return sessionClient.getSessionFromCookie(sessionCookie, req)
    .catch((error) => {
      // If session cookie is no longer valid, then clean it
      if (error.response && error.response.status === 404) {
        clearSessionCookie(req, res);
      }

      throw error;
    });
};

/**
 * getSessionFromHeaders
 *
 * @param {Express.Request} req
 * @param {boolean} allowWebviewAuthentication
 */
const getSessionFromHeaders = (req, allowWebviewAuthentication) => {
  const authMethod = req.header(MIDDLEWARE_HEADERS.AUTHENTICATION_METHOD);

  if (authMethod === 'TOKEN') {
    const isWebview = req.device && req.device.webView;
    const clientId = req.header(MIDDLEWARE_HEADERS.CLIENT_ID);

    if (!allowWebviewAuthentication || !isWebview || !isValidClientId(clientId)) {
      return Promise.resolve(null);
    }
  }

  const userId = req.header(MIDDLEWARE_HEADERS.USER_ID);
  if (!userId) {
    return Promise.resolve(null);
  }

  return sessionClient.getSessionFromHeaders(req)
    .catch((error) => {
      logger.error(`Error parsing headers of session. ${error.message}`);
      return null;
    });
};

/**
 * getUser
 *
 * @type {import('./user-resolver').UserResolver}
 */
exports.getMeliUser = function getUser(req, res, opts = {}) {
  /** @type {import('../types').AuthInfo} */
  const authInfo = { method: 'MELI_WEB', user: null, session: null };

  const { navigateAsOperator, allowWebviewAuthentication } = opts;
  let resolveUserSession;
  const handledByMiddleware = isHandledByMiddleware(req);
  if (handledByMiddleware) {
    const authMethod = req.header(MIDDLEWARE_HEADERS.AUTHENTICATION_METHOD);
    if (authMethod === 'TOKEN') {
      authInfo.method = 'MELI_WEBVIEW';
    }

    resolveUserSession = getSessionFromHeaders(req, allowWebviewAuthentication);
  } else {
    const [token, tokenSource] = getTokenFromRequest(req);
    if (token) {
      authInfo.method = 'MELI_WEBVIEW';
      resolveUserSession = getSessionFromToken({
        req,
        allowWebviewAuthentication,
        token,
        tokenSource,
      });
    } else {
      resolveUserSession = getSessionFromCookie(req, res);
    }
  }

  return resolveUserSession
    .then((session) => {
      if (session) {
        authInfo.session = session;
        const userId = session.operator_id && navigateAsOperator ? session.operator_id : session.user_id;
        return userClient.getUser(userId, req);
      }

      return null;
    })
    .then((user) => {
      if (user) {
        const { session } = authInfo;
        authInfo.user = {
          id: user.id,
          nickname: user.nickname,
          active: user.status.site_status.toLowerCase() === 'active',
          // If user is a test user
          test: user.tags.includes('test_user'),
          scopes: session.scopes,
          // Operator
          operator: session.operator_id !== null,
          operatorId: session.operator_id,
          // User ID of root user (operator owner)
          rootId: +(session.root_id || session.user_id), // Cast to number
          // Admin (impersonalized)
          admin: !!session.admin_otp,
          // When the user is not an operator or an admin, is the owner.
          owner: !(session.operator_id !== null || session.admin_otp),
          // Response from Users API
          raw: user,
        };

        const nonModifyingMethods = ['GET', 'OPTIONS', 'HEAD'];
        if (authInfo.user.admin && !nonModifyingMethods.includes(req.method)) {
          res.on('finish', () => {
            const code = `${Math.floor(res.statusCode / 100)}xx`;
            statsd.increment('business.auth.frontend-authentication.impersonation', {
              application: APPLICATION || npm_package_name, // eslint-disable-line camelcase
              method: req.method.toLowerCase(),
              status_code: code,
            });

            if (code === '2xx') {
              logger.warn('Made a modifying request with an admin session', {
                url: join(req.hostname, req.originalUrl),
                detachedId: session.detached_id,
              });
            }
          });
        }
      }

      return authInfo;
    })
    .catch((error) => {
      authInfo.error = error;

      return authInfo;
    });
};
