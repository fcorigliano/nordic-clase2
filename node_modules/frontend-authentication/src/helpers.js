const http = require('http');
const env = require('frontend-env');
const config = require('frontend-config');
const logger = require('./logger');
const { unauthorizedURL, getLoginURL } = require('./urls');
const {
  MIDDLEWARE_HEADERS,
  AUTHORIZATION_HEADER,
  ACCESS_TOKEN_HEADER,
  ACCESS_TOKEN_COOKIE_NAME,
} = require('./constants');

const SESSION_COOKIE_NAME = 'ssid';
const NATIVE_APPS_CLIENT_IDS = [
  1505, // ML iOS
  7092, // ML Android
  1945000207238192, // MP iOS
  1311377052931992, // ML Android
  8071255816559405, // MP Android SmartPOS
  3729071185294842, // Mercado Envios WMS Mercury
  8331031380410903, // Mercado Envios Logistics
  4749098811397999, // Mercado Envios Flex
];

/**
 * Returns the preferred value for SameSite attribute by checking its full support of client
 */
const getSameSiteValue = (req) => {
  const hasSupport = (req.browser && req.browser.support && req.browser.support.sameSite) || false;

  return hasSupport ? 'none' : false;
};

/**
 * Generates cookie options object from request info
 *
 * @param {Express.Request} req Request
 * @returns Cookie options object
 */
const generateCookieOptions = (req) => {
  const domain = config.get('url.mainDomain.link', req.platform.id, req.platform.siteId);

  return {
    domain,
    httpOnly: true,
    secure: true,
    sameSite: getSameSiteValue(req),
  };
};

/**
 * Invokes access_token cookie setting from query string
 */
const setAccessTokenCookie = (accessToken, req, res) => {
  if (accessToken) {
    res.cookie(ACCESS_TOKEN_COOKIE_NAME, accessToken, { ...generateCookieOptions(req), sameSite: false });
  }
};

/**
 * Clears SSID Session Cookie
 *
 * @param {Express.Request} req Request
 * @param {Express.Response} res Response
 */
exports.clearSessionCookie = (req, res) => {
  res.clearCookie(SESSION_COOKIE_NAME, generateCookieOptions(req));
};

/**
 * Is the client ID valid for user authentication
 *
 * @param {number | string} clientId Access Token client ID
 * @returns {boolean}
 */
const isValidClientId = (clientId) => {
  const id = typeof clientId === 'string' ? Number.parseInt(clientId, 10) : clientId;

  return NATIVE_APPS_CLIENT_IDS.includes(id);
};
exports.isValidClientId = isValidClientId;

/**
 * Validate that the access token is secure.
 *
 * @param {object} [accessTokenInfo] AT Info (session)
 * @returns {boolean}
 */
const isSecureAccessToken = (accessTokenInfo) => {
  if (accessTokenInfo) {
    return isValidClientId(accessTokenInfo.client_id);
  }
  return false;
};
exports.isSecureAccessToken = isSecureAccessToken;

const sessionRegex = /^[\w\d_-]+$/;
const webSessionRegex = /^ghy-\d{6}-\w+-__-\d+-__-\d+--[A-Z]+_\d+-[A-Z]+_\d+$/;

/**
 * @param {string} cookie Session Cookie
 */
const isValidCookie = cookie => cookie.startsWith('ghy')
  && (!env.PRODUCTION || webSessionRegex.test(cookie));

/**
 * @param {string} token Access Token
 */
exports.isValidAccessToken = token => sessionRegex.test(token);

/**
 * Returns the session cookie for the logged user.
 */
exports.getSessionCookie = (req) => {
  const cookie = req.cookies && req.cookies[SESSION_COOKIE_NAME] && req.cookies[SESSION_COOKIE_NAME] !== '0'
    ? req.cookies[SESSION_COOKIE_NAME] : null;

  if (cookie && !isValidCookie(cookie)) {
    return null;
  }

  return cookie;
};

/**
 * Generate a JSON object for xhr responses
 * @param {number} httpCode A valid HTTP status code
 * @param {object} data Any additional data that should be included
 * @return {{code: number, message: string, data: object}}
 */
const getJsonResponse = (httpCode, data = {}) => ({
  message: http.STATUS_CODES[httpCode] || '',
  data: { ...data }, // Maintain legacy structure
  ...data,
});
exports.getJsonResponse = getJsonResponse;

/**
 * Redirects to the login page.
 */
exports.handleUnauthenticatedReq = (req, res, next) => {
  const url = getLoginURL(req);

  if (!url) {
    return next(new Error('Cannot generate the URL to redirect to login. Please check the request parameters'));
  }

  if (req.xhr) {
    return res.status(401).json(getJsonResponse(401, { url, login: url }));
  }

  return res.redirect(302, url);
};

/**
 * Redirects to the failed authorization URL.
 */
exports.handleUnauthorizedReq = (req, res, next) => {
  const url = unauthorizedURL(req);

  if (!url) {
    const error = new Error('Cannot generate the redirect URL.');
    logger.error(error.message, {
      user: req.auth.user.id,
      platformId: req.platform ? req.platform.id : 'unavailable',
      siteId: req.platform ? req.platform.siteId : 'unavailable',
    });
    return next(error);
  }

  if (req.xhr) {
    return res.status(401).json(getJsonResponse(401, { url, login: url }));
  }

  return res.redirect(302, url);
};

/**
 * Returns if a given admin is authorized.
 * If the user is an admins and admins are not allowed, the admin is restricted.
 *
 * @param {boolean} isAdminUser User is an admin user (impersonalized user)
 * @param {string[]} adminAllowedMethods Array with allowed request methods for admins
 * @param {string} requestMethod Current request method
 * @returns {boolean} Value representing if request should be blocked for admin users
 */
exports.isAdminRestricted = (isAdminUser, adminAllowedMethods, requestMethod) => isAdminUser
  && !adminAllowedMethods.includes(requestMethod);

/**
 * Returns if a given user is authorized.
 * There are two conditions to be accomplished:
 * 1. operators: checks if operators are not allowed and if the user is an operator.
 * 2. status: checks if the user status should be ignored.
 */
exports.isAuthorized = (user, opts) => {
  // If operators are not allowed and the user is an operator, the user is not authorized.
  const operators = !(!opts.allowOperators && user.operator);
  // If the user status should be ignored, always use the ignoreUserSiteStatus value (true).
  // If not use the user.active value.
  const status = opts.ignoreUserSiteStatus || user.active;
  // Both conditions should be accomplished.
  return operators && status;
};

/**
 * If we can't trust session resolved by 'authenticate'
 * or we need to resolve again due to specific options
 *
 * @param {Express.Request} req Request
 * @param {import('../types').AuthenticationOptions} options Authorization options
 * @returns {boolean}
 */
exports.shouldResolveUserAgain = (req, options = {}) => {
  if (!req.auth) {
    return false;
  }

  const { navigateAsOperator, allowWebviewAuthentication } = options;
  const { operator, operatorId, id: userId } = req.auth.user;

  return !!((operator && navigateAsOperator && operatorId !== userId)
    || (!allowWebviewAuthentication && req.auth.session.access_token));
};

/**
 * Returns if a given request is being handled by middleware http
 * This happens only when it's value is true
 * By default all the public proxies (F5, cloudfront) inject 'x-handled-by-middleware': 'false'
 */
exports.isHandledByMiddleware = req => req
  .header(MIDDLEWARE_HEADERS.HANDLED_BY_MIDDLEWARE) === 'true'
    && env.ENABLE_TRAFFIC_MIDDLEWARE === 'true';

/**
 * Returns an userId if a given header ('x-session-user-id') have been correctly parsed
 * Should always exists and also should be a number otherwise it is an invalid session
 */
function getUserIdFromHeader(userIdHeaderString) {
  const userId = parseInt(userIdHeaderString, 10);
  if (Number.isNaN(userId)) {
    throw new TypeError(`Invalid userid: ${userIdHeaderString}`);
  }
  return userId;
}

/**
 * Returns an array with elements that were splitted by commas and without blank spaces (sanitized).
 * Scopes should come with this form "scope1,scope2,scope3" but we decided to trim anyway just in case.
 * @param scopesHeaderString
 * @returns {string[]}
 */
function sanitizeScopes(scopesHeaderString) {
  const array = scopesHeaderString.split(',');
  return array.map(element => element.trim());
}

/**
 * Returns scopes if a given header ('x-session-caller-scopes') have been correctly parsed
 * Should always exists otherwise it is an invalid session
 */
function getCallerScopesFromHeader(scopesHeaderString) {
  if (!scopesHeaderString) {
    throw new TypeError(`Invalid caller-scopes: ${scopesHeaderString}`);
  }
  return sanitizeScopes(scopesHeaderString);
}

/**
 * Returns an operator id if a given header ('x-session-operator-id') have been correctly parsed
 * If it exists, should always be a number otherwise it is an invalid session
 */
function getOperatorIdFromHeader(operatorIdHeaderString) {
  const operatorId = operatorIdHeaderString ? parseInt(operatorIdHeaderString, 10) : null;
  if (Number.isNaN(operatorId)) {
    throw new TypeError(`Invalid operator id: ${operatorIdHeaderString}`);
  }
  return operatorId;
}

/**
 * Returns if a given header ('x-session-admin') represents an admin
 * If it exists, should always be true otherwise it is an invalid session
 */
function getAdminFromHeader(adminOtpHeaderString) {
  if (adminOtpHeaderString
    && adminOtpHeaderString !== 'true'
    && adminOtpHeaderString !== 'false') {
    throw new TypeError(`Invalid admin-otp: ${adminOtpHeaderString}`);
  }
  return adminOtpHeaderString === 'true';
}

/**
 * Returns a detached-id if a given header ('x-session-detached-id') have been correctly parsed.
 * Should always exists and also should be an uuid otherwise it is an invalid session.
 */
function getDetachedIdFromHeader(detachedIdHeaderString) {
  if (!detachedIdHeaderString) {
    throw new TypeError(`Invalid detached-id: ${detachedIdHeaderString}`);
  }
  return detachedIdHeaderString;
}

/**
 * Returns a site-id if a given header ('x-session-site-id') have been correctly parsed.
 * Should always exists and also should be an string otherwise it is an invalid session.
 */
function getSiteIdFromHeader(siteIdHeaderString) {
  if (!siteIdHeaderString) {
    throw new TypeError(`Invalid site-id: ${siteIdHeaderString}`);
  }
  return siteIdHeaderString;
}

/**
 * Returns an client-id if a given header ('x-session-client-id') have been correctly parsed
 * If it exists, should always be a number otherwise it is an invalid session.
 */
function getClientIdFromHeader(clientIdHeaderString) {
  const clientId = clientIdHeaderString ? parseInt(clientIdHeaderString, 10) : null;
  if (Number.isNaN(clientId)) {
    throw new TypeError(`Invalid client id: ${clientIdHeaderString}`);
  }
  return clientId;
}

/**
 * Returns if a given request have been correctly parsed
 * This means that all the headers of a session got through all the strong validations
 * The result is a JSON object with a valid session otherwise an exception could be thrown
 */
exports.getSessionFromHeadersSync = (headers) => {
  const {
    SCOPES, USER_ID, OPERATOR_ID, ADMIN_SESSION, DETACHED_ID, SITE_ID, CLIENT_ID,
  } = MIDDLEWARE_HEADERS;

  return {
    scopes: getCallerScopesFromHeader(headers[SCOPES]),
    user_id: getUserIdFromHeader(headers[USER_ID]),
    operator_id: getOperatorIdFromHeader(headers[OPERATOR_ID]),
    admin_otp: getAdminFromHeader(headers[ADMIN_SESSION]),
    detached_id: getDetachedIdFromHeader(headers[DETACHED_ID]),
    site_id: getSiteIdFromHeader(headers[SITE_ID]),
    client_id: getClientIdFromHeader(headers[CLIENT_ID]),
  };
};

const getTokenFromHeaderAuthorization = headerAuthorization => headerAuthorization
  && headerAuthorization.startsWith('Bearer ')
  && headerAuthorization.replace('Bearer ', '');

exports.setAccessTokenCookieIfApplies = (req, res) => {
  const isWebview = req.device && req.device.webView;
  const isLoggedIn = !!req.auth;

  if (isWebview
    && isLoggedIn
    && isSecureAccessToken(req.auth.session)) {
    setAccessTokenCookie(req.auth.session.access_token, req, res);
  }
};

exports.getTokenFromRequest = (req) => {
  let token = getTokenFromHeaderAuthorization(req.header(AUTHORIZATION_HEADER));
  if (token) {
    return [token, 'header_auth'];
  }

  token = req.header(ACCESS_TOKEN_HEADER);
  if (token) {
    return [token, 'header_at_custom'];
  }

  if (req.query.accessToken) {
    return [req.query.accessToken, 'qs_accessToken'];
  }

  if (req.query.access_token) {
    return [req.query.access_token, 'qs_access_token'];
  }

  if ((req.cookies && req.cookies[ACCESS_TOKEN_COOKIE_NAME])) {
    return [req.cookies[ACCESS_TOKEN_COOKIE_NAME], 'cookie_nat'];
  }

  return [];
};
