/**
 * @jest-environment jsdom
 */

const { appendImage, defaults, triggerLoadEvent } = require('./utils');

describe('OnLoad images && lazy images && window.onload && document.readyState === complete', () => {
  afterEach(() => {
    const images = document.getElementsByTagName('IMG');

    for (let i = 0; i < images.length; i += 1) {
      const image = images[i];
      image.remove();
    }
    document.getElementsByTagName('html')[0].innerHTML = '';
  });

  beforeAll(() => {
    Object.defineProperty(document, 'readyState', {
      get() { return 'loading'; },
    });

    require('../src');
  });

  test('lazy and onload image should change data-src and delete class only for the provided node', () => {
    const url = 'http:/url/to/image';

    const imageWithoutLazy = appendImage({
      classes: [defaults.lazyLoadClassName],
      dataSrc: url,
    });

    const imageLazy = appendImage({
      classes: [defaults.lazyLoadClassName],
      dataSrc: url,
    });

    const imageWithoutOnload = appendImage({
      classes: [defaults.onloadClassName],
      dataSrc: url,
    });

    const imageLoad = appendImage({
      classes: [defaults.onloadClassName],
      dataSrc: url,
    });

    window.imageLazyLoading(defaults.lazyLoadClassName, { loadMode: 'lazy' }, imageWithoutLazy);
    window.imageLazyLoading(defaults.onloadClassName, { loadMode: 'onload' }, imageWithoutOnload);

    triggerLoadEvent();

    expect(imageWithoutLazy.classList).not.toContain(defaults.lazyLoadClassName);
    expect(imageWithoutOnload.classList).not.toContain(defaults.onloadClassName);
    expect(imageLazy.classList).toContain(defaults.lazyLoadClassName);
    expect(imageLoad.classList).toContain(defaults.onloadClassName);
  });

  test('lazy and onload image should change data-src and delete class in case of node is undefined or null', () => {
    const url = 'http:/url/to/image';

    const imageWithoutLazy = appendImage({
      classes: [defaults.lazyLoadClassName],
      dataSrc: url,
    });

    const imageLazy = appendImage({
      classes: [defaults.lazyLoadClassName],
      dataSrc: url,
    });

    const imageWithoutOnload = appendImage({
      classes: [defaults.onloadClassName],
      dataSrc: url,
    });

    const imageLoad = appendImage({
      classes: [defaults.onloadClassName],
      dataSrc: url,
    });

    window.imageLazyLoading(defaults.lazyLoadClassName, { loadMode: 'lazy' });
    window.imageLazyLoading(defaults.onloadClassName, { loadMode: 'onload' });

    triggerLoadEvent();

    expect(imageWithoutLazy.classList).not.toContain(defaults.lazyLoadClassName);
    expect(imageWithoutOnload.classList).not.toContain(defaults.onloadClassName);
    expect(imageLazy.classList.length).toEqual(0);
    expect(imageLoad.classList.length).toEqual(0);
  });

  test('multiple lazy and onload images should change data-src and delete class since there is only one', () => {
    const url = 'http:/url/to/image';

    appendImage({
      classes: [defaults.lazyLoadClassName],
      dataSrc: url,
    });

    appendImage({
      classes: [defaults.lazyLoadClassName],
      dataSrc: url,
    });

    appendImage({
      classes: [defaults.onloadClassName],
      dataSrc: url,
    });

    appendImage({
      classes: [defaults.onloadClassName],
      dataSrc: url,
    });

    window.imageLazyLoading(defaults.onloadClassName, { loadMode: 'onload' });
    window.imageLazyLoading(defaults.lazyLoadClassName, { loadMode: 'lazy' });

    triggerLoadEvent();

    const images = document.getElementsByTagName('IMG');

    for (let i = 0; i < images.length; i += 1) {
      const image = images[i];
      const urlInImage = image.getAttribute(defaults.src);
      const dataSrc = image.getAttribute(defaults.dataSrc);

      expect(urlInImage).toBe(url);
      expect(dataSrc).toBe(null);
      expect(image.classList).toHaveLength(0);
    }
  });

  test('multiple onload and lazy (with default params) images should change data-src and delete class since there is only one', () => {
    const url = 'http:/url/to/image';

    appendImage({
      classes: [defaults.lazyLoadClassName],
      dataSrc: url,
    });

    appendImage({
      classes: [defaults.lazyLoadClassName],
      dataSrc: url,
    });

    appendImage({
      classes: [defaults.onloadClassName],
      dataSrc: url,
    });

    appendImage({
      classes: [defaults.onloadClassName],
      dataSrc: url,
    });

    window.imageLazyLoading();
    window.imageLazyLoading(defaults.onloadClassName, { loadMode: 'onload' });

    triggerLoadEvent();

    const images = document.getElementsByTagName('IMG');

    for (let i = 0; i < images.length; i += 1) {
      const image = images[i];
      const urlInImage = image.getAttribute(defaults.src);
      const dataSrc = image.getAttribute(defaults.dataSrc);

      expect(urlInImage).toBe(url);
      expect(dataSrc).toBe(null);
      expect(image.classList).toHaveLength(0);
    }
  });

  test('lazy and onload images should set fallback image and remove data-src-fallback attribute', () => {
    const url = 'http:/url/to/image';
    const urlFallback = 'http:/url/to/fallback';

    const { setAttribute } = global.HTMLImageElement.prototype;
    global.HTMLImageElement.prototype.setAttribute = function (qualifiedName, value) {
      setAttribute.apply(this, [qualifiedName, value]);
      if (qualifiedName === 'src' && value === url && typeof this.onerror === 'function') {
        this.onerror.apply(this);
      }
    };

    appendImage({
      classes: [defaults.lazyLoadClassName],
      dataSrc: url,
      dataSrcFallback: urlFallback,
    });

    window.imageLazyLoading();
    window.imageLazyLoading(defaults.onloadClassName, { loadMode: 'onload' });

    triggerLoadEvent();

    const images = document.getElementsByTagName('IMG');
    const first = images[0];

    const urlInImage = first.getAttribute(defaults.src);
    const urlInSrcSetImage = first.getAttribute(defaults.srcSet);
    const dataSrc = first.getAttribute(defaults.dataSrc);
    const dataSrcFallback = first.getAttribute(defaults.dataSrcFallback);

    expect(urlInImage).toBe(urlFallback);
    expect(urlInSrcSetImage).toBe(urlFallback);
    expect(dataSrc).toBe(null);
    expect(dataSrcFallback).toBe(null);
    expect(first.classList).toHaveLength(0);

    global.HTMLImageElement.prototype.setAttribute = setAttribute;
  });
});

