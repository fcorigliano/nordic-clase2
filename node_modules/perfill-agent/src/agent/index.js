const { supportsEnvironment } = require('./support');
const { queue } = require('./subscriptions');
const { agentKey } = require('../constants/agent');
const initiatives = require('./initiatives');

const settings = {};

const initialize = () => (settings.initiatives || [])
  .forEach((initiative) => {
    if (initiative && initiative.id && initiatives[initiative.id]) {
      initiatives[initiative.id].start(settings, initiative);
    }
  });

const deferInitialization = () => {
  // eslint-disable-next-line no-unused-expressions
  window.requestIdleCallback
    ? window.requestIdleCallback(initialize, { timeout: 2000 })
    : setTimeout(initialize, 500);
};

let started = false;
const start = () => {
  if (started || !supportsEnvironment()) {
    return;
  }
  started = true;

  if (window.document.readyState === 'complete') {
    deferInitialization();
  } else {
    window.addEventListener('load', deferInitialization);
  }
};

const commands = {
  set: (key, val) => {
    settings[key] = val;
  },
  queue,
  send: (cmd) => {
    if (cmd in commands) {
      commands[cmd]();
    }
  },
  start,
};

const executeCommand = (args) => {
  try {
    const action = args[0];
    const actionInCommands = commands[action];
    if (action && actionInCommands) {
      // eslint-disable-next-line prefer-spread
      actionInCommands.apply(null, [].slice.call(args, 1));
    }
  // eslint-disable-next-line no-empty
  } catch (e) {
  }
};

const patchCommands = () => {
  window[agentKey] = (args) => executeCommand(args);
};

const perfill = () => {
  const commandsQueue = (window[agentKey] || {}).q || [];
  patchCommands();
  try {
    commandsQueue.forEach(executeCommand);
  // eslint-disable-next-line no-empty
  } catch (e) {
  }
};

module.exports = perfill;
