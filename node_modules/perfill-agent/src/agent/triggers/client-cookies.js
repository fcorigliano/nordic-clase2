const { CLIENT_COOKIES } = require('../../constants/initiatives');
const {
  commands,
  endpoint,
} = require('../../constants/client-cookies');
const { subscribe } = require('../subscriptions');
const { beaconWithFetchFallback } = require('../utils/send');
const { objectOperator } = require('../utils/spread');
const {
  prepareClientInfo,
  prepareTags,
} = require('../builder/commons');

let cookies = [];

const getSingleValue = (values) => {
  if (values.length !== 1 || !values[0]) {
    throw new Error();
  }
  return values[0];
};

const metadata = {
  path: getSingleValue,
  domain: getSingleValue,
  expires: getSingleValue,
  samesite: getSingleValue,
  'max-age': values => {
    const parsed = parseInt(getSingleValue(values), 10);
    if (Number.isNaN(parsed)) {
      throw new Error();
    }
    return parsed;
  },
  secure: values => {
    if (values.length) {
      throw new Error();
    }
    return true;
  },
};

const addToUnknownData = (data, metadataString) => {
  data['unknown-metadata'] = `${(data['unknown-metadata'] ? `${data['unknown-metadata']};` : '')}${metadataString}`;
};

const getCookieData = (cookieString) => {
  if (!cookieString) {
    return null;
  }

  const data = cookieString
    .split(';')
    .reduce((temporalData, value, index) => {
      const trimmedValue = value.trim();

      // discard empty parts
      if (!trimmedValue) {
        return temporalData;
      }

      const assignmentParts = trimmedValue
        .split('=')
        .map(part => part.trim());

      const key = assignmentParts[0];

      if (!index) {
        // Cookie key = cookie value
        if (key && assignmentParts.length === 2) {
          temporalData.name = key;
        }
        return temporalData;
      }

      const lowercasedKey = key.toLowerCase();
      const metadataFormatter = metadata[lowercasedKey];
      if (metadataFormatter) {
        try {
          temporalData[lowercasedKey] = metadataFormatter(assignmentParts.slice(1));
        } catch (e) {
          addToUnknownData(temporalData, value);
        }
      } else {
        addToUnknownData(temporalData, value);
      }

      return temporalData;
    }, {
      name: null,
      path: null,
      domain: null,
      'max-age': null,
      expires: null,
      samesite: null,
      secure: null,
      'unknown-metadata': null,
    });

  return data.name
    ? data
    : null;
};

const getRequestIdleCallback = window.requestIdleCallback || (callback => setTimeout(callback, 200));

let subscribedToPageUnload = false;
const subscribeToPageUnload = (settings) => {
  const visibilityChangeHandler = () => {
    if (window.document.visibilityState === 'hidden') {
      const clientInfo = prepareClientInfo();
      const tags = prepareTags(settings);
      beaconWithFetchFallback(endpoint, objectOperator({ clientInfo, tags, cookies }));
      cookies = [];

      window.document.removeEventListener('visibilitychange', visibilityChangeHandler);
      subscribedToPageUnload = false;
    }
  };

  if (!subscribedToPageUnload) {
    // TODO - listen to pagehide on safari? https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_event
    window.document.addEventListener('visibilitychange', visibilityChangeHandler);
    subscribedToPageUnload = true;
  }
};

const setCookieHandler = (cookieValue, settings) => {
  const data = getCookieData(cookieValue);
  if (data) {
    cookies.push(data);
    subscribeToPageUnload(settings);
  }
};

const commandHandlers = {
  [commands.SET_COOKIE]: setCookieHandler,
};

const monitor = (settings) => {
  subscribe(CLIENT_COOKIES, (commandData) => {
    if (commandData && commandHandlers[commandData.type]) {
      getRequestIdleCallback(() => commandHandlers[commandData.type](commandData.data, settings));
    }
  });
};

module.exports = monitor;
