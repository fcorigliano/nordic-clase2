/* eslint-disable security/detect-object-injection */
const fs = require('fs');
const path = require('path');
const url = require('url');
const jsesc = require('jsesc');
const pkg = require('./package.json');
const config = require('./config/analytics');
const optimizeConfig = require('./config/optimize');
const AnalyticsCache = require('./analytics_cache/analytics-cache');

const VERSION = `nodejs-${pkg.version}`;
const DEFAULT_PLATFORM = 'ml';
const MERCADO_SHOPS_PLATFORM = 'ms';
const { SCOPE, NODE_ENV } = process.env;
const analyticsCache = new AnalyticsCache();

// eslint-disable-next-line security/detect-non-literal-fs-filename
const meliGAWebviewsLibContent = fs.readFileSync(path.join(__dirname, '/lib/meli-ga-webviews.js'), 'utf-8');
const isMercadoShops = (platform) => (platform === MERCADO_SHOPS_PLATFORM);

/*
 * USE THIS TAG INSIDE <HEAD/>
 * Generates a script tag to download the corresponding Meli Analytics tracker file.
 * The tracking for a given site and platform will resolve to
 * ga('set', 'page', '/{section_parameter}/{page_parameter}' );
 *
 * @attr siteId REQUIRED the tracker's site ID requested
 * @attr platform REQUIRED the tracker's platform. Marketplace = ('ML'), MercadoPago = ('MP'), TuCarro = ('TC'), MercadoShops = ('MS')
 * @attr section REQUIRED describes MELI's ecosystem section we're tracking. examples: ('vip'), ('checkout'), ('home'), ('registration')
 * @attr page the page name to use for tracking. This is OPTIONAL, if not provided weÂ´ll use request.forwardURI
 */
class Tracker {
  track(req = {}, options = { secure: true, section: '' }, nonceCSP, traceabilityConsent) {
    const siteId = options.siteId ? options.siteId.toLowerCase()
      : (req.platform ? req.platform.siteId : '').toLowerCase(); // eslint-disable-line
    const platform = options.platform ? options.platform.toLowerCase()
      : (req.platform ? req.platform.id : '').toLowerCase(); // eslint-disable-line
    // Page to track
    const page = options.page ? options.page.trim() : null;

    const {
      staging,
      section,
      secure,
      search,
      dimensions,
      metrics,
      pathFromRoot,
      business,
      pageVertical,
      pageLayout,
      pageCategoryL1,
      privatePage,
      isDeferred,
      enableOptimize,
      optimizeId,
    } = options;

    let { preventOptimizeFlickering } = options;

    const device = req && req.device ? req.device : {};

    if (siteId && platform && section) {
      const isWebview = device.webView;
      const deviceLayout = `${device.forced ? 'forced_' : ''}${isWebview ? 'webview' : device.type}`;
      const deviceLowEnd = device.lowEnd;
      const pluginVersion = this.gaSetCustomCode({ title: this.getVersion() });
      preventOptimizeFlickering = isWebview ? false : preventOptimizeFlickering;

      const scriptURL = NODE_ENV === 'production'
        ? this.getProductionUrl(req, siteId, platform, secure, staging) : this.getDevelopmentUrl(req, secure);

      let modPage = this.getTrackerPage(req, section, page);

      // BuyingFlow track migration: Add section to maintain the same track
      let customPrivatePage;
      if (privatePage) {
        customPrivatePage = this.getTrackerPage(req, section, privatePage);
      }

      const categoryLevelsDimensions = this.getCategoryLevelsDimensions(platform, pathFromRoot);

      if (search) {
        // Add the corresponding query string for the site search analytics functionality
        const query = encodeURIComponent(search.toLowerCase());
        modPage += `?q=${query}`;
        const category = this.getSearchCategory(platform, categoryLevelsDimensions);

        if (category) {
          modPage += `&c=${category}`;
        }
      }

      const customDimensions = this.getCustoms(platform, 'dimensions', dimensions);
      const customMetrics = this.getCustoms(platform, 'metrics', metrics);
      const experimentsData = this.getExperimentsData(req, platform, customDimensions);

      const customContentGroups = this.getContentGroups(platform, { modPage }, {
        business,
        pageVertical,
        pageCategoryL1,
      });

      const pageDimensions = this.getDimensions(platform, {
        deviceLayout,
        pageLayout,
        business,
        pageVertical,
        privatePage: customPrivatePage,
        deviceLowEnd,
      });

      let customsCode = '';
      customsCode += this.gaSetCustomCode(customDimensions);
      customsCode += this.gaSetCustomCode(categoryLevelsDimensions);
      customsCode += this.gaSetCustomCode(customMetrics);
      customsCode += this.gaSetCustomCode(customContentGroups);
      customsCode += this.gaSetCustomCode(pageDimensions);
      customsCode += this.gaSetCustomCode(experimentsData);

      let configuredOptimizeId;
      if (!isWebview) {
        configuredOptimizeId = optimizeId || this.getPreconfiguredOptimizeId(enableOptimize, platform, siteId);
        if (configuredOptimizeId) {
          customsCode += `\nmeli_ga('require', '${configuredOptimizeId}');`;
        }
      }

      const trackerCode = this.getTrackerCode({
        platform,
        scriptURL,
        pluginVersion,
        customsCode,
        modPage,
        isDeferred,
        isWebview,
        meliAnalyticsData: false,
        siteId,
        nonceCSP,
        traceabilityConsent,
      });

      // TODO: add meliAnalyticsData parameter
      return `${this.getOptimizeAntiflickeringCode(configuredOptimizeId,
        preventOptimizeFlickering)}${trackerCode}`;
    }

    const errorMsg = `Missing required parameter (siteId: ${siteId}, platform: ${platform}, section: ${section})`;
    return `new Image().src='//analytics.mercadolibre.com/error.gif?message=${encodeURIComponent(errorMsg)}';`;
  }

  getTrackerCodeForWeb({
    scriptURL,
    pluginVersion,
    customsCode,
    modPage,
    isDeferred,
    meliAnalyticsData,
    nonceCSP,
    traceabilityConsent,
  }) {
    const nonceCSPScriptTag = nonceCSP ? `nonce='${nonceCSP}'` : '';
    let meliIframeMin = `\n(function(a,b){a.GoogleAnalyticsObject=b;${
      meliAnalyticsData ? `a["MeliAnalyticsData"] = ${meliAnalyticsData};` : ''
    }a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)};a[b].l=1*new Date})(window,"meli_ga");`;
    meliIframeMin += pluginVersion;
    meliIframeMin += `\nmeli_ga("set", "page", "${modPage}");`;
    meliIframeMin += customsCode;
    if (!isDeferred) {
      meliIframeMin += '\nmeli_ga("send", "pageview");';
    }
    meliIframeMin += `\n(function(d, win) {
      win['GA-user-traceability-consent'] = ${traceabilityConsent};
      var i = d.createElement('iframe');
      (i.frameElement || i).style.cssText = 'width: 0; height: 0; border: 0; position: absolute';
      i.src = "about:srcdoc";
      i.srcdoc="\\<script\\ ${nonceCSPScriptTag} src='${scriptURL}'>\\</script\\>";
      i.id = "GoogleAnalyticsIframe";
      var w = d.getElementsByTagName('script')[0];
      w.parentNode.insertBefore(i, w);
      var doc = i.contentWindow.document;
      var s = doc.createElement('script');
      s.type = 'text/javascript';
      s.text ='window.inDapIF = true;';
      doc.documentElement.appendChild(s);
    })(document, window);\n`;

    return meliIframeMin;
  }

  getTrackerCodeForWebviews({
    customsCode,
    modPage,
    isDeferred,
    siteId,
  }) {
    let trackerCode = meliGAWebviewsLibContent;
    trackerCode += `\nmeli_ga("set", "page", "${modPage}");`;
    trackerCode += `\nmeli_ga("set", "trackerKey", "${siteId}");`;
    trackerCode += customsCode;
    if (!isDeferred) {
      trackerCode += '\nmeli_ga("send", "pageview");';
    }

    return trackerCode;
  }

  getTrackerCode({
    platform,
    scriptURL,
    pluginVersion,
    customsCode,
    modPage,
    isDeferred,
    isWebview,
    meliAnalyticsData,
    siteId,
    nonceCSP,
    traceabilityConsent,
  }) {
    return (isWebview && !isMercadoShops(platform))
      ? this.getTrackerCodeForWebviews({
        customsCode, modPage, isDeferred, siteId,
      })
      : this.getTrackerCodeForWeb({
        scriptURL, pluginVersion, customsCode, modPage, isDeferred, meliAnalyticsData, nonceCSP, traceabilityConsent,
      });
  }

  /**
   * Detects is the request is secure
   *
   * @param {Request} req A request object
   * @param {boolean} forceSecure Override the request and force it to secure
   * @returns {boolean}
   */
  isSecureRequest(req, forceSecure) {
    if (!req) {
      return false;
    }

    return (forceSecure
      || (req.headers && Number(req.headers.ml_ssl) === 1)
      || !!(req.connection && req.connection.encrypted));
  }

  getDevelopmentUrl(req, forceSSL) {
    const partialUrl = '.mlstatic.com/org-img/analytics/debug-ml-analytics.js';

    if (this.isSecureRequest(req, forceSSL)) {
      return `https://secure${partialUrl}`;
    }

    return `http://static${partialUrl}`;
  }

  getProductionUrl(req, siteId, platform, forceSSL, staging) {
    const platformSlug = isMercadoShops(platform) ? 'mshops' : platform;
    const trackerFile = `${siteId}-${platformSlug}-analytics.min.js`;
    const pathGA = (SCOPE === 'analytics_staging' || staging) ? 'ga-staging' : 'ga';
    const protocol = this.isSecureRequest(req, forceSSL) ? 'https' : 'http';
    const urlGA = `${protocol}://http2.mlstatic.com/analytics/${pathGA}/${trackerFile}`;
    return urlGA;
  }

  getVersion() {
    const {
      APP, APPLICATION, DEPT, PLATFORM,
    } = process.env;

    if (PLATFORM === 'fury') {
      const name = (APPLICATION || 'dept-dev').toLowerCase();
      return `app-${name}-${VERSION}`;
    }

    const name = (APP || 'dev').toLowerCase();
    const department = (DEPT || 'dept').toLowerCase();
    return `app-${department}-${name}-${VERSION}`;
  }

  getConfigByPlatform(platform) {
    return config[platform] || config[DEFAULT_PLATFORM];
  }

  getTrackerPage(req, section, page) {
    if (page != null) {
      // We check != null because an "" value coming from attrs IS VALID (it translates to page=/SECTION/)
      let trackerPage = `/${section ? section.toUpperCase() : ''}/${page.toUpperCase()}`.replace(/\/{2,}/g, '/');
      if (trackerPage[trackerPage.length - 1] !== '/') {
        trackerPage += '/';
      }

      return trackerPage;
    }

    const urlObject = url.parse(req.url);
    const { pathname } = urlObject;
    const forwardURI = pathname.indexOf('?') !== -1 ? pathname.substring(0, pathname.indexOf('?')) : pathname;

    return `/${section ? section.toUpperCase() : ''}${forwardURI.toUpperCase()}`.replace(/\/{2,}/g, '/');
  }

  getCustoms(platform, type, customs) {
    const map = {};

    if (customs) {
      for (const name in customs) {
        if (Object.prototype.hasOwnProperty.call(customs, name)) {
          const dimensionId = this.getCustomDimensionId(platform, type, name, analyticsCache);
          if (dimensionId !== undefined && dimensionId !== '') {
            map[dimensionId] = customs[name];
          }
        }
      }
    }

    return map;
  }

  getCustomDimensionId(platform, type, name, cache) {
    let dimensionId = cache.getCustoms(platform, type, name);
    if (!dimensionId) {
      const platformConfig = this.getConfigByPlatform(platform);
      if (platformConfig.customs[type] && platformConfig.customs[type][name]) {
        dimensionId = platformConfig.customs[type][name];
      } else {
        dimensionId = cache.getCustoms(DEFAULT_PLATFORM, type, name);
      }
    }
    return dimensionId;
  }

  getCategoryLevelsDimensions(platform, pathFromRoot) {
    const paths = {};
    const platformConfig = this.getConfigByPlatform(platform);

    if (pathFromRoot && pathFromRoot.length > 0 && platformConfig.pathFromRoot) {
      const limit = Object.keys(platformConfig.pathFromRoot).length;
      let previousLevel;

      for (let i = 0; i < pathFromRoot.length && i < limit; i += 1) {
        const level = pathFromRoot[i];
        const currentLevel = `L${i + 1}`;
        const levelDimension = platformConfig.pathFromRoot[currentLevel];

        if (levelDimension) {
          let levelPath = this.createJsonEntry(level.id, level.name);
          if (previousLevel) {
            levelPath = `${previousLevel},${levelPath}`;
          }
          previousLevel = levelPath;
          paths[levelDimension] = `{${levelPath}}`;
        }
      }
    }

    return paths;
  }

  createJsonEntry(key, value) {
    const escConfig = { json: true, quotes: 'single' };
    let category = `${jsesc(key, escConfig)}:`;

    if (typeof value !== 'boolean' || Number.isNaN(value)) {
      category += jsesc(value, escConfig);
    } else {
      category += value;
    }

    return category;
  }

  getSearchCategory(platform, categoryLevelsDimensions) {
    let category = null;

    if (categoryLevelsDimensions) {
      const platformConfig = this.getConfigByPlatform(platform);
      const l1Category = categoryLevelsDimensions[platformConfig.pathFromRoot.L1];

      if (l1Category) {
        category = l1Category;
      }
    }
    return category;
  }

  getContentGroups(platform, track, groups) {
    if (track.modPage && track.modPage.indexOf('?') !== -1) {
      track.modPage = track.modPage.substring(0, track.modPage.indexOf('?')); // eslint-disable-line
    }

    const customGroups = {};
    if (groups) {
      const platformConfig = this.getConfigByPlatform(platform);

      for (const groupKey in groups) { // eslint-disable-line
        const groupValue = groups[groupKey];
        const group = platformConfig.contentGroups && platformConfig.contentGroups[groupKey];

        if (group && groupValue) {
          const value = this.getAllowedValue(groupValue, group);
          customGroups[group.name] = this.formatGroupValue(groupKey, value, track, group.format);
        } else if (group && group.name) {
          // Default to /NONE/$modPage
          customGroups[group.name] = `/NONE/${track.modPage}`.toUpperCase().replace(/\/{2,}/g, '/');
        }
      }
    }

    return customGroups;
  }

  getAllowedValue(value, entity) {
    let allowedValue = value;

    if (value) {
      if (Array.isArray(entity.valuesAllowed)) {
        const allowed = entity.valuesAllowed.find((val) => val === value.toUpperCase());

        if (!allowed) {
          allowedValue = 'NONE';
        }
      }
    } else {
      allowedValue = 'NONE';
    }

    return allowedValue;
  }

  formatGroupValue(groupKey, groupValue, track, format) {
    let groupDimensionValue = '/';

    for (let i = 0; i < format.length; i += 1) {
      const part = format[i];

      if (part === groupKey) {
        groupDimensionValue += groupValue ? `${groupValue}/` : '';
      } else {
        groupDimensionValue += `${track[part]}/`;
      }
    }

    return groupDimensionValue.toUpperCase().replace(/\/{2,}/g, '/');
  }

  getDimensions(platform, dimensionMap) {
    const dimensions = {};

    if (dimensionMap) {
      const platformConfig = this.getConfigByPlatform(platform);
      for (const name in dimensionMap) {
        if (Object.prototype.hasOwnProperty.call(dimensionMap, name)) {
          const value = dimensionMap[name];
          const dimension = platformConfig.dimensions[name];

          if (dimension) {
            if (dimension.nullable && (!value || value === '')) {
              // Ignore this dimension
            } else {
              dimensions[dimension.name] = this.getAllowedValue(value, dimension);
            }
          }
        }
      }
    }

    return dimensions;
  }

  /**
   * Generates the client-side ready code for setting the custom dimensions, metrics and any type of allowed GA fields.
   * For the complete list of allowed field types please @see https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference
   * Default type is `string`, only some fields can has `boolean` or `number` as its values
   *
   * @param map
   * @returns {string}
   */
  gaSetCustomCode(map) {
    let code = '';

    for (const key in map) {
      if (Object.prototype.hasOwnProperty.call(map, key)) {
        let val;
        if (['anonymizeIp', 'forceSSL', 'javaEnabled', 'nonInteraction'].indexOf(key) !== -1) {
          val = Boolean(map[key]);
        } else if (key === 'queueTime') {
          val = parseInt(map[key], 10);
        } else if (key.startsWith('metric')) { // The format of metric key is `metric{1..200}`
          val = parseFloat(map[key]);
        } else if (typeof map[key] !== 'string') {
          val = JSON.stringify(JSON.stringify(map[key])); // Should be stringified twice, first to convert to a string and second to wrap with a double quotes
          if (key.startsWith('dimension')) { // The format of dimension key is `dimension{1..200}`
            val = val.replace(/\\"/g, '\''); // Defined by Meli format to receive the objects is a JSON stringified value but with single quotes
          }
        } else {
          val = JSON.stringify(map[key]).replace(/\\\\u/g, '\\u'); // It's a string, just wrap with a double quotes
        }

        code += `\nmeli_ga("set", "${key}", ${val});`;
      }
    }

    return code;
  }

  /**
   * Generates the Google Optimize anti-flickering code
   * @see https://support.google.com/optimize/answer/7100284
   *
   * @param optimizeId string
   * @param useAntiflickering boolean
   * @returns {string}
   */
  getOptimizeAntiflickeringCode(optimizeId, useAntiflickering = false) {
    if (!optimizeId || !useAntiflickering) {
      return '';
    }

    return `(function(a,s,y,n,c,h,i,d,e){try {var st = a.document.createElement('style');
st.appendChild(a.document.createTextNode(''));a.document.head.appendChild(st);
st.sheet.insertRule('.'+y+' {opacity: 0 !important}');} catch(ex){}
s.className+=' '+y;h.start=1*new Date;
h.end=i=function(){s.className=s.className.replace(RegExp(' ?'+y),'')};
(a[n]=a[n]||[]).hide=h;setTimeout(function(){i();h.end=null},c);h.timeout=c;
})(window,document.documentElement,'async-hide','dataLayer',4000,{'${optimizeId}':true});`;
  }

  /**
   * Returns the preconfigured ID for specified platform when exist and enabled
   * @param isOptimizeEnabled boolean
   * @param platform string
   * @param siteId string
   * @returns {string|null}
   */
  getPreconfiguredOptimizeId(isOptimizeEnabled, platform, siteId) {
    const siteConfig = isOptimizeEnabled && optimizeConfig[platform] && optimizeConfig[platform][siteId]
      ? optimizeConfig[platform][siteId]
      : null;

    return siteConfig ? siteConfig.id : null;
  }

  /**
   * Search for the experiments in the request object and assign it to the corresponding dimension name if it is defined
   * @param {object} req
   * @param {string} platform
   * @param {object} customDimensions
   * @return {object}
   */
  getExperimentsData(req, platform, customDimensions) {
    const { melidataTrack } = req;
    const dimensionName = this.getCustomDimensionId(platform, 'dimensions', 'melidataExperiments', analyticsCache);
    const experimentsData = {};

    let existingMelidataExperiments = {};
    if (customDimensions && customDimensions[dimensionName] && typeof customDimensions[dimensionName] === 'string') {
      try {
        existingMelidataExperiments = JSON.parse(customDimensions[dimensionName]);
      } catch (e) {
        existingMelidataExperiments = {};
      }
    }

    if (
      dimensionName
      && melidataTrack && melidataTrack.experiments
      && typeof melidataTrack.experiments === 'object' && Object.keys(melidataTrack.experiments).length
    ) {
      experimentsData[dimensionName] = { ...existingMelidataExperiments, ...this.getPlainExperiments(melidataTrack) }; // eslint-disable-line no-param-reassign
    }

    return experimentsData;
  }

  getPlainExperiments(melidataTrack) {
    const plainExperiments = {};
    Object.keys(melidataTrack.experiments)
      .forEach((exp) => {
        const variant = melidataTrack.experiments[exp];
        plainExperiments[exp] = Object.prototype.hasOwnProperty.call(variant, 'id') ? String(variant.id) : variant;
      });
    return plainExperiments;
  }
}

module.exports = Tracker;
