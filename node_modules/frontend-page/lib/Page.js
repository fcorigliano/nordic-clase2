module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 9);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var PAGES_PATH = './app/nordic-pages';
var PAGE_COMPONENTS_PATH = '**/ui-components/**';
var PAGE_TESTS_DIRECTORY_PATH = '**/__test?(s)__/**';
var PAGE_POLYFILLS_FILE = 'polyfills.js';
var FILES_IGNORED_IN_DISCOVERY = [PAGE_COMPONENTS_PATH, PAGE_TESTS_DIRECTORY_PATH, PAGE_POLYFILLS_FILE];
var hooksFilesIdentifier = {
  VIEW_SPECIFIC: 'hooks.server',
  BASE: '_hooks.server'
};
var discoveryFileExtensions = {
  SCRIPT: ['tsx', 'ts', 'jsx', 'js'],
  STYLE: ['scss', 'css']
};
var environments = {
  DEV: 'development',
  PROD: 'production',
  TEST: 'test'
};
var possibleDeviceTypes = ['desktop', 'mobile', 'tablet', 'webview'];
var discoveryDeviceTypes = [].concat(possibleDeviceTypes, ['base']);
var possibleAdaptiveOptions = {
  both: 'both',
  scripts: 'scripts',
  styles: 'styles'
};
var warnings = {
  MELIDATA: 'You are trying to use melidata but you are not specifying a path. ' + 'This is required for melidata to work. Melidata track will not be ' + 'rendered to the page',
  ANALYTICS: 'You are trying to use analytics but you are not specifying a ' + 'section. This is required for analytics to work. Analytics track will ' + 'not be rendered to the page',
  ROUTE_DISCOVERY: 'The following paths could not be processed correctly:'
};
module.exports = {
  PAGES_PATH: PAGES_PATH,
  PAGE_COMPONENTS_PATH: PAGE_COMPONENTS_PATH,
  PAGE_POLYFILLS_FILE: PAGE_POLYFILLS_FILE,
  PAGE_TESTS_DIRECTORY_PATH: PAGE_TESTS_DIRECTORY_PATH,
  FILES_IGNORED_IN_DISCOVERY: FILES_IGNORED_IN_DISCOVERY,
  hooksFilesIdentifier: hooksFilesIdentifier,
  discoveryDeviceTypes: discoveryDeviceTypes,
  discoveryFileExtensions: discoveryFileExtensions,
  environments: environments,
  possibleDeviceTypes: possibleDeviceTypes,
  possibleAdaptiveOptions: possibleAdaptiveOptions,
  warnings: warnings
};

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("frontend-analytics/meli-ga");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("frontend-melidata/melidata-track");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("frontend-script");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("frontend-style");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("serialize-javascript");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var logger = __webpack_require__(8);

var _require = __webpack_require__(0),
    possibleAdaptiveOptions = _require.possibleAdaptiveOptions;

var log = logger('frontend-page');

var isAdaptiveEnabled = function isAdaptiveEnabled(adaptive, adaptiveFor) {
  return possibleAdaptiveOptions.both === adaptive || possibleAdaptiveOptions[adaptiveFor] === adaptive;
};

module.exports = {
  isAdaptiveEnabled: isAdaptiveEnabled,
  log: log
};

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("frontend-logger");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(10);


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var REACT_ELEMENT_TYPE;

function _jsx(type, props, key, children) { REACT_ELEMENT_TYPE || (REACT_ELEMENT_TYPE = "function" == typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103); var defaultProps = type && type.defaultProps, childrenLength = arguments.length - 3; if (props || 0 === childrenLength || (props = { children: void 0 }), 1 === childrenLength) props.children = children;else if (childrenLength > 1) { for (var childArray = new Array(childrenLength), i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } if (props && defaultProps) for (var propName in defaultProps) { void 0 === props[propName] && (props[propName] = defaultProps[propName]); } else props || (props = defaultProps || {}); return { $$typeof: REACT_ELEMENT_TYPE, type: type, key: void 0 === key ? null : "" + key, ref: null, props: props, _owner: null }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* eslint-disable react/jsx-closing-tag-location */
var React = __webpack_require__(1);

var MeliGA = __webpack_require__(2);

var MelidataTrack = __webpack_require__(3);

var Script = __webpack_require__(4);

var Style = __webpack_require__(5);

var serialize = __webpack_require__(6);

var _require = __webpack_require__(0),
    possibleDeviceTypes = _require.possibleDeviceTypes,
    possibleAdaptiveOptions = _require.possibleAdaptiveOptions,
    warnings = _require.warnings;

var _require2 = __webpack_require__(7),
    log = _require2.log,
    isAdaptiveEnabled = _require2.isAdaptiveEnabled;

var Page = /*#__PURE__*/function (_React$Component) {
  _inherits(Page, _React$Component);

  var _super = _createSuper(Page);

  function Page() {
    _classCallCheck(this, Page);

    return _super.apply(this, arguments);
  }

  _createClass(Page, [{
    key: "getClassName",
    value:
    /**
     * Retrieves the className to be used for the wrapping div.
     * If a className is provided, that will be used, instead the name of the page will be used
     * @param {string} name - The page's name.
     * @param {string} className - Classname to be used.
     * @return {string} classname to be used
     */
    function getClassName(name, className) {
      return className || name;
    }
    /**
     * Retrieves style sheet file name, taking into consideration the adaptive strategy.
     * @param {string} deviceType - Current Device Type. can be mobile or desktop
     * @param {string} name - The page's name.
     * @param {string} adaptiveFor - String to detect whether we need to apply adaptive for styles
     * @return {string} Style sheet file to be rendered
     */

  }, {
    key: "getStyleSheetName",
    value: function getStyleSheetName(deviceType, name, adaptiveFor) {
      // TODO: in the future we could allow the developer to pass a function to generate the name of the file maybe,
      // in case they are using some different naming convention
      var styleSheetName = "".concat(name, ".css");

      if (deviceType && possibleDeviceTypes.includes(deviceType) && isAdaptiveEnabled(adaptiveFor, possibleAdaptiveOptions.styles)) {
        styleSheetName = "".concat(name, ".").concat(deviceType, ".css");
      }

      return styleSheetName;
    }
    /**
     * Retrieves the js file name, taking into consideration the adaptive strategy.
     * @param {string} deviceType - Current Device Type. can be mobile or desktop
     * @param {string} name - The page's name.
     * @param {string} adaptiveFor - String to detect whether we need to apply adaptive for scripts
     * @return {string} Js file to be rendered
     */

  }, {
    key: "getScriptName",
    value: function getScriptName(deviceType, name, adaptiveFor) {
      // TODO: in the future we could allow the developer to pass a function to generate the name of the file maybe,
      // in case they are using some different naming convention
      var scriptName = "".concat(name, ".js");

      if (deviceType && possibleDeviceTypes.includes(deviceType) && isAdaptiveEnabled(adaptiveFor, possibleAdaptiveOptions.scripts)) {
        scriptName = "".concat(name, ".").concat(deviceType, ".js");
      }

      return scriptName;
    }
    /**
     * Retrieves id for the page
     * @param {string} id - Id to be used.
     * @param {string} name - The page's name. This will be the default value
     * @return {string} Page id to be used
     */

  }, {
    key: "getIdForPage",
    value: function getIdForPage(id, name) {
      return id || name;
    }
    /**
     * Validates that a specific object is valid to be used as analytics props.
     * @param {object} analytics - Object with analytics props
     * @return {boolean} Returns true if the object is valid
     */

  }, {
    key: "isAnalyticsValid",
    value: function isAnalyticsValid(analytics) {
      var isValid = analytics && Object.prototype.hasOwnProperty.call(analytics, 'section');

      if (analytics && !Object.prototype.hasOwnProperty.call(analytics, 'section')) {
        log.warn(warnings.ANALYTICS);
      }

      return isValid;
    }
    /**
     * Validates that a specific object is valid to be used as melidata props.
     * @param {object} melidata - Object with analytics props
     * @return {boolean} Returns true if the object is valid
     */

  }, {
    key: "isMelidataValid",
    value: function isMelidataValid(melidata) {
      var isValid = melidata && Object.prototype.hasOwnProperty.call(melidata, 'path');

      if (melidata && !Object.prototype.hasOwnProperty.call(melidata, 'path')) {
        log.warn(warnings.MELIDATA);
      }

      return isValid;
    }
    /**
     * Validates that the conditions are met for the state to be rendered.
     * @param {object} state - Object with state
     * @param {boolean} scripts - Flag indicating that the page to be rendered has js scripts
     * @return {boolean} Returns true if the object is valid
     */

  }, {
    key: "canRenderState",
    value: function canRenderState(state, scripts) {
      return state !== null && scripts;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          name = _this$props.name,
          id = _this$props.id,
          className = _this$props.className,
          analytics = _this$props.analytics,
          melidata = _this$props.melidata,
          deviceType = _this$props.deviceType,
          state = _this$props.state,
          scripts = _this$props.scripts,
          styles = _this$props.styles,
          adaptiveFor = _this$props.adaptiveFor,
          children = _this$props.children;
      return /*#__PURE__*/_jsx("div", {
        className: this.getClassName(name, className),
        id: this.getIdForPage(id, name)
      }, void 0, children, this.isAnalyticsValid(analytics) && /*#__PURE__*/React.createElement(MeliGA, analytics), this.isMelidataValid(melidata) && /*#__PURE__*/React.createElement(MelidataTrack, melidata), styles && /*#__PURE__*/_jsx(Style, {
        href: this.getStyleSheetName(deviceType, name, adaptiveFor),
        critical: deviceType === 'mobile'
      }), this.canRenderState(state, scripts) && /*#__PURE__*/_jsx(Script, {}, void 0, "\n            window.__PRELOADED_STATE__ = ".concat(serialize(state, {
        isJSON: true
      }), ";\n          ")), scripts && /*#__PURE__*/_jsx(Script, {
        src: this.getScriptName(deviceType, name, adaptiveFor)
      }));
    }
  }]);

  return Page;
}(React.Component);

Page.defaultProps = {
  state: null,
  analytics: null,
  melidata: null,
  adaptiveFor: possibleAdaptiveOptions.both,
  className: '',
  deviceType: null,
  scripts: true,
  styles: true,
  id: ''
};
module.exports = Page;

/***/ })
/******/ ]);