# frontend-page

> A React Component that encapsulates most common components used on Nordic Pages

# What's the idea behind this component?
When using nordic, we noticed that we keep repeating a basic template for all the pages that we create:
```js
  <div className="page-class">
    <Melidata />
    <MeliGA />
    <Script src="page.js" />
    <Style hrf="page.css">
    <Script>
        {`
        window.__PRELOADED_STATE__ = ${serialize({ a bunch of props }, { isJSON: true })};
        `}
    </Script>

    <Your />
    <Page />
    <Starts />
  </div>
```

So, taking a look at this, we noticed that, if we are aware that we need to include those components to work,
why don't we put them on a separate component and save the developer the trouble of managing and worrying about
those components?

Also, these components tend to confuse and distract the developer from the actual page, basically just adding more
code to a Page that should only be worried on what the Page needs to do.

Moreover, we are adding a lot of repeated code to our Nordic Apps, making it sometimes a little bit complicated to manage and
maintain.  

That's where this component comes into place.

# Features
Ok, sounds great, but what can this component do? Or, what things can I forget about when implementing a page?
- Creates the encapsulating div for the Page, allowing you to set a specific class and id.
- Simple management of the MeliGA component
- Also provides management of the Melidata component
- Add styles to your page, allowing traditional and adaptive strategy names
- Adds the preloaded state to the page
- Manages script for the page, taking into consideration traditional and adaptive strategy names

## New Concept for a page
One IMPORTANT thing about this component, is that it introduces the idea of a specific name for each page.
Did you notice that everytime you create a page you repeat the same name for all the files
that you are adding to the page? as well as the ids for the divs you use to surround those components?
And also we use the same name for the folders?

On the main div usually created:
```js
  <div className="page" id="page"></div>
```

On the name for the js file:
```js
  <Script src="page.js" />
```

On the name for the css file:
```js
  <Style hrf="page.css">
```

Looking at this, we notice that we have the "page" string repeated over and over. That's what we are calling Page Name.

# Usage
So, how can I use this component?

## Creating a Page from scratch
Let's say I want to create a new page for my Nordic app, I create the necessary scaffolding, a folder for the page, a controller,
index.js file, another folder for the components and there I create a SomethingView.js file.

For this example, let's use Listing as the name for the page, just to make it friendly :)

So our scaffolding would look something like this:
```js
 listing
 - controller.js
 - index.js
 - listing.scss
 - ListingView.js
```

Now, let's create the page. We go to ListingView.js and start adding some simple scaffolding for the page:
```js
const React = require('react');
const injectI18n = require('nordic/i18n/injectI18n');

class ListingView extends React.Component {
  render() {
      return (
          <div />
      )
  }
}

module.exports = injectI18n(ListingView);
```
### Page Name
As we mentioned before, we have a new concept for pages called Page Name. In our Listing example, our name would be ```listing```.

Now it is time to add our Page component! Add the require for the component:

```js
const Page = require('nordic/page');
```

On the render method, add the following:
```js
render() {
    return (
      <Page name="listing">
        <YourPageComponentsHere />
    </Page>
    )
}
```

By adding this, Page automatically adds the style sheet and script file to your page:
```js
<div className="listing" id="listing">
  <YourPageComponentsHere />
  <Style href="listing.css" />
  <Script src="listing.js" />
</div>
```

Neat right? What about if I want to change the className or id for the div generated?

You can pass additional props to tackle that:
```js
render() {
    return (
      <Page name="listing" className="fancy-class-for-listing" id="awesome-id-for-listing">
        <YourPageComponentsHere />
    </Page>
    )
}
```

By adding this, Page will render the following:
```js
<div className="fancy-class-for-listing" id="awesome-id-for-listing">
  <YourPageComponentsHere />
  <Style href="listing.css" />
  <Script src="listing.js" />
</div>
```

### Adaptive Strategy
In case you are using adaptive strategy for managing your scripts and styles, you can pass another prop to the
Page component to indicate what deviceType you are using. That deviceType can be ```mobile``` or ```desktop```

```js
render() {
    return (
      <Page name="listing" deviceType="mobile">
        <YourPageComponentsHere />
    </Page>
    )
}
```

By adding this, Page will render the following:
```js
<div className="fancy-class-for-listing" id="awesome-id-for-listing">
  <YourPageComponentsHere />
  <Style href="listing.mobile.css" />
  <Script src="listing.mobile.js" />
</div>
```

Also, if you want to use adaptive only for the js or only for styles, you can do that by using the prop adaptiveFor.

For example, if you only want adaptive for styles you can do this:
```js
render() {
    return (
      <Page name="listing" deviceType="mobile" adaptiveFor="styles">
        <YourPageComponentsHere />
    </Page>
    )
}
```

Which will generate this:
```js
<div className="fancy-class-for-listing" id="awesome-id-for-listing">
  <YourPageComponentsHere />
  <Style href="listing.mobile.css" />
  <Script src="listing.js" />
</div>
```

On the other hand, if you only want adaptive for scripts:
```js
render() {
    return (
      <Page name="listing" deviceType="mobile" adaptiveFor="scripts">
        <YourPageComponentsHere />
    </Page>
    )
}
```

Which will generate this:
```js
<div className="fancy-class-for-listing" id="awesome-id-for-listing">
  <YourPageComponentsHere />
  <Style href="listing.css" />
  <Script src="listing.mobile.js" />
</div>
```

If you don't specify that prop, it will default to the value ```both``` which determines that both 
styles and scripts will use adaptive.

Furthermore, if you are not using adaptive (did not provide the deviceType prop) the ```adaptiveFor``` prop will not be considered

### Preloaded State
Pages usually send the Preloaded State to the frontend, so in this component you can do that too!

On the render method, you can pass a state prop with the object that you want to serialize.
```js
render() {
  const state = {
    i18n: this.props.i18n,
    translations: this.props.translations,
    siteId: this.props.siteId,
    lowEnd: this.props.lowEnd,
    rowsForListing: this.props.rowsForListing
  };
  return (
    <Page name="listing" state={ state }>
      <YourPageComponentsHere />
  </Page>
  )
}
```

### No Js or styles scenarios
Sometimes we do not need to use JS on our page, can we use the Page component in that scenario?

To indicate that to the Page component, you can pass the prop scripts in false, which will indicate the page component not to render them
```js
render() {
  return (
    <Page name="listing" scripts={false}>
      <YourPageComponentsHere />
  </Page>
  )
}
```

What if I do not want to render css? You can do that with the styles prop:

```js
render() {
  return (
    <Page name="listing" styles={false}>
      <YourPageComponentsHere />
  </Page>
  )
}
```


### Melidata and Analytics
Now, let's add analytics and melidata tracking to our page.

Before adding this, please take into consideration what you are planning to track and how. Do you want to have Google Analytics and Melidata to your app?
How are you going to name your sections, paths and pages? We suggest you take this as homework before using this feature.

Already got what you want to track? Great!

So in order to start tracking, we reuse the components created by [frontend-analytics](https://github.com/mercadolibre/fury_frontend-analytics)
and [frontend-melidata](https://github.com/mercadolibre/fury_frontend-melidata). You just need to pass the props that you want to send to those
components as another prop on the Page component.

```js
render() {
  const analytics = {
    section: "SectionForListingPage",
    page: "listing"
  };
  const melidata = {
    path: "/listing",
    event_data: {...}
  };
  return (
    <Page name="listing" state={ state } analytics={analytics} melidata={melidata}>
      <YourPageComponentsHere />
  </Page>
  )
}
```

By adding this, Page will render the following:
```js
<div className="listing" id="listing">
  <YourPageComponentsHere />
  <MeliGA {...analytics} /> // passes all the props that you provided directly to MeliGA
  <Melidata {...melidata} /> // passes all props that you provided directly to Melidata
  <Style href="listing.css" />
  <Script src="listing.js" />
</div>
```

HEAD'S UP!
- If you are not tracking in MeliGA and/or Melidata, you don't need to pass those props, and the Page component will simply
not render those components. However, we strongly recommend that you track your app :)
- There are some props inside analytics and melidata that are required for rendering these components:
    - For analytics, the prop section is required. If you do not pass it, the MeliGA Component will not be rendered
    - For melidata, the prop path is required. If you do not pass it, the Melidata Component will not be rendered

### Final Page with component
If we put all these things together, we get the following result:
```js
const React = require('react');
const injectI18n = require('nordic/i18n/injectI18n');
const Page = require('nordic/page');

class ListingView extends React.Component {
  render() {
    const state = {
      i18n: this.props.i18n,
      translations: this.props.translations,
      siteId: this.props.siteId,
      lowEnd: this.props.lowEnd,
      rowsForListing: this.props.rowsForListing
    };
    const analytics = {
      section: "SectionForListingPage",
      page: "listing"
    };
    const melidata = {
      path: "/listing",
      event_data: {...}
    };

    return (
      <Page
        name="listing"
        className="fancy-class-for-listing"
        id="awesome-id-for-listing"
        state={ state }
        melidata={melidata}
        analytics={analytics}
      >
        <YourPageComponentsHere />
      </Page>
    )
  }
}

module.exports = injectI18n(ListingView);
```

## Migrating from an existing page
So, what happens if you are already using Nordic, have a bunch of pages already created and you want to migrate.

No problem! Let's see an example on how to migrate to this component. Let's take the DemoView that we have all seen and migrate it.

Here's the DemoView:
```js
/**
 * Module dependencies
 */
const React = require('react');
const Head = require('react-declarative-head');
const MeliGA = require('nordic/analytics/meli-ga');
const Melidata = require('nordic/melidata/melidata-track');
const Script = require('nordic/script');
const Style = require('nordic/style');
const serialize = require('serialize-javascript');
const injectI18n = require('nordic/i18n/injectI18n');

/**
 * View Component
 */
class View extends React.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    alert('Click using React!');
  }

  render() {
    const { i18n, translations, site, siteId, lowEnd, deviceType, company } = this.props;
    return (
      <div className="demo">
        <MeliGA
          section="universal"
          page="test"
        />
        <Melidata path="/demo" event_data={{ ... }} />

        <Head>
          <title>Demo Page</title>
        </Head>

        <Style href="demo.css" />
        <Script>
          {`
            window.__PRELOADED_STATE__ = ${serialize({ translations, site, siteId, lowEnd, deviceType, company }, { isJSON: true })};
            console.log('Demo page is loaded!');
          `}
        </Script>
        <Script src="vendor.js" />
        <Script src="demo.js" />

        <button onClick={this.handleClick}>Click Me!</button>

        <h2>Site details:</h2>
        <p>Country: {site.name}, default currency: {site.default_currency_id}, company: {company}</p>

        <h2>Device details:</h2>
        <p>Is low-end: {String(lowEnd)}, type: {deviceType}</p>

        <h2>API endpoints:</h2>
        <ul>
          <li><a href="/api/demo/platform">Platform</a></li>
          <li><a href="/api/demo/user">User</a></li>
          <li><a href="/api/demo/device">Device</a></li>
          <li><a href="/api/demo/browser">Browser</a></li>
        </ul>

        <h2>i18n</h2>
        <p>{i18n.gettext('Usuarios')}</p>
      </div>
    );
  }
}

/**
 * Inject i18n context as props into View.
 */
module.exports = injectI18n(View);
```

Taking into consideration of new "Page Name" concept, plus what things our Page component can do, we will need to:
- Remove the following requires: MeliGA, Melidata, Style, serialize and add the Page require. It will end looking like this:

```js
const React = require('react');
const Head = require('react-declarative-head');
const Script = require('nordic/script');
const injectI18n = require('nordic/i18n/injectI18n');
const Page = require('nordic/page')
```

- Create specific objects for:
  - Melidata props
  - Analytics props
  - Preloaded State

```js
render() {
    const { i18n, translations, site, siteId, lowEnd, deviceType } = this.props;
    const state = {
      i18n,
      translations,
      site,
      siteId,
      lowEnd,
      deviceType
    };
    const analytics = {
      section: "universal",
      page: "test"
    };
    const melidata = {
      path: "/demo",
      event_data:{{ ... }}
    };
  }
```

- Refactor your components. You will need to:
  - Add the page component, passing the Page Name, state, analytics and melidata as props.
  - Remove MeliGA, Melidata, Style, <Script src="demo.js"/>, Script with Preloaded State

```js
  <Page
    name="demo"
    state={state}
    analytics={analytics}
    melidata={melidata}
  >
    <Head>
      <title>Demo Page</title>
    </Head>
    <Script src="vendor.js" />

    <button onClick={this.handleClick}>Click Me!</button>

    <h2>Site details:</h2>
    <p>Country: {site.name}, default currency: {site.default_currency_id}, company: {company}</p>

    <h2>Device details:</h2>
    <p>Is low-end: {String(lowEnd)}, type: {deviceType}</p>

    <h2>API endpoints:</h2>
    <ul>
      <li><a href="/api/demo/platform">Platform</a></li>
      <li><a href="/api/demo/user">User</a></li>
      <li><a href="/api/demo/device">Device</a></li>
      <li><a href="/api/demo/browser">Browser</a></li>
    </ul>

    <h2>i18n</h2>
    <p>{i18n.gettext('Usuarios')}</p>
  </Page>
```

Doesn't that look much more simpler?

Put everything together and the Page will look something like this:
```js
/**
 * Module dependencies
 */
const React = require('react');
const Head = require('react-declarative-head');
const Script = require('nordic/script');
const Page = require('nordic/page');
const injectI18n = require('nordic/i18n/injectI18n');

/**
 * View Component
 */
class View extends React.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    alert('Click using React!');
  }

  render() {
    const { i18n, translations, site, siteId, lowEnd, deviceType, company } = this.props;
    const state = {
      i18n,
      translations,
      site,
      siteId,
      lowEnd,
      deviceType
    };
    const analytics = {
      section: "universal",
      page: "test"
    };
    const melidata = {
      path: "/demo",
      event_data: {}
    };
    return (
      <Page
        name="demo"
        state={state}
        analytics={analytics}
        melidata={melidata}
      >
        <Head>
          <title>Demo Page</title>
        </Head>
        <Script src="vendor.js" />

        <button onClick={this.handleClick}>Click Me!</button>

        <h2>Site details:</h2>
        <p>Country: {site.name}, default currency: {site.default_currency_id}, company: {company}</p>

        <h2>Device details:</h2>
        <p>Is low-end: {String(lowEnd)}, type: {deviceType}</p>

        <h2>API endpoints:</h2>
        <ul>
          <li><a href="/api/demo/platform">Platform</a></li>
          <li><a href="/api/demo/user">User</a></li>
          <li><a href="/api/demo/device">Device</a></li>
          <li><a href="/api/demo/browser">Browser</a></li>
        </ul>

        <h2>i18n</h2>
        <p>{i18n.gettext('Usuarios')}</p>
      </Page>
    );
  }
}

/**
 * Inject i18n context as props into View.
 */
module.exports = injectI18n(View);
```
# Full Specs

Property|Type|Default|Is Required|Description
---|---|---|---|---
name|String|N/A|Yes|Page name, this usually maps to the name used on the page for the .css and .js files. For example, if your js file is called "details.js", it will be details
children|Elements|N/A|Yes|Children that will be rendered in the Page. This would be the components on your page
className|String|name prop|No|Class that will be used for the encapsulating div of the Page's components. If it is not passed, the page name will be used
state|Object|`{}`|No|State that will be serialized to the frontend
analytics|Object|`null`|No|Props to be passed to the MeliGA component
melidata|Object|`null`|No|Props to be passed to the Melidata component
id|String|`null`|No|Id that will be used for the encapsulating div of the Page's components. If it is not passed, the page name will be used
deviceType|```['mobile, desktop']```|`null`|No|Current Device Type to implement adaptive strategy
noJs|boolean|`null`|No|Flag that tells the component that the page will use no js
adaptiveFor|```['styles, scripts, both']```|`both`|No|Allows managing adaptive strategy independent between styles and scripts

# Things the component does not do yet
- Head: Head is also a component that usually is present on the Page, but the usage of this component varies between projects. Usually it is only used to change
the page title, but it can be used for other scenarios that could not be fully contemplated in case we wanted to add it to Page
- Vendor.js: not all projects use vendor.js, so it made sense to allow the developer to decide to include it or not. This can be done the same way that you were
previously doing, just add the ```<Script src="vendor.js" />```to the Page Component children

## Develop

1) Install dependencies:

```
npm install
```

2) Build the component:

```
npm run build
```

3) Build the example app:

```
npm run build:examples
```

4) Run the example app:

```
npm run start-dev
npm run watch:examples // In case you want to watch your changes
```

5) Navigate to:

```
http://dev.mercadolibre.com.ar:8080/
```

# Contact
If you want to get in touch with the team behind this, you can contact directly the main collaborators of the project:
- Frontend Core (frontendcore@mercadolibre.com)
- Juani Galán (juan.galan@mercadolibre.com)

## License
© 2017 Mercado Libre
