const { existsSync } = require('fs');
const path = require('path');
const { resolve } = require('path');

const { PAGES_PATH, discoveryFileExtensions, environments } = require('../constants');
const discoverFiles = require('./utils/discover-files');
const { log } = require('../utils');
const { getFileType, checkIfViewOrStyles } = require('./utils/file-helpers');
const { addPathToDiscoveredRoute, addPathToDiscoveredHttpError } = require('./utils/add-file-to-paths');
const { classifyDiscoveredFiles } = require('./utils/classify-discovered-files');
const { addActualRouteToDiscoveredRoutesIfApplies, addActualHttpErrorToDiscoveredHttpErrorsIfApplies } = require('./utils/complete-discovered-objects');
const { checkDuplicatedRoute, checkDuplicatedHttpErrorStatusCode, logDuplicatedFileByFileExtension } = require('./utils/inform-duplicates');
const { normalizeRoute, normalizeStatusCode } = require('./utils/normalizers');

const scriptOptions = discoveryFileExtensions.SCRIPT.join(',');
const stylesOptions = discoveryFileExtensions.STYLE.join(',');

/**
 * Object defining the resources of each device type for a specific page
 * @typedef { { [deviceType]: { client, view, style } } } PagePaths
 * @property {string} [deviceType] - Name of the device type defined by the route
 * discovery (base, mobile, etc.)
 * @property {string} [deviceType].client - Client file name for certain device type
 * @property {string} [deviceType].view - View file path for certain device type
 * @property {string} [deviceType].style - Style file path for certain device type
 */

/**
 * Object defining the resources of a specific page
 * @typedef { { route, hook, paths } } PageObject
 * @property {string} route - Navigable route of the page
 * @property {string} hook - Specific hooks file of the page
 * @property {PagePaths} paths - Object defining the paths resources of each device type for the page
 */

/**
 * Object defining the resources of each device type for a specific http error status code
 * @typedef { { [deviceType]: { view, style } } } HttpErrorPaths
 * @property {string} [deviceType] - Name of the device type defined by the route
 * discovery (base, mobile, etc.)
 * @property {string} [deviceType].view - View file path for certain device type
 * @property {string} [deviceType].style - Style file path for certain device type
 */

/**
 * Object defining the resources of a specific http error
 * @typedef { { statusCode: paths } } HttpErrorObject
 * @property {number} statusCode - Status code of the http error
 * @property {PagePaths} paths - Object defining the paths resources of each device type for the http error
 */

/**
 * Object defining a list of http error status codes
 * @typedef { { statusCode: { paths } } } HttpErrorListObject
 * @property {number} statusCode - Status code of the http error
 * @property {PagePaths} paths - Object defining the paths resources of each device type for the http error
 */

/**
 * Object defining the base hook file and the resources of each discovered page and http error
 * @typedef { { discoveredRoutes, discoveredHttpErrors, baseHooksFile } } FsRoutesResult
 * @property {Array<PageObject>} discoveredRoutes - List of discovered pages data
 * @property {HttpErrorListObject} discoveredHttpErrors - Object with list of discovered http errors data
 * @property {string} baseHooksFile - File path of the discovered base hook file
 */

/**
 * Returns the full path to a specific-hook file for a page.
 * In case the same file name with different extension is found,
 * it will be reported as an error.
 * @param {PageObject} actualRoute - Actual page route
 * @param {string} hooksFile - Specific page hooks file for the actual route
 * @param {string} fileType - Indicates that page file path is a specific page hooks file
 * @param {string} newDir - Base directory for the page files
 * @returns {string} Specific page hooks file full path
 *
 * @examples
 * const actualRoute = {
 *  route: 'home',
 *  hook: '',
 *  paths: {
 *    tablet: {
 *      client: 'home.tablet',
 *      view: 'home.tablet.js',
 *      style: 'home.tablet.scss'
 *    },
 *    mobile: {
 *      client: 'home.mobile',
 *      view: 'home.mobile.js',
 *    },
 *  },
 * };
 * const hooksFile = 'home.hooks.server.js';
 * const fileType = 'hooks';
 * const newDir = 'app/nordic-pages';
 *
 * getPageHooksFile({ actualRoute, hooksFile, fileType, newDir }) returns: 'app/nordic-pages/home.hooks.server.js'
 */
const getPageHooksFile = ({ actualRoute, hooksFile, fileType, newDir }) => {
  const { route, hooks } = actualRoute;

  if (hooks) {
    const messagePortion = `${route} route`;
    const errorMessage = logDuplicatedFileByFileExtension({ fileType, messagePortion });

    throw new Error(errorMessage);
  }

  const newHooks = path.resolve(newDir, hooksFile);

  return newHooks;
};

/**
 * Builds and returns a list of discovered page data based on the specific page files received.
 * If an error or warning occurs, it is reported.
 * @param {Array<string>} specificPageFiles - List of discovered specific page files
 * @param {string} dir - Base directory of discovered page files
 * @returns {Array<PageObject>} Returns proccessed list of discovered pages
 *
 * @example
 * const specificPageFiles = [
 *  'item/list.js',
 *  'item/list.scss',
 *  '_hooks.server.js',
 *  '404.js',
 *  '404.mobile.scss',
 *  '500/index.js',
 *  'home.js',
 *  'home.desktop.js',
 *  'home.hooks.server.js',
 * ];
 * const dir = 'my-dir';
 *
 * buildDiscoveredRoutes(specificPageFiles, dir) returns:
 * [
 *  {
 *    route: '/item/list',
 *    paths: {
 *      base: {
 *        view: 'item/list.js',
 *        styles: 'item/list.scss'
 *        client: 'item-list'
 *      }
 *    }
 *  },
 *  {
 *    route: '/home',
 *    hooks: 'home.hooks.server.js',
 *    paths: {
 *      base: {
 *        view: 'home.js',
 *        client: 'home'
 *      },
 *      desktop: {
 *        view: 'home.desktopjs',
 *        client: 'home.desktop'
 *      }
 *    }
 *  }
 * ]
 */
const buildDiscoveredRoutes = (specificPageFiles, dir) => {
  const newDir = path.resolve(process.cwd(), dir);

  let duplicatedRouteErrorMsg = '';
  let discoveredRoutes = [];
  let actualRoute = { route: '', paths: {}, hook: '' };

  specificPageFiles.forEach((pageFile) => {
    const fileType = getFileType(pageFile);

    if (!fileType) {
      log.warn(`The file ${pageFile} doesn't match any of the supported `
      + `extensions for scripts (${scriptOptions}) or styles (${stylesOptions}).`);

      return;
    }

    const route = normalizeRoute(pageFile);

    if (actualRoute.route !== route) {
      const filePath = path.resolve(dir, pageFile);

      duplicatedRouteErrorMsg += checkDuplicatedRoute({ route, discoveredRoutes, fileType, filePath });

      discoveredRoutes = addActualRouteToDiscoveredRoutesIfApplies(discoveredRoutes, actualRoute);

      actualRoute = { route, paths: {}, hooks: '' };
    }

    if (fileType === 'hooks') {
      actualRoute.hooks = getPageHooksFile({ actualRoute, hooksFile: pageFile, fileType, newDir });
    } else {
      actualRoute.paths = addPathToDiscoveredRoute({
        route, paths: actualRoute.paths, dir: newDir, filePath: pageFile,
      });
    }
  });

  if (duplicatedRouteErrorMsg !== '') throw new Error(duplicatedRouteErrorMsg);

  discoveredRoutes = addActualRouteToDiscoveredRoutesIfApplies(discoveredRoutes, actualRoute);

  return discoveredRoutes;
};

/**
 * Builds and returns an object of discovered http errors data based on the http error files received.
 * If an error or warning occurs, it is reported.
 * @param {Array<string>} httpErrorFiles - List of discovered http error files
 * @param {string} dir - Base directory of discovered http error files
 * @returns {HttpErrorListObject} Returns proccessed object of discovered http errors
 *
 * @example
 * const httpErrorFiles = [
 *  '404.js',
 *  '404.mobile.scss',
 *  '500/index.js',
 * ];
 * const dir = 'my-dir';
 *
 * buildDiscoveredHttpErrors(httpErrorFiles, dir) returns:
 * {
 *    404: {
 *      paths: {
 *        base: {
 *          view: '404.js',
 *          styles: '',
 *        },
 *        mobile: {
 *          view: '404.js',
 *          styles: '404.mobile.scss',
 *        },
 *      },
 *    },
 *    500: {
 *      paths: {
 *        base: {
 *          view: '500/index.js',
 *          styles: ''
 *        },
 *      }
 *    }
 * }
 */
const buildDiscoveredHttpErrors = (httpErrorFiles, dir) => {
  const newDir = path.resolve(process.cwd(), dir);

  let duplicatedHttpErrorMsg = '';
  let discoveredHttpErrors = {};
  let actualHttpError = { statusCode: null, paths: {} };

  httpErrorFiles.forEach((httpErrorFile) => {
    const fileType = checkIfViewOrStyles(httpErrorFile);

    if (fileType !== 'view' && fileType !== 'styles') {
      log.warn(`The file ${httpErrorFile} doesn't match any of the supported `
      + `extensions for scripts (${scriptOptions}) or styles (${stylesOptions}).`);

      return;
    }

    const statusCode = normalizeStatusCode(httpErrorFile);

    if (actualHttpError.statusCode !== statusCode) {
      const filePath = path.resolve(dir, httpErrorFile);

      duplicatedHttpErrorMsg += checkDuplicatedHttpErrorStatusCode({
        statusCode, discoveredHttpErrors, fileType, filePath,
      });

      discoveredHttpErrors = addActualHttpErrorToDiscoveredHttpErrorsIfApplies(discoveredHttpErrors, actualHttpError);

      actualHttpError = { statusCode, paths: {} };
    }

    actualHttpError.paths = addPathToDiscoveredHttpError({
      statusCode, paths: actualHttpError.paths, dir: newDir, filePath: httpErrorFile,
    });
  });

  if (duplicatedHttpErrorMsg !== '') throw new Error(duplicatedHttpErrorMsg);

  discoveredHttpErrors = addActualHttpErrorToDiscoveredHttpErrorsIfApplies(discoveredHttpErrors, actualHttpError);

  return discoveredHttpErrors;
};

/**
 * Discovers page files, http error files and base hook files using a given directory as a base and
 * process each file to generate an object with discovered pages, discovered http errors
 * and the base hook file:
 * - The discovered pages is a list of page data that follows the PageObject format.
 * - The discovered http errors is a list of http error data that follows the HttpErrorObject format.
 * - The base hook file is the path to the file.
 * @param {string} dir - Base directory used to discover pages files
 * @returns {FsRoutesResult} Returns proccessed list of discovered pages, discovered http errors and base hook file
 *
 * @example
 * If you have the following files in 'my-dir' directory:
 * - item/list.js
 * - item/list.scss
 * - _hooks.server.js
 * - 404.js
 * - 404.mobile.scss
 * - 500/index.js
 * - home.js
 * - home.desktop.js
 * - home.hooks.server.js
 *
 * fsRoutes('./my-dir') returns:
 * {
 *  baseHooksFile: '_hooks.server.js',
 *  discoveredRoutes: [
 *    {
 *      route: '/item/list',
 *      paths: {
 *        base: {
 *          view: 'item/list.js',
 *          styles: 'item/list.scss'
 *          client: 'item-list'
 *        }
 *      }
 *    },
 *    {
 *      route: '/home',
 *      hooks: 'home.hooks.server.js',
 *      paths: {
 *        base: {
 *          view: 'home.js',
 *          client: 'home'
 *        },
 *        desktop: {
 *          view: 'home.desktopjs',
 *          client: 'home.desktop'
 *        }
 *      }
 *    }
 *  ],
 *  discoveredHttpErrors: {
 *     404: {
 *        paths: {
 *          base: {
 *            view: '404.js',
 *            styles: '',
 *          },
 *          mobile: {
 *            view: '404.js',
 *            styles: '404.mobile.scss',
 *          },
 *        },
 *     },
 *     500: {
 *        paths: {
 *          base: {
 *            view: '500/index.js',
 *            styles: ''
 *          },
 *        }
 *      }
 *  },
 * }
 */
const fsRoutes = (dir) => {
  const newDir = path.resolve(process.cwd(), dir);

  let specificFiles = [];
  let httpErrorFiles = [];
  let fsRoutesDiscoveryResult = {
    discoveredRoutes: [],
    discoveredHttpErrors: {},
    baseHooksFile: '',
  };

  try {
    const discoveredFiles = discoverFiles(newDir);

    ({
      specificFiles,
      httpErrorFiles,
      baseHooksFile: fsRoutesDiscoveryResult.baseHooksFile,
    } = classifyDiscoveredFiles(discoveredFiles, dir));

    fsRoutesDiscoveryResult.discoveredRoutes = buildDiscoveredRoutes(specificFiles, dir);
    fsRoutesDiscoveryResult.discoveredHttpErrors = buildDiscoveredHttpErrors(httpErrorFiles, dir);
  } catch (error) {
    fsRoutesDiscoveryResult = { discoveredRoutes: [], discoveredHttpErrors: {}, baseHooksFile: '' };

    log.error(error);
  }

  return fsRoutesDiscoveryResult;
};

/**
 * Discover files and returns discovered pages, discovered http error and base hook file
 * using a given directory as a basis
 * @param {string} pagesPath - Base directory used to discover pages files
 * @returns {FsRoutesResult} Returns base hooks file and list of discovered pages and discovered http error data
 */
const getDiscoveredRoutes = (pagesPath = PAGES_PATH) => {
  let output = [];
  const fullPath = resolve(pagesPath);

  if (existsSync(fullPath)) {
    output = fsRoutes(fullPath);
  }

  return output;
};

module.exports = {
  getDiscoveredRoutes,
};
if (process.env.NODE_ENV === environments.TEST) {
  exports = module.exports;
  exports.fsRoutes = fsRoutes;
  exports.getPageHooksFile = getPageHooksFile;
}
