const {
  possibleDeviceTypes,
  discoveryDeviceTypes,
  environments,
  warnings,
} = require('../../constants');
const { log } = require('../../utils');
const { endsWithDeviceTypeRegex } = require('../regExs');
const { getPriorityDevicePaths } = require('./device-helper');

/**
 * Object defining the resources of each device type for a specific page
 * @typedef { { [deviceType]: { client, view, style } } } PagePaths
 * @property {string} [deviceType] - Name of the device type defined for the route discovery (base, mobile, etc.)
 * @property {string} [deviceType].client - Client file name for certain device type
 * @property {string} [deviceType].view - View file path for certain device type
 * @property {string} [deviceType].style - Style file path for certain device type
 */

/**
 * Object defining the resources of a specific page
 * @typedef { { route, hook, paths } } PageObject
 * @property {string} route - Navigable route of the page
 * @property {string} hook - Specific hooks file of the page
 * @property {PagePaths} paths - Object defining the paths resources of each device type for the page
 */

/**
 * Object defining the resources of each device type for a specific http error status code
 * @typedef { { [deviceType]: { view, style } } } HttpErrorPaths
 * @property {string} [deviceType] - Name of the device type defined for the route discovery (base, mobile, etc.)
 * @property {string} [deviceType].client - Client file name for certain device type
 * @property {string} [deviceType].view - View file path for certain device type
 * @property {string} [deviceType].style - Style file path for certain device type
 */

/**
 * Object defining the resources of a specific http error
 * @typedef { { route, hook, paths } } HttpErrorObject
 * @property {number} statusCode - Status code of the http error
 * @property {PagePaths} paths - Object defining the paths resources of each device type for the http error
 */

/**
 * Object defining a list of http error status codes
 * @typedef { { statusCode: { paths } } } HttpErrorListObject
 * @property {number} statusCode - Status code of the http error
 * @property {PagePaths} paths - Object defining the paths resources of each device type for the http error
 */

const stylesBaseLog = (styleSheet) => `The style sheet ${styleSheet} does not match any view`;

/**
 * Checks if an invalid route exists for a device type and informs it
 * @param {PagePaths} routePaths - Page paths by device type
 */
function informInvalidRoute(routePaths) {
  const invalidRoutes = [];
  let deviceTypePaths;

  discoveryDeviceTypes.forEach((deviceType) => {
    deviceTypePaths = routePaths[deviceType];

    if (deviceTypePaths) {
      if (deviceTypePaths.view) {
        invalidRoutes.push(deviceTypePaths.view);
      }

      if (deviceTypePaths.styles) {
        invalidRoutes.push(deviceTypePaths.styles);
      }
    }
  });

  if (invalidRoutes.length > 0) {
    log.warn(`${warnings.ROUTE_DISCOVERY} ${invalidRoutes.join('\n- ')}`);
  }
}

/**
 * Populates the device object (mobile, desktop, tablet or webview)
 * when it doesn't have a view defined.
 * In case a view cannot be assigned to complete an object, this is reported.
 * @param { PagePaths | HttpErrorPaths } paths - Paths object by device type
 * @returns { PagePaths | HttpErrorPaths } Paths object with populated device objects
 *
 * @example
 * const paths = {
 *    base: {
 *      view: 'home.js',
 *      styles: 'home.scss',
 *      client: 'home',
 *    },
 *    mobile: {
 *      styles: 'home.mobile.scss',
 *      client: 'home.mobile',
 *    },
 * };
 *
 * completeDeviceObject(paths) returns:
 * {
 *    base: {
 *      view: 'home.js',
 *      styles: 'home.scss',
 *      client: 'home',
 *    },
 *    mobile: {
 *      view: 'home.js',
 *      styles: 'home.mobile.scss',
 *      client: 'home.mobile',
 *    },
 * }
 */
function completeDeviceObject(paths) {
  const pagePaths = JSON.parse(JSON.stringify(paths));
  const newPaths = (pagePaths.base ? { base: pagePaths.base } : {});

  possibleDeviceTypes.forEach((deviceType) => {
    if (pagePaths[deviceType]) {
      const deviceTypePaths = pagePaths[deviceType];

      if (!deviceTypePaths.view) {
        if (deviceType === 'webview' && pagePaths.mobile && pagePaths.mobile.view) {
          deviceTypePaths.view = pagePaths.mobile.view;
          newPaths.webview = deviceTypePaths;

          return;
        }

        if (pagePaths.base && pagePaths.base.view) {
          deviceTypePaths.view = pagePaths.base.view;
          newPaths[deviceType] = deviceTypePaths;

          return;
        }

        const message = `${stylesBaseLog(deviceTypePaths.styles)}.`
        + ' Please check the naming convention of the view for '
        + 'different device types or create the base view.';

        throw new Error(message);
      }

      newPaths[deviceType] = deviceTypePaths;
    }
  });

  return newPaths;
}

/**
 * Populates the 'base' object when it doesn't have a view defined.
 * In case a view cannot be assigned to complete the object, this is reported.
 * @param { PagePaths | HttpErrorPaths } paths - Paths object by device type
 * @param {string} messagePortion - Message portion added to view cannot assigned report when it applies
 * @returns { PagePaths | HttpErrorPaths } Paths object with populated 'base' object
 */
function completeBaseObject(paths, messagePortion) {
  const pathsObjectQuantity = Object.keys(paths).length;
  const newPaths = JSON.parse(JSON.stringify(paths));

  let message = '';

  const { deviceType, deviceTypePaths } = getPriorityDevicePaths(paths);

  if (paths.base && !paths.base.view) {
    message = stylesBaseLog(paths.base.styles);

    if (pathsObjectQuantity === 1) {
      message += '. Please move it to the style components folder '
      + 'or create the corresponding view following the naming '
      + `convention for the ${messagePortion}`;

      delete newPaths.base;
    } else {
      newPaths.base.view = deviceTypePaths.view;

      message += ` and now is asociated with the following ${deviceType} `
      + `device type view: ${newPaths.base.view}. Please create the `
      + 'corresponding base view following the naming convention for '
      + `the ${messagePortion}`;
    }
  } else if (!paths.base && pathsObjectQuantity > 0) {
    newPaths.base = { ...deviceTypePaths };
    newPaths.base.client = newPaths.base.client.replace(endsWithDeviceTypeRegex, '');

    message = `The following ${messagePortion} does not match any base view, `
    + `so the ${deviceType} device type view will be considered as the base `
    + `view: ${newPaths.base.view}. Please create the corresponding base `
    + `view following the naming convention for the ${messagePortion}`;
  }

  if (message) log.warn(message);

  return newPaths;
}

/**
   * Populates the paths of the actual object by completing the missing views of
   * the base and device path objects (desktop, mobile, etc.).
   * In case a view cannot be assigned to complete an object, this is reported.
   * @param { PageObject | HttpErrorObject } actualObject - Actual object with the base and device paths to be populated
   * @param {string} messagePortion - Message portion added to view cannot assigned report when it applies
   * @returns { PageObject | HttpErrorObject } Actual object with populated base and device paths
   */
function completeActualObjectPaths(actualObject, messagePortion) {
  const { paths } = actualObject;
  const completedActualObject = JSON.parse(JSON.stringify(actualObject));

  completedActualObject.paths = completeDeviceObject(paths);
  completedActualObject.paths = completeBaseObject(completedActualObject.paths, messagePortion);

  if (completedActualObject.paths && Object.keys(completedActualObject.paths).length !== 0) {
    return completedActualObject;
  }

  return null;
}

/**
   * Add the actual route to the discovered routes list when the actual route paths object
   * is populated and it has values.
   * @param { Array<PageObject> } discoveredRoutes - List of populated discovered routes
   * @param { PageObject } actualRoute - Actual route to be populated and added if applies
   * @returns { Array<PageObject> } List of populated discovered routes with the populated actual route added
   */
function addActualRouteToDiscoveredRoutesIfApplies(discoveredRoutes, actualRoute) {
  const { route, paths } = actualRoute;

  const completedDiscoveredRoutes = JSON.parse(JSON.stringify(discoveredRoutes));

  if (route && route.trim()) {
    const messagePortion = `route: ${route}`;

    const completedActualRoute = completeActualObjectPaths(actualRoute, messagePortion);

    if (completedActualRoute) {
      completedDiscoveredRoutes.push(completedActualRoute);
    }
  } else if (paths && Object.keys(paths).length !== 0) {
    informInvalidRoute(paths);
  }

  return completedDiscoveredRoutes;
}

/**
   * Add the actual http error to the discovered http errors list when the actual http error paths object
   * is populated and it has values.
   * @param {HttpErrorListObject} discoveredHttpErrors - List of populated discovered http errors
   * @param { HttpErrorObject } actualHttpError - Actual http error to be populated and added if applies
   * @returns {HttpErrorListObject} List of populated discovered http errors with the populated actual http error added
   */
function addActualHttpErrorToDiscoveredHttpErrorsIfApplies(discoveredHttpErrors, actualHttpError) {
  const { statusCode } = actualHttpError;
  const completedDiscoveredHttpErrors = JSON.parse(JSON.stringify(discoveredHttpErrors));
  const messagePortion = `http error status code: ${statusCode}`;

  const completedActualHttpError = completeActualObjectPaths(actualHttpError, messagePortion);

  if (completedActualHttpError) {
    completedDiscoveredHttpErrors[actualHttpError.statusCode] = {
      paths: completedActualHttpError.paths,
    };
  }

  return completedDiscoveredHttpErrors;
}

module.exports = {
  addActualRouteToDiscoveredRoutesIfApplies,
  addActualHttpErrorToDiscoveredHttpErrorsIfApplies,
};
exports = module.exports;

if (process.env.NODE_ENV === environments.TEST) {
  exports = module.exports;
  exports.addActualRouteToDiscoveredRoutesIfApplies = addActualRouteToDiscoveredRoutesIfApplies;
  exports.informInvalidRoute = informInvalidRoute;
  exports.completeDeviceObject = completeDeviceObject;
  exports.completeBaseObject = completeBaseObject;
  exports.completeActualObjectPaths = completeActualObjectPaths;
  exports.stylesBaseLog = stylesBaseLog;
}
