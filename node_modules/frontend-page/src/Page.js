/* eslint-disable react/jsx-closing-tag-location */
const React = require('react');
const MeliGA = require('frontend-analytics/meli-ga');
const MelidataTrack = require('frontend-melidata/melidata-track');
const Script = require('frontend-script');
const Style = require('frontend-style');
const serialize = require('serialize-javascript');
const PropTypes = require('prop-types');
const { possibleDeviceTypes, possibleAdaptiveOptions, warnings } = require('./constants');
const { log, isAdaptiveEnabled } = require('./utils');

class Page extends React.Component {
  /**
   * Retrieves the className to be used for the wrapping div.
   * If a className is provided, that will be used, instead the name of the page will be used
   * @param {string} name - The page's name.
   * @param {string} className - Classname to be used.
   * @return {string} classname to be used
   */
  getClassName(name, className) {
    return className || name;
  }

  /**
   * Retrieves style sheet file name, taking into consideration the adaptive strategy.
   * @param {string} deviceType - Current Device Type. can be mobile or desktop
   * @param {string} name - The page's name.
   * @param {string} adaptiveFor - String to detect whether we need to apply adaptive for styles
   * @return {string} Style sheet file to be rendered
   */
  getStyleSheetName(deviceType, name, adaptiveFor) {
    // TODO: in the future we could allow the developer to pass a function to generate the name of the file maybe,
    // in case they are using some different naming convention
    let styleSheetName = `${name}.css`;

    if (deviceType && possibleDeviceTypes
      .includes(deviceType) && isAdaptiveEnabled(adaptiveFor, possibleAdaptiveOptions.styles)) {
      styleSheetName = `${name}.${deviceType}.css`;
    }

    return styleSheetName;
  }

  /**
   * Retrieves the js file name, taking into consideration the adaptive strategy.
   * @param {string} deviceType - Current Device Type. can be mobile or desktop
   * @param {string} name - The page's name.
   * @param {string} adaptiveFor - String to detect whether we need to apply adaptive for scripts
   * @return {string} Js file to be rendered
   */
  getScriptName(deviceType, name, adaptiveFor) {
    // TODO: in the future we could allow the developer to pass a function to generate the name of the file maybe,
    // in case they are using some different naming convention
    let scriptName = `${name}.js`;

    if (deviceType && possibleDeviceTypes
      .includes(deviceType) && isAdaptiveEnabled(adaptiveFor, possibleAdaptiveOptions.scripts)) {
      scriptName = `${name}.${deviceType}.js`;
    }

    return scriptName;
  }

  /**
   * Retrieves id for the page
   * @param {string} id - Id to be used.
   * @param {string} name - The page's name. This will be the default value
   * @return {string} Page id to be used
   */
  getIdForPage(id, name) {
    return id || name;
  }

  /**
   * Validates that a specific object is valid to be used as analytics props.
   * @param {object} analytics - Object with analytics props
   * @return {boolean} Returns true if the object is valid
   */
  isAnalyticsValid(analytics) {
    const isValid = analytics && Object.prototype.hasOwnProperty.call(analytics, 'section');

    if (analytics && !Object.prototype.hasOwnProperty.call(analytics, 'section')) {
      log.warn(warnings.ANALYTICS);
    }

    return isValid;
  }

  /**
   * Validates that a specific object is valid to be used as melidata props.
   * @param {object} melidata - Object with analytics props
   * @return {boolean} Returns true if the object is valid
   */
  isMelidataValid(melidata) {
    const isValid = melidata && Object.prototype.hasOwnProperty.call(melidata, 'path');

    if (melidata && !Object.prototype.hasOwnProperty.call(melidata, 'path')) {
      log.warn(warnings.MELIDATA);
    }

    return isValid;
  }

  /**
   * Validates that the conditions are met for the state to be rendered.
   * @param {object} state - Object with state
   * @param {boolean} scripts - Flag indicating that the page to be rendered has js scripts
   * @return {boolean} Returns true if the object is valid
   */
  canRenderState(state, scripts) {
    return state !== null && scripts;
  }

  render() {
    const { name, id, className, analytics, melidata, deviceType, state, scripts, styles, adaptiveFor, children } = this.props;
    return (
      <div className={this.getClassName(name, className)} id={this.getIdForPage(id, name)}>
        { children }
        { this.isAnalyticsValid(analytics) && <MeliGA {...analytics} /> }
        { this.isMelidataValid(melidata) && <MelidataTrack {...melidata} /> }
        { styles && <Style href={this.getStyleSheetName(deviceType, name, adaptiveFor)} critical={deviceType === 'mobile'} /> }
        { this.canRenderState(state, scripts) && <Script>
          {`
            window.__PRELOADED_STATE__ = ${serialize(state, { isJSON: true })};
          `}
        </Script> }
        { scripts && <Script src={this.getScriptName(deviceType, name, adaptiveFor)} /> }
      </div>
    );
  }
}

Page.propTypes = {
  name: PropTypes.string.isRequired,
  state: PropTypes.object,
  analytics: PropTypes.object,
  scripts: PropTypes.bool,
  styles: PropTypes.bool,
  adaptiveFor: PropTypes.oneOf(Object.keys(possibleAdaptiveOptions).map(k => possibleAdaptiveOptions[k])),
  melidata: PropTypes.object,
  className: PropTypes.string,
  id: PropTypes.string,
  deviceType: PropTypes.oneOf(possibleDeviceTypes),
  children: PropTypes.oneOfType([
    PropTypes.arrayOf(PropTypes.node),
    PropTypes.node,
  ]).isRequired,
};


Page.defaultProps = {
  state: null,
  analytics: null,
  melidata: null,
  adaptiveFor: possibleAdaptiveOptions.both,
  className: '',
  deviceType: null,
  scripts: true,
  styles: true,
  id: '',
};

module.exports = Page;
