{"version":3,"file":"perfume.umd.min.js","sources":["../src/config.ts","../src/constants.ts","../src/isSupported.ts","../src/getNetworkInformation.ts","../src/isLowEnd.ts","../src/onVisibilityChange.ts","../src/utils.ts","../src/vitalsScore.ts","../src/reportPerf.ts","../src/getNavigatorInfo.ts","../src/log.ts","../src/metrics.ts","../src/cumulativeLayoutShift.ts","../src/observeInstances.ts","../src/performanceObserver.ts","../src/firstInput.ts","../src/totalBlockingTime.ts","../src/paint.ts","../src/resourceTiming.ts","../src/observe.ts","../src/storageEstimate.ts","../src/perfume.ts","../src/getNavigationTiming.ts","../src/measure.ts"],"sourcesContent":["import { IPerfumeConfig } from './types';\n\nexport const config: IPerfumeConfig = {\n  // Metrics\n  isResourceTiming: false,\n  isElementTiming: false,\n  // Logging\n  maxTime: 30000,\n};\n","// Have private variable outside the class,\n// helps drastically reduce the library size\nexport const W = window;\nexport const C = W.console;\nexport const D = document;\nexport const WN = W.navigator;\nexport const WP = W.performance;\nexport const getDM = () => (WN as any).deviceMemory;\nexport const getHC = () => (WN as any).hardwareConcurrency;\n","import { WP } from './constants';\n\n/**\n * True if the browser supports the Navigation Timing API,\n * User Timing API and the PerformanceObserver Interface.\n * In Safari, the User Timing API (performance.mark()) is not available,\n * so the DevTools timeline will not be annotated with marks.\n * Support: developer.mozilla.org/en-US/docs/Web/API/Performance/mark\n * Support: developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver\n * Support: developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByType\n */\nexport const isPerformanceSupported = (): boolean => {\n  return WP && !!WP.getEntriesByType && !!WP.now && !!WP.mark;\n};\n","import { WN } from './constants';\nimport { EffectiveConnectionType, IPerfumeNetworkInformation } from './types';\n\nexport let et: EffectiveConnectionType = '4g';\nexport let sd = false;\n\nexport const getNetworkInformation = (): IPerfumeNetworkInformation => {\n  if ('connection' in WN) {\n    const dataConnection = (WN as any).connection;\n    if (typeof dataConnection !== 'object') {\n      return {};\n    }\n    et = dataConnection.effectiveType;\n    sd = !!dataConnection.saveData;\n    return {\n      downlink: dataConnection.downlink,\n      effectiveType: dataConnection.effectiveType,\n      rtt: dataConnection.rtt,\n      saveData: !!dataConnection.saveData,\n    };\n  }\n  return {};\n};\n","import { getDM, getHC } from './constants';\nimport { EffectiveConnectionType } from './types';\n\nexport const getIsLowEndDevice = (): boolean => {\n  // If number of logical processors available to run threads <= 4\n  if (getHC() && getHC() <= 4) {\n    return true;\n  }\n  // If the approximate amount of RAM client device has <= 4\n  if (getDM() && getDM() <= 4) {\n    return true;\n  }\n  return false;\n};\n\nexport const getIsLowEndExperience = (\n  et: EffectiveConnectionType,\n  sd: boolean,\n): boolean => {\n  // If the effective type of the connection meaning\n  // one of 'slow-2g', '2g', '3g', or '4g' is !== 4g\n  switch (et) {\n    case 'slow-2g':\n      return true;\n      break;\n    case '2g':\n      return true;\n      break;\n    case '3g':\n      return true;\n      break;\n    default:\n      // Data Saver preference\n      return (getIsLowEndDevice() || sd);\n  }\n};\n","import { D } from './constants';\n\nexport const visibility = {\n  isHidden: false,\n};\n\n/**\n * From visibilitychange listener it saves only when\n * the page gets hidden, because it's important to not\n * use the wrong \"hidden\" value when send timing or logging.\n */\nexport const didVisibilityChange = function(cb: Function) {\n  if (D.hidden) {\n    cb();\n    visibility.isHidden = D.hidden;\n  }\n};\n","import { W } from './constants';\n\nexport const roundByFour = (num: number) => {\n  return parseFloat(num.toFixed(4));\n}\n\nexport const convertToKB = (bytes: number): number | null => {\n  if (typeof bytes !== 'number') {\n    return null;\n  }\n  return roundByFour(bytes / Math.pow(1024, 2));\n};\n\n/**\n * PushTask to requestIdleCallback\n */\nexport const pushTask = (cb: any): void => {\n  if ('requestIdleCallback' in W) {\n    (W as any).requestIdleCallback(cb, { timeout: 3000 });\n  } else {\n    cb();\n  }\n};\n","import { IPerfumeData, IVitalsScore } from './types';\n\nconst ttfbScore = [200, 500];\nconst fcpScore = [2000, 4000];\nconst lcpScore = [2500, 4000];\nconst fidcore = [100, 300];\nconst clsScore = [0.1, 0.25];\nconst tbtScore = [200, 600];\nconst ntbtScore = [200, 600];\n\nexport const webVitalsScore: Record<string, number[]> = {\n  ttfb: ttfbScore,\n  fp: fcpScore,\n  fcp: fcpScore,\n  lcp: lcpScore,\n  lcpFinal: lcpScore,\n  fid: fidcore,\n  cls: clsScore,\n  clsFinal: clsScore,\n  tbt: tbtScore,\n  ntbt: ntbtScore,\n};\n\nexport const getVitalsScore = (\n  measureName: string,\n  value: IPerfumeData,\n): IVitalsScore => {\n  if (!webVitalsScore[measureName]) {\n    return null;\n  }\n  if (value <= webVitalsScore[measureName][0]) {\n    return 'good';\n  }\n  return value <= webVitalsScore[measureName][1] ? 'needsImprovement' : 'poor';\n};\n","import { config } from './config';\nimport { getNavigatorInfo } from './getNavigatorInfo';\nimport { visibility } from './onVisibilityChange';\nimport { pushTask } from './utils';\nimport { getVitalsScore } from './vitalsScore';\n\n/**\n * Sends the User timing measure to analyticsTracker\n */\nexport const reportPerf = function(\n  measureName: string,\n  data: any,\n  customProperties?: object,\n): void {\n  pushTask(() => {\n    // Doesn't send timing when page is hidden\n    if (\n      (visibility.isHidden && measureName.indexOf('Final') < 0) ||\n      !config.analyticsTracker\n    ) {\n      return;\n    }\n    // Send metric to custom Analytics service\n    config.analyticsTracker({\n      metricName: measureName,\n      data,\n      eventProperties: customProperties || {},\n      navigatorInformation: getNavigatorInfo(),\n      vitalsScore: getVitalsScore(measureName, data),\n    });\n  });\n};\n","import { getDM, getHC, WN } from './constants';\nimport { et, sd } from './getNetworkInformation';\nimport { getIsLowEndDevice, getIsLowEndExperience } from './isLowEnd';\nimport { INavigatorInfo } from './types';\n\n/**\n * Information coming from window.navigator:\n * 1. Device Memory\n * 2. Hardware Concurency\n * 3. Status of the service worker:\n *     - controlled: a service worker is controlling the page\n *     - supported: the browser supports service worker\n *     - unsupported: the user's browser does not support service worker\n */\nexport const getNavigatorInfo = function(): INavigatorInfo {\n  if (WN) {\n    return {\n      deviceMemory: getDM() || 0,\n      hardwareConcurrency: getHC() || 0,\n      serviceWorkerStatus:\n        'serviceWorker' in WN\n          ? WN.serviceWorker.controller\n            ? 'controlled'\n            : 'supported'\n          : 'unsupported',\n      isLowEndDevice: getIsLowEndDevice(),\n      isLowEndExperience: getIsLowEndExperience(et, sd)\n    };\n  }\n  return {};\n};\n","import { config } from './config';\nimport { reportPerf } from './reportPerf';\nimport { roundByFour } from './utils';\n\nexport const logData = (\n  measureName: string,\n  metric: any,\n  customProperties?: object,\n): void => {\n  Object.keys(metric).forEach(key => {\n    if (typeof metric[key] === 'number') {\n      metric[key] = roundByFour(metric[key]);\n    }\n  });\n  // Sends the metric to an external tracking service\n  reportPerf(measureName, metric, customProperties);\n};\n\n/**\n * Dispatches the metric duration into internal logs\n * and the external time tracking service.\n */\nexport const logMetric = (duration: number, measureName: string, customProperties?: object): void => {\n  const duration2Decimal = roundByFour(duration);\n  if (duration2Decimal <= config.maxTime && duration2Decimal >= 0) {\n    // Sends the metric to an external tracking service\n    reportPerf(measureName, duration2Decimal, customProperties);\n  }\n};\n","import { IMetricMap, IPerfumeDataConsumption } from './types';\n\nexport const metrics: IMetricMap = {};\nexport const cls = {\n  value: 0,\n};\nexport const fcp = {\n  value: 0,\n};\nexport const lcp = {\n  value: 0,\n};\nexport const fcpEntryName = 'first-contentful-paint';\nexport const rt: { value: IPerfumeDataConsumption } = {\n  value: {\n    beacon: 0,\n    css: 0,\n    fetch: 0,\n    img: 0,\n    other: 0,\n    script: 0,\n    total: 0,\n    xmlhttprequest: 0,\n  },\n};\nexport const tbt = {\n  value: 0,\n};\nexport const ntbt = {\n  value: 0,\n};\n\n","import { cls } from './metrics';\nimport { IPerformanceEntry } from './types';\n\n/**\n * Detects new layout shift occurrences and updates the\n * `cumulativeLayoutShiftScore` variable.\n */\nexport const initLayoutShift = (performanceEntries: IPerformanceEntry[]) => {\n  const lastEntry = performanceEntries.pop();\n  // Only count layout shifts without recent user input.\n  if (lastEntry && !lastEntry.hadRecentInput && lastEntry.value) {\n    cls.value += lastEntry.value;\n  }\n};\n","import { IPerfObservers } from './types';\n\nexport const perfObservers: IPerfObservers = {};\n","import { C } from './constants';\nimport { perfObservers } from './observeInstances';\nimport { IPerformanceObserverType } from './types';\n\n/**\n * PerformanceObserver subscribes to performance events as they happen\n * and respond to them asynchronously.\n */\nexport const po = (\n  eventType: IPerformanceObserverType,\n  cb: (performanceEntries: any[]) => void,\n): PerformanceObserver | null => {\n  try {\n    const perfObserver = new PerformanceObserver(entryList => {\n      cb(entryList.getEntries());\n    });\n    // Retrieve buffered events and subscribe to newer events for Paint Timing\n    perfObserver.observe({ type: eventType, buffered: true });\n    return perfObserver;\n  } catch (e) {\n    C.warn('Perfume.js:', e);\n  }\n  return null;\n};\n\nexport const poDisconnect = (observer: any) => {\n  if (perfObservers[observer]) {\n    perfObservers[observer].disconnect();\n  }\n  delete perfObservers[observer];\n}\n","import { logData, logMetric } from './log';\nimport { cls, lcp, rt, tbt } from './metrics';\nimport { perfObservers } from './observeInstances';\nimport { poDisconnect } from './performanceObserver';\nimport { PerformanceEventTiming } from './types';\n\nexport const initFirstInputDelay = (\n  performanceEntries: PerformanceEventTiming[],\n) => {\n  const lastEntry = performanceEntries.pop();\n  if (lastEntry) {\n    // Core Web Vitals FID logic\n    // Measure the delay to begin processing the first input event\n    logMetric(lastEntry.processingStart - lastEntry.startTime, 'fid', {\n      performanceEntry: lastEntry\n    });\n  }\n  // Disconnect this observer since callback is only triggered once\n  poDisconnect(1);\n  logMetric(lcp.value, 'lcp');\n  if (perfObservers[3] && typeof perfObservers[3].takeRecords === 'function') {\n    perfObservers[3].takeRecords();\n  }\n  logMetric(cls.value, 'cls');\n  // TBT has 10 second delay after FID\n  setTimeout(() => {\n    logMetric(tbt.value, 'tbt');\n    logData('dataConsumption', rt.value);\n  }, 10000);\n};\n","import { fcp, tbt, ntbt } from './metrics';\nimport { IPerformanceEntry } from './types';\n\nexport const initTotalBlockingTime = (\n  performanceEntries: IPerformanceEntry[],\n): void => {\n  performanceEntries.forEach(entry => {\n    if (\n      entry.name !== 'self' ||\n      entry.startTime < fcp.value\n    ) {\n      return;\n    }\n    const blockingTime = entry.duration - 50;\n    if (blockingTime > 0) {\n      tbt.value += blockingTime;\n      ntbt.value += blockingTime;\n    }\n  });\n};\n","import { logMetric } from './log';\nimport { fcp, fcpEntryName, lcp } from './metrics';\nimport { perfObservers } from './observeInstances';\nimport { po, poDisconnect } from './performanceObserver';\nimport { initTotalBlockingTime } from './totalBlockingTime';\nimport { IPerformanceEntry } from './types';\n\n/**\n * First Paint is essentially the paint after which\n * the biggest above-the-fold layout change has happened.\n */\nexport const initFirstPaint = (performanceEntries: IPerformanceEntry[]) => {\n  performanceEntries.forEach(entry => {\n    if (entry.name === 'first-paint') {\n      logMetric(entry.startTime, 'fp');\n    } else if (entry.name === fcpEntryName) {\n      fcp.value = entry.startTime;\n      logMetric(fcp.value, 'fcp');\n      perfObservers[4] = po('longtask', initTotalBlockingTime);\n      poDisconnect(0);\n    }\n  });\n};\n\nexport const initLargestContentfulPaint = (\n  performanceEntries: IPerformanceEntry[],\n) => {\n  const lastEntry = performanceEntries.pop();\n  if (lastEntry) {\n    lcp.value = lastEntry.renderTime || lastEntry.loadTime;\n  }\n};\n\nexport const initElementTiming = (\n  performanceEntries: IPerformanceEntry[],\n) => {\n  performanceEntries.forEach(entry => {\n    if (entry.identifier) {\n      logMetric(entry.startTime, entry.identifier);\n    }\n  });\n};\n","import { config } from './config';\nimport { logData } from './log';\nimport { rt } from './metrics';\nimport { IPerformanceEntry } from './types';\n\nexport const initResourceTiming = (performanceEntries: IPerformanceEntry[]) => {\n  performanceEntries.forEach(entry => {\n    if (config.isResourceTiming) {\n      logData('resourceTiming', entry);\n    }\n    if (entry.decodedBodySize && entry.initiatorType) {\n      const bodySize = entry.decodedBodySize / 1000;\n      rt.value[entry.initiatorType] += bodySize;\n      rt.value.total += bodySize;\n    }\n  });\n};\n","import { config } from './config';\nimport { initLayoutShift } from './cumulativeLayoutShift';\nimport { initFirstInputDelay } from './firstInput';\nimport { logMetric } from './log';\nimport { cls, lcp } from './metrics';\nimport { perfObservers } from './observeInstances';\nimport {\n  initElementTiming,\n  initFirstPaint,\n  initLargestContentfulPaint,\n} from './paint';\nimport { po, poDisconnect } from './performanceObserver';\nimport { initResourceTiming } from './resourceTiming';\n\nexport const initPerformanceObserver = (): void => {\n  perfObservers[0] = po('paint', initFirstPaint);\n  // FID needs to be initialized as soon as Perfume is available\n  // DataConsumption resolves after FID is triggered\n  perfObservers[1] = po('first-input', initFirstInputDelay);\n  perfObservers[2] = po('largest-contentful-paint', initLargestContentfulPaint);\n  // Collects KB information related to resources on the page\n  if (config.isResourceTiming) {\n    po('resource', initResourceTiming);\n  }\n  perfObservers[3] = po('layout-shift', initLayoutShift);\n  if (config.isElementTiming) {\n    po('element', initElementTiming);\n  }\n};\n\nexport const disconnectPerfObserversHidden = (): void => {\n  if (perfObservers[2]) {\n    logMetric(lcp.value, `lcpFinal`);\n    poDisconnect(2);\n  }\n  if (perfObservers[3]) {\n    if (typeof perfObservers[3].takeRecords === 'function') {\n      perfObservers[3].takeRecords();\n    }\n    logMetric(cls.value, `clsFinal`);\n    poDisconnect(3);\n  }\n};\n","import { logData } from './log';\nimport { convertToKB } from './utils';\n\n/**\n * The estimate() method of the StorageManager interface asks the Storage Manager\n * for how much storage the app takes up (usage),\n * and how much space is available (quota).\n */\nexport const reportStorageEstimate = (storageInfo: StorageEstimate) => {\n  const estimateUsageDetails =\n    'usageDetails' in storageInfo ? (storageInfo as any).usageDetails : {};\n  logData('storageEstimate', {\n    quota: convertToKB((storageInfo as any).quota),\n    usage: convertToKB((storageInfo as any).usage),\n    caches: convertToKB(estimateUsageDetails.caches),\n    indexedDB: convertToKB(estimateUsageDetails.indexedDB),\n    serviceWorker: convertToKB(estimateUsageDetails.serviceWorkerRegistrations),\n  });\n};\n","/*!\n * Perfume.js v7.0.0 (http://zizzamia.github.io/perfume)\n * Copyright 2022 Leonardo Zizzamia (https://github.com/Zizzamia/perfume.js/graphs/contributors)\n * Licensed under MIT (https://github.com/Zizzamia/perfume.js/blob/master/LICENSE)\n * @license\n */\nimport { config } from './config';\nimport { D, W, WN, WP } from './constants';\nimport { getNavigationTiming } from './getNavigationTiming';\nimport { getNetworkInformation } from './getNetworkInformation';\nimport { isPerformanceSupported } from './isSupported';\nimport { logData, logMetric } from './log';\nimport { performanceMeasure } from './measure';\nimport { metrics, ntbt } from './metrics';\nimport {\n  disconnectPerfObserversHidden,\n  initPerformanceObserver,\n} from './observe';\nimport { didVisibilityChange, visibility } from './onVisibilityChange';\nimport { reportStorageEstimate } from './storageEstimate';\nimport { IPerfumeOptions } from './types';\nimport { roundByFour } from './utils';\n\nlet ntbtTimeoutID = 0;\n\nexport default class Perfume {\n  v = '7.0.0';\n\n  constructor(options: IPerfumeOptions = {}) {\n    // Extend default config with external options\n    config.analyticsTracker = options.analyticsTracker;\n    config.isResourceTiming = !!options.resourceTiming;\n    config.isElementTiming = !!options.elementTiming;\n    config.maxTime = options.maxMeasureTime || config.maxTime;\n\n    // Exit from Perfume when basic Web Performance APIs aren't supported\n    if (!isPerformanceSupported()) {\n      return;\n    }\n    // Checks if use Performance or the EmulatedPerformance instance\n    if ('PerformanceObserver' in W) {\n      initPerformanceObserver();\n    }\n\n    // Init visibilitychange listener\n    if (typeof D.hidden !== 'undefined') {\n      // Opera 12.10 and Firefox 18 and later support\n      D.addEventListener(\n        'visibilitychange',\n        didVisibilityChange.bind(this, disconnectPerfObserversHidden),\n      );\n    }\n    const navigationTiming = getNavigationTiming();\n    // Log Navigation Timing\n    logData('navigationTiming', navigationTiming);\n    if (navigationTiming.timeToFirstByte) {\n      logMetric(navigationTiming.timeToFirstByte, 'ttfb');\n    }\n    // Log Network Information\n    logData('networkInformation', getNetworkInformation());\n    // Let's estimate our storage capacity\n    if (WN && WN.storage && typeof WN.storage.estimate === 'function') {\n      WN.storage.estimate().then(reportStorageEstimate);\n    }\n  }\n\n  /**\n   * Start performance measurement\n   */\n  start(markName: string): void {\n    if (!isPerformanceSupported() || metrics[markName]) {\n      return;\n    }\n    metrics[markName] = true;\n    // Creates a timestamp in the browser's performance entry buffer\n    WP.mark(`mark_${markName}_start`);\n    // Reset hidden value\n    visibility.isHidden = false;\n  }\n\n  /**\n   * End performance measurement\n   */\n  end(markName: string, customProperties = {}, doLogData = true): void {\n    if (!isPerformanceSupported() || !metrics[markName]) {\n      return;\n    }\n    // End Performance Mark\n    WP.mark(`mark_${markName}_end`);\n    delete metrics[markName];\n    const measure = performanceMeasure(markName);\n    if (doLogData) {\n      logData(markName, roundByFour(measure), customProperties);\n    }\n  }\n\n  /**\n   * End performance measurement after first paint from the beging of it\n   */\n  endPaint(markName: string, customProperties?: object): void {\n    setTimeout(() => {\n      this.end(markName, customProperties);\n    });\n  }\n\n  /**\n   * Removes the named mark from the browser's performance entry buffer.\n   */\n  clear(markName: string): void {\n    delete metrics[markName];\n    // Mobile Safari v13 and UC Browser v11\n    // don't support clearMarks yet\n    if (!WP.clearMarks) {\n      return;\n    }\n    WP.clearMarks(`mark_${markName}_start`);\n    WP.clearMarks(`mark_${markName}_end`);\n  }\n\n  /**\n   * NTBT = Navigation Total Blocking Time\n   *\n   * This metric measures the amount of time the application may be blocked\n   * from processing code during the 2s window after a user navigates\n   * from page A to page B.\n   *\n   * Because this library is navigation agnostic, we have this method\n   * to mark when the navigation starts.\n   *\n   * The NTBT metric is the summation of the blocking time of all long tasks\n   * in the 2s window after this method is invoked.\n   *\n   * If this method is called before the 2s window ends; it will trigger a new\n   * NTBT measurement and interrupt the previous one.\n   *\n   * Credit: Thank you Steven Lam for helping with this!\n   */\n  markNTBT(): void {\n    this.start('ntbt');\n    // Reset NTBT value\n    ntbt.value = 0;\n    clearTimeout(ntbtTimeoutID);\n    // @ts-ignore\n    ntbtTimeoutID = setTimeout(() => {\n      this.end('ntbt', {}, false);\n      logMetric(ntbt.value, `ntbt`);\n      ntbt.value = 0;\n    }, 2000);\n  }\n}\n","import { WP } from './constants';\nimport { isPerformanceSupported } from './isSupported';\nimport { IPerfumeNavigationTiming } from './types';\n\n/**\n * Navigation Timing API provides performance metrics for HTML documents.\n * w3c.github.io/navigation-timing/\n * developers.google.com/web/fundamentals/performance/navigation-and-resource-timing\n */\nexport const getNavigationTiming = (): IPerfumeNavigationTiming => {\n  if (!isPerformanceSupported()) {\n    return {};\n  }\n  // There is an open issue to type correctly getEntriesByType\n  // github.com/microsoft/TypeScript/issues/33866\n  const n = WP.getEntriesByType('navigation')[0] as any;\n  // In Safari version 11.2 Navigation Timing isn't supported yet\n  if (!n) {\n    return {};\n  }\n  const responseStart = n.responseStart;\n  const responseEnd = n.responseEnd;\n  // We cache the navigation time for future times\n  return {\n    // fetchStart marks when the browser starts to fetch a resource\n    // responseEnd is when the last byte of the response arrives\n    fetchTime: responseEnd - n.fetchStart,\n    // Service worker time plus response time\n    workerTime: n.workerStart > 0 ? responseEnd - n.workerStart : 0,\n    // Request plus response time (network only)\n    totalTime: responseEnd - n.requestStart,\n    // Response time only (download)\n    downloadTime: responseEnd - responseStart,\n    // Time to First Byte (TTFB)\n    timeToFirstByte: responseStart - n.requestStart,\n    // HTTP header size\n    headerSize: n.transferSize - n.encodedBodySize || 0,\n    // Measuring DNS lookup time\n    dnsLookupTime: n.domainLookupEnd - n.domainLookupStart,\n    // redirects could add latency to requests\n    redirectTime: n.redirectEnd - n.redirectStart,\n  };\n};\n","import { WP } from './constants';\n\n/**\n * Get the duration of the timing metric or -1\n * if there a measurement has not been made by the User Timing API\n */\nexport const performanceMeasure = (measureName: string): number => {\n  WP.measure(\n    measureName,\n    `mark_${measureName}_start`,\n    `mark_${measureName}_end`,\n  );\n  const entry = WP.getEntriesByName(measureName).pop();\n  if (entry && entry.entryType === 'measure') {\n    return entry.duration;\n  }\n  return -1;\n};\n"],"names":["config","t","i","o","W","window","C","console","D","document","WN","navigator","WP","performance","getDM","deviceMemory","getHC","hardwareConcurrency","isPerformanceSupported","getEntriesByType","now","mark","et","sd","getIsLowEndDevice","getIsLowEndExperience","visibility","u","didVisibilityChange","cb","hidden","isHidden","roundByFour","num","parseFloat","toFixed","convertToKB","bytes","Math","pow","fcpScore","lcpScore","clsScore","webVitalsScore","ttfb","fp","fcp","lcp","lcpFinal","fid","cls","clsFinal","tbt","ntbt","getVitalsScore","measureName","value","reportPerf","data","customProperties","indexOf","analyticsTracker","metricName","eventProperties","navigatorInformation","serviceWorkerStatus","serviceWorker","controller","isLowEndDevice","isLowEndExperience","vitalsScore","requestIdleCallback","timeout","logData","metric","Object","keys","forEach","key","logMetric","duration","duration2Decimal","maxTime","metrics","rt","beacon","css","fetch","img","other","script","total","xmlhttprequest","initLayoutShift","performanceEntries","lastEntry","pop","hadRecentInput","perfObservers","po","eventType","perfObserver","PerformanceObserver","entryList","getEntries","observe","type","buffered","e","warn","poDisconnect","observer","disconnect","initFirstInputDelay","processingStart","startTime","performanceEntry","takeRecords","setTimeout","initTotalBlockingTime","entry","name","blockingTime","initFirstPaint","initLargestContentfulPaint","renderTime","loadTime","initElementTiming","identifier","initResourceTiming","isResourceTiming","decodedBodySize","initiatorType","bodySize","disconnectPerfObserversHidden","reportStorageEstimate","storageInfo","estimateUsageDetails","usageDetails","quota","usage","caches","indexedDB","serviceWorkerRegistrations","ntbtTimeoutID","options","this","resourceTiming","isElementTiming","elementTiming","maxMeasureTime","addEventListener","bind","navigationTiming","n","responseStart","responseEnd","fetchTime","fetchStart","workerTime","workerStart","totalTime","requestStart","downloadTime","timeToFirstByte","headerSize","transferSize","encodedBodySize","dnsLookupTime","domainLookupEnd","domainLookupStart","redirectTime","redirectEnd","redirectStart","getNavigationTiming","dataConnection","connection","effectiveType","saveData","downlink","rtt","getNetworkInformation","storage","estimate","then","Perfume","markName","doLogData","measure","getEntriesByName","entryType","performanceMeasure","_this","end","clearMarks","start","clearTimeout"],"mappings":"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"}