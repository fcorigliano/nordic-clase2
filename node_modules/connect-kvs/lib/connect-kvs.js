const crypto = require('crypto');
const statsd = require('frontend-statsd/internal');
const { Item, ContainerKvsClient } = require('kvsclient');

const CIPHER_NAME = 'aes-256-gcm';

module.exports = (session) => {
  const { Store } = session;

  class KvsStore extends Store {
    constructor(options) {
      super(options);

      const defaults = {
        ttl: 1800,
        max_retries: 3,
        retry_delay: 30,
        secret: 'furysessions',
        client: null,
      };

      Object.assign(this, defaults, options);

      if (!options.client) {
        this.client = new ContainerKvsClient({
          container: options.container,
        });
      }
    }

    get(sid, fn) {
      KvsStore.retryPromise(this.client.get(sid), this.max_retries, this.retry_delay)
        .then((item) => {
          if (!item) {
            fn();
          } else {
            const data = this.decryptData(item.value);
            fn(null, JSON.parse(data));
          }
        })
        .catch((err) => {
          fn(err, {});
        });
    }

    set(sid, sess, fn) {
      const encrypted = this.encryptData(JSON.stringify(sess), this.secret);

      const item = new Item({
        key: sid,
        value: encrypted,
        ttl: this.ttl,
      });

      KvsStore.retryPromise(this.client.save(item), this.max_retries, this.retry_delay)
        .then(() => {
          fn && fn();
        })
        .catch((err) => {
          fn(err, {});
        });
    }

    destroy(sid, fn) {
      KvsStore.retryPromise(this.client.delete(sid), this.max_retries, this.retry_delay)
        .then(() => {
          fn && fn();
        })
        .catch((error) => {
          fn && fn(error);
        });
    }

    encryptData(plaintext) {
      const key = KvsStore.keygen(this.secret);
      const pt = KvsStore.encryptIv(key, plaintext);
      const hmac = KvsStore.digest(this.secret, pt.ct);

      return { ...pt, mac: hmac };
    }

    decryptData(ciphertext) {
      const hmac = KvsStore.digest(this.secret, ciphertext.ct);
      let decrypt = '';

      if (hmac !== ciphertext.mac) {
        throw new Error('Encrypted session was tampered with!');
      }

      if (typeof ciphertext.at !== 'undefined') {
        const key = KvsStore.keygen(this.secret);
        decrypt = KvsStore.decryptIv(key, ciphertext);
      } else {
        statsd.increment('nordic.connect_kvs.warning_cipher.count');
        decrypt = KvsStore.decrypt(this.secret, ciphertext.ct);
      }

      return decrypt;
    }

    static retryPromise(fn, retries, delay) {
      return new Promise((resolve, reject) => fn
        .then(resolve)
        .catch((error) => {
          if (retries <= 0) {
            reject(error);
            return;
          }
          setTimeout(() => {
            KvsStore.retryPromise(fn, retries - 1, delay)
              .then(resolve, reject);
          }, delay);
        }));
    }

    static keygen(passphrase) {
      const hash = crypto.createHash('sha512').update(passphrase).digest('hex');
      return hash.substr(0, 32);
    }

    static digest(key, obj) {
      const hmac = crypto.createHmac('sha512', key);
      hmac.setEncoding('hex');
      hmac.write(obj);
      hmac.end();
      return hmac.read();
    }

    // @deprecated
    static encrypt(key, pt) {
      const algorithm = 'aes-256-ctr';
      pt = (Buffer.isBuffer(pt)) ? pt : new Buffer(pt);

      const cipher = crypto.createCipher(algorithm, key);
      const ct = [];
      ct.push(cipher.update(pt, 'buffer', 'hex'));
      ct.push(cipher.final('hex'));

      return { ct: ct.join('') };
    }

    // @deprecated
    static decrypt(key, ct) {
      const algorithm = 'aes-256-ctr';
      const cipher = crypto.createDecipher(algorithm, key);
      const pt = [];

      pt.push(cipher.update(ct, 'hex', 'utf8'));
      pt.push(cipher.final('utf8'));

      return pt.join('');
    }

    static encryptIv(key, pt) {
      const iv = crypto.randomBytes(16).toString('hex');
      const cipher = crypto.createCipheriv(CIPHER_NAME, key, iv);

      let encrypted = cipher.update(pt, 'utf8', 'hex');
      encrypted += cipher.final('hex');

      const cipherTag = cipher.getAuthTag();

      return { ct: encrypted, at: cipherTag.toString('hex'), iv };
    }

    static decryptIv(key, ciphertext) {
      const { ct, at, iv } = ciphertext;
      const decipher = crypto.createDecipheriv(CIPHER_NAME, key, iv);

      decipher.setAuthTag(Buffer.from(at, 'hex'));

      let decrypted = decipher.update(ct, 'hex', 'utf-8');
      decrypted += decipher.final('utf-8');

      return decrypted;
    }
  }

  return KvsStore;
};
