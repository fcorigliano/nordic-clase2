const { readFileSync: readFile, existsSync: exists } = require('fs');
const { sync: commandExists } = require('command-exists');
const createDebug = require('debug');

const {
  isMac,
  isLinux,
  pathForDomain,
  // rootCAKeyPath,
  rootCACertPath,
  VALID_DOMAIN,
  VALID_IP,
} = require('./constants');

const { generateDomainCertificate, ensureDomainCertificateFreshnessFor } = require('./certificates');

const debug = createDebug('frontend-devcert:index');

function hasCertificateFor(domain) {
  return exists(pathForDomain(domain, 'certificate.crt'));
}

async function certificateFor(domain) {
  if (VALID_IP.test(domain)) {
    throw new Error('IP addresses are not supported currently');
  }

  if (!VALID_DOMAIN.test(domain)) {
    throw new Error(`"${domain}" is not a valid domain name.`);
  }

  if (!isMac && !isLinux) {
    throw new Error(`Platform not supported: "${process.platform}"`);
  }

  if (!commandExists('openssl')) {
    throw new Error('OpenSSL not found: OpenSSL is required to generate SSL certificates - make sure it is installed and available in your PATH');
  }

  const domainKeyPath = pathForDomain(domain, 'private-key.key');
  const domainCertPath = pathForDomain(domain, 'certificate.crt');

  ensureDomainCertificateFreshnessFor(domain);
  if (!hasCertificateFor(domain)) {
    await generateDomainCertificate(domain);
  }

  debug(`Returning domain certificate for ${domain}`);

  return {
    key: readFile(domainKeyPath),
    cert: readFile(domainCertPath),
  };
}

function getCACertificate() {
  return readFile(rootCACertPath);
}

module.exports = {
  certificateFor,
  getCACertificate,
};
