"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const frontend_env_1 = require("frontend-env");
const config_service_1 = require("@auth/config-service");
const constants_1 = require("./data/constants");
const reauth_1 = require("./services/reauth");
const reauth_2 = require("./client/reauth");
const urls_1 = require("./urls");
const helpers_1 = require("./helpers");
const Logger = require("frontend-logger"); // eslint-disable-line import/order
const statsd = require("frontend-statsd/internal"); // eslint-disable-line import/order
const logger = Logger('reauth-middleware');
/**
 * Checks whether the current session requires reauthentication. If it
 * does it redirects to the reauthentication flow with the current URL
 * as the one to return to after reauthenticating.
 */
const reauthMiddleware = (reauthParams) => {
    if (!reauthParams?.operationId || typeof reauthParams.operationId !== 'string') {
        throw new Error('The property operationId is required to initialize the reauthentication plugin and must be a string.\nPlease refer to the documentation: https://github.com/mercadolibre/fury_frontend-reauthentication#parameters');
    }
    const { regulation: deprecatedRegulation, regulations: deprecatedRegulations, } = reauthParams;
    if (deprecatedRegulation || deprecatedRegulations) {
        throw new Error('Passing the property "regulation" or "regulations" in the config is no longer valid.\nPlease refer to the documentation: https://github.com/mercadolibre/fury_frontend-reauthentication#regulations');
    }
    (0, config_service_1.addConfigKey)('reauth', { operation_ids: [reauthParams.operationId] });
    const middleware = async (req, res, next) => {
        if (!req.user) {
            return next();
        }
        const skipReauth = req.cookies[constants_1.REAUTH_DEV_COOKIE_NAME] === 'off'; // eslint-disable-line @typescript-eslint/no-unsafe-member-access
        if (skipReauth && req.user.test) {
            return next();
        }
        let parsedParams = {
            ...reauthParams,
        };
        const { regulation } = req.user;
        if (regulation) {
            const regulatedReauths = regulation.regulations.filter((reg) => {
                const { status } = reg;
                return status === 'APPLIED' || status === 'BLOCK';
            });
            if (regulatedReauths.length > 0) {
                parsedParams = {
                    flowType: 'other',
                    ...reauthParams,
                    regulations: regulatedReauths.map(r => r.name),
                };
            }
        }
        const { operationId, regulatedOnly } = parsedParams;
        const reauthConfig = (0, helpers_1.getConfigByOperationId)(operationId);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
        const reauthTx = req.cookies?.[constants_1.REAUTH_COOKIE_NAME] && req.cookies[constants_1.REAUTH_COOKIE_NAME] !== '0'
            ? req.cookies[constants_1.REAUTH_COOKIE_NAME] // eslint-disable-line @typescript-eslint/no-unsafe-member-access
            : undefined;
        const validationCode = req.query.code;
        if (reauthTx && validationCode) {
            try {
                (0, helpers_1.setReauthCookie)('0', req, res, { maxAge: 0 });
                await (0, reauth_2.verifyReauthenticationTransaction)(req, {
                    operationId,
                    code: validationCode,
                    reauthTransaction: reauthTx,
                });
                req.userSession.reauthChecked = { transaction_id: reauthTx };
                return next();
            }
            catch (e) {
                const { response, message } = e;
                const logData = {
                    operation_id: operationId,
                    reauth_tx: reauthTx,
                    ...response && {
                        status_code: response.status,
                        data: JSON.stringify(response.data),
                    },
                };
                logger.error(`Couldn't verify reauth transaction. Error: ${message}`, logData);
            }
        }
        const serviceParams = {
            operationId,
            regulatedOnly,
            redirectUrl: parsedParams.redirectUrl,
            regulations: parsedParams.regulations,
            flowType: parsedParams.flowType,
            ...req.reauthParams,
        };
        if (regulatedOnly && !serviceParams.regulations) {
            return next();
        }
        return (0, reauth_1.internalCheckReauthService)(req, serviceParams, true)
            .then((serviceResponse) => {
            // If reauth is needed
            if (serviceResponse.requireReauth) {
                const { transactionId, reauthUrl } = serviceResponse;
                (0, helpers_1.setReauthCookie)(transactionId, req, res, { maxAge: 10800000 }); // 3 hours
                if (req.xhr) {
                    const responseCode = 401;
                    const jsonResponse = (0, helpers_1.getJsonResponse)(responseCode, {
                        url: reauthUrl,
                        require_reauth: true,
                    });
                    res.status(responseCode).json(jsonResponse);
                }
                else {
                    res.redirect(reauthUrl);
                }
            }
            else {
                next();
            }
        })
            .catch((e) => {
            const { message, response } = e;
            if (response?.data?.redirect_path) {
                const { data } = response;
                const url = (0, urls_1.createURLFromPath)(req, data.redirect_path);
                if (req.xhr) {
                    return res.status(403).json({
                        require_reauth: true, url,
                    });
                }
                return res.redirect(url);
            }
            // Multiple sessions not allowed by IFPE regulation
            if (response?.status === 409 && req.platform && req.platform.siteId === 'MLM') {
                const url = (0, urls_1.reauthRestrictedURL)();
                if (req.xhr) {
                    return res.status(403).json({
                        require_reauth: true, url,
                    });
                }
                return res.redirect(url);
            }
            const errorBehaviour = parsedParams.ignoreErrorRedirect ? 'ignore' : reauthConfig.on_error;
            statsd.increment('business.auth.frontend-authentication.reauthentication.fail', {
                application: frontend_env_1.APPLICATION || process.env.npm_package_name,
                scope: frontend_env_1.SCOPE || 'unknown',
                test_scope: frontend_env_1.FURY_IS_TEST_SCOPE || 'unknown',
                operation_id: operationId,
                sdk_version: constants_1.version,
                on_error: req.xhr ? 'ajax' : errorBehaviour,
            });
            if (req.xhr) {
                const status = response?.status || 500;
                const data = response?.data;
                return res.status(status).json({ ...data, message, reauthFailed: true });
            }
            // The param ignoreErrorRedirect its going to be deprecated
            if (parsedParams.ignoreErrorRedirect || errorBehaviour === 'pass') {
                req.userSession.reauthFailed = {
                    message,
                };
                return next();
            }
            const url = (0, urls_1.reauthErrorURL)(req);
            return res.redirect(url);
        });
    };
    return middleware;
};
exports.default = reauthMiddleware;
