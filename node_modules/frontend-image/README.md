# frontend-image

> A React Component for rendering images in nordic environments with a lazy loading layer.

## Features

- `<Image />`
  - [Simple usage](#simple-image-on-your-page)
  - [Without lazy loading](#without-lazy-loading)
  - [Loading after page load](#loading-after-page-load)
  - [Preloading critical images with `preload` prop](#preloading-critical-images-with-preload-prop)
  - [Low end scenarios](#low-end-scenarios)
  - [Manage src and src-set as well as other img attributes](#what-if-i-want-to-add-other-attributes-to-the-rendered-image-tag)
  - [An image as a local resource](#an-image-as-a-local-resource)
    - [`<ImageProvider />`](#step-4-provide-the-context)
  - [Usage with carousel](#inside-a-carousel)
  - [Full Options](#full-options)
- [Lazy loading](#lazy-loading)
- [SVG Optimization - CLI](#svg-optimization)

## Usage

So, how can I use this component?

### Simple Image on your page

Now, let's say that you have a big amount of images on your page, or you have some images that have a very high resolution and you
would like to download them only if it is necessary. You can do this by using the image component like this:

```js
const { Image } = require('frontend-image');

// Or the legacy way
const Image = require('frontend-image');

  <Image
    src="http://link.to/image"
    alt="Alt for image"
  />
```

**By default, this component will consider that you are going to use lazy loading.** Once that image is visible, the image will start downloading

### Without lazy loading

Can I use this component to render images without [lazy loading](#lazy-loading)?

Yeah! You most certainly can! You just need to pass the flag `lazyload` in false

```js
const { Image } = require('frontend-image');

// Or the legacy way
const Image = require('frontend-image');

  <Image
    src="http://link.to/image"
    alt="Alt for image"
    lazyload="off"
  />
```

### Loading after page load

The `onload` props is an alternative to lazy loading mode when an image is always available by default on viewport and you don't want to block the document's load.

**Note that `onload` will take priority over `lazyload` meaning if both are used then lazyload will apply but images in the viewport will be loaded in the load event.**

```js
const { Image } = require('frontend-image');

// Or the legacy way
const Image = require('frontend-image');

  <Image
    src="http://link.to/image"
    alt="Alt for image"
    onload="on"
  />
```

### With a fallback image

You can configure a fallback image in case the image you're trying to load fails

```js
const { Image } = require('frontend-image');

// Or the legacy way
const Image = require('frontend-image');

  <Image
    src="http://link.to/image-with-error"
    srcFallback="http://link.to/image"
    alt="Alt for image"
  />
```

### Preloading critical images with `preload` prop

The `preload` prop uses `<link rel="preload" as="image">` allowing you to force the browser to make a request for an image without blocking the document’s onload event.

**You must use the `preload` along with `lazyload="off"`. Otherwise `lazyload` will have precedence over `preload` and thus preload won't work.**

```js
const { Image } = require('frontend-image');

// Or the legacy way
const Image = require('frontend-image');

  <Image
    src="http://link.to/image"
    alt="Alt for image"
    lazyload="off"
    preload
  />
```

### Low End scenarios

In scenarios where we are dealing with devices that are considered as low End, we can pass a flag to Image, `lowEnd`, to supress the lazy loading functionality.

```js
const { Image } = require('frontend-image');

// Or the legacy way
const Image = require('frontend-image');

  <Image
    src="http://link.to/image"
    alt="Alt for image"
    lowEnd
  />
```

### What if I want to add other attributes to the rendered image tag?

What if I want to set the width and height of my image, as well as pass some other attributes to it, like srcSet?

You can do this by passing them directly to Image, and that the component will take care of that and pass them to the img tag.

```js
const { Image } = require('frontend-image');

// Or the legacy way
const Image = require('frontend-image');

  <Image
    src="http://link.to/image"
    alt="Alt for image"
    width="500"
    height="400"
    srcSet="http://link.to/image,
            http://link.to/image1.5x,
            http://link.to/image 2x"
  />
```

### An image as a local resource

If you want to add an image that is not available on a given url but as a local asset, you can config the component in order to be able to recognise the image as a local resource in the development environment and to be uploaded automatically with *building-blocks* to the proper server for the production environment.

#### Step 1: Create the resource

Into your app folder, just create a folder, like *"assets/images"* and copy your image files in there. In this example we are supposed to copy a file named *"mla.jpg"*.

#### Step 2: Tell webpack where to get the local resource from

Webpack needs to know where to get the images from in order to copy those into the build folder.
So we need to set a new property to the classic preset, pointing to this folder you just created. This new property is called *"imagesPath"* and it available for the classicPreset configuration object.

```js
// webpack.config.js
classicPreset({
    // [...]
    imagesPath: 'assets/images',
  }),
]);
```

#### Step 3: Set the config

The production config provides a prefix value that comes from the global config. This value will be used to build the url of the static resources server.

```js
// config/default-production.js
const pkg = require(`${__dirname}/../../package.json`);
module.exports = {
    // [...]
    assets: {
        prefix: `https://http2.mlstatic.com/resources/frontend/statics/${pkg.name}/`
    },
};
```

The development config also needs to have this value, but as a simple slash pointing to the local resource.

```js
// config/default.js
module.exports = {
    // [...]
    assets: {
      prefix: '/'
    },
};
```

#### Step 4: provide the context

Now, as this url belongs to the config and the config is not available for client side, we need to forward this value to be accessed by the components. We do this though a provider that will share this value to the components.
How do we do this? We just need to pass the config value to the provider in the controller of the page, in the *'prefix'* property.

```js
const { ImageProvider } = require('frontend-image');

// Or the legacy way
const ImageProvider = require('frontend-image/provider');

exports.render = function render(req, res) {
    const View = props => (
        <I18nProvider i18n={req.i18n}>
            <ImageProvider prefix={config.assets.prefix}>
                <DemoView {...props} />
            </ImageProvider>
        </I18nProvider>
    );

    res.render(View, {
        // [...]
    });
};
```

#### Step 5: just use the component as always, but don't specify an url in the src property

In order to use the local image, just set the *src* property with the raw filename of the image.

```js
<Image
    src="mla.jpg"
    alt=""
    lazyload="on"
    width="100%"
  />
```

You need to do all this configuration just once, but it will apply for all the image instances of your view.

If you are rehydrating these components on the client side, you need to wrap your client component with the ImageProvider as well.

```js
const React = require('react');
const ReactDOM = require('react-dom');
const DemoView = require('../pages/demo/DemoView');
const I18n = require('nordic/i18n');
const I18nProvider = require('nordic/i18n/I18nProvider');

const { ImageProvider } = require('frontend-image');

// Or the legacy way
const ImageProvider = require('frontend-image/provider');

const {
  siteId,
  lowEnd,
  deviceType,
  company,
  translations,
  imagePrefix
  // this prefix will come from config.assets.prefix,
  // but we need to send it through the state in order to have it available on the frontend.
} = window.__PRELOADED_STATE__;

const i18n = new I18n({ translations });

ReactDOM.hydrate(
  <ImageProvider prefix={imagePrefix}>
    <I18nProvider i18n={i18n}>
      <DemoView
        siteId={siteId}
        lowEnd={lowEnd}
        deviceType={deviceType}
        company={company}
      />
    </I18nProvider>
  </ImageProvider>,
  document.getElementById('root-app'),
);
```

You will also need to make the `config.assets.prefix` configuration available on the client side. You can do this by sending that information
via preloaded State:

```js
const config = require('nordic/config');
const I18nProvider = require('nordic/i18n/I18nProvider');

const { ImageProvider } = require('frontend-image'); // Project root component

// Or the legacy way
const ImageProvider = require('frontend-image/provider');

const { basePath } = config.ragnar;

exports.render = function render(req, res) {
  const imagesPrefix = config.assets.images.prefix;
  const View = props => (
    <I18nProvider i18n={req.i18n}>
      <ImageProvider prefix={imagesPrefix}>
        <DemoView {...props} />
      </ImageProvider>
    </I18nProvider>
  );

  res.render(View, {
    baseURL: `${basePath}demo`,
    staticMarkup: false,
    type: 'lite',
    imagesPrefix,
  });
};

```

Then send it over to the frontend, either by using Page or directly serializing the preloaded state.

If you are using Nordic's Page component, it will look like this:

```js
const React = require('react');
const Page = require('nordic/page');

class DemoView extends React.Component {
  render() {
    const { imagesPrefix } = this.props;

    const state = {
      ...
      imagesPrefix,
    };

    return (
      <Page
        name="demo"
        state={state}
      >
        {...}
      </Page>
    )
  }
}

```

On the other hand, if you are sending over the Preloaded state using `serialize`, it will look like this:

```js
const React = require('react');
const Page = require('nordic/page');

class DemoView extends React.Component {
  render() {
    const { imagesPrefix } = this.props;

    const state = {
      ...
      imagesPrefix,
    };

    return (
      <Script>
        {`window.__PRELOADED_STATE__ = ${serialize(state, { isJSON: true })};`}
      </Script>
    )
  }
}

```

### Inside a carousel

In order to use this component with frontend-ui_libraries/carousel, there are some considerations that you need to know:

- Carousel accepts a prop called `lazyLoad`. Make sure you set it in true
- Each Slide Component will receive a flag called `mounted`, which you will need to pass to the Image component to work
- There is an additional flag on the Image component called `carousel` which you need to set to true to indicate Image that it is inside a carousel.

Here's an example. Imagine you have an OfficialStore component that shows information about an Official Store with their own image.

```js
const React = require('react');
const PropTypes = require('prop-types');

class OfficialStore extends React.Component {
    render() {
        const { link, image, title } = this.props;
        return (
          <a href={link}>
              <img
                  src={image}
                  alt={title}
              />
          </a>
        );
    }
}
```

Now, you would like that component to lazy load that image, but also be part of a carousel, since you will be displaying several of these official stores.

First, you would change the OfficialStore component and add the Image component

```js
const React = require('react');
const PropTypes = require('prop-types');

const { Image } = require('frontend-image');

// Or the legacy way
const Image = require('frontend-image');

class OfficialStore extends React.Component {
    render() {
        const { link, image, title } = this.props;
        return (
          <a href={link}>
              <Image
                  src={image}
                  alt={title}
              />
          </a>
        );
    }
}
```

Then, you would need to show these stores using the carousel component. That would look like this:

```js
const React = require('react');
const { CarouselPaged } = require('frontend-ui_libraries/carousel');
const OfficialStore = require('../OfficialStore');

const settings = {
  Slide: OfficialStore,
  dots: false,
  arrowsVisible: true,
  slidesToShow: 3,
  slidesToScroll: 3,
  variableWidth: false,
  infinite: false,
  lazyLoad: true, // <- Remember to set this to True!!
  speed: 300,
  size: {
    width: '700px',
  },
};

class OfficialStores extends React.Component {
    render() {
        const { officialStores } = this.props;
        return (
          <CarouselPaged {...settings} slides={officialStores} />
        );
    }
}
```

To finalize this configuration, we need to indicate the Image component that we are rendering it inside a carousel. We do this using the `carousel` and `mounted` flags.

```js
const React = require('react');
const PropTypes = require('prop-types');

const { Image } = require('frontend-image');

// Or the legacy way
const Image = require('frontend-image');

class OfficialStore extends React.Component {
    render() {
        const { link, image, title, mounted } = this.props;
        return (
          <a href={link}>
              <Image
                  src={image}
                  alt={title}
                  mounted={mounted}
                  carousel
              />
          </a>
        );
    }
}
```

## Full Options

Property|Type|Default|Is Required|Description
---|---|---|---|---
src|String|N/A|Yes|URL or binary data for the image to be displayed
srcFallback|String|null|No|URL for the fallback image to be displayed
srcSet|String|null|No|This specifies the string to use for the srcset attribute
alt|String|N/A|Yes|Alternate text for the img tag.
className|String|null|No|Class that will be used for the img tag.
lazyload|String(on/off)|on|No|Flag indicating that the image should be lazy loaded.
onload|String(on/off)|off|No|Flag indicating that the image should be loaded after page load.
preload|Bool|false|No|Flag indicating that the image should be preloaded.
mounted|Bool|false|No|Flag indicating that the image was mounted to the carousel. Only use this flag if your component is inside a carousel.
carousel|Bool|false|No|Flag indicating that the image will be used inside a carousel.
lowEnd|Bool|false|No|Flag indicating this component is running in a lowEnd device

## Lazy loading
In order to provide image lazy loading **server side**, this module loads a script called `ImageLoader` that replaces the `src` property of an `<img>` tag with the `data-src` property.

Note that the `ImageLoader` script loads on the server side, so if you are using `Image` only on the client side, **this script will never load**. Using lazy load only on the client side is a scenario **not supported** by this module.

### How to use client-side only Lazy Load?

First of all, it's important to understand why it's necessary to use Lazy Load client-side only, since it is a feature that makes sense on the server side to avoid penalizing rendering time.

#### When should Lazy Load **not** be used?

If images are loaded on demand after the page has already been rendered. For example, when calling an API to get image sources based on an option selected in a combo box on the rendered page.
In this case, the best option is to disable lazy loading.

Read the [Without lazy loading](#without-lazy-loading) section to learn how to turn it off.

#### What if I still want to use Lazy Load client side? 

There are two options to implement it:

1. Loading the snippet of lazy loading directly on the bundle. Read the [Image lazy load](https://github.com/mercadolibre/fury_frontend-performance/tree/master/packages/image-lazy-loading#image-lazy-load) documentation to learn how to use it.

2. Using the browser’s native lazy loading.

## SVG Optimization

frontend-image provides a CLI that will optimize the SVG files automatically and also generate React Components ready to be used.

Let's say we have this SVG file called **cross.svg**:

```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="close" x="0px" y="0px" width="100px" height="100px" viewBox="0 0 100 100" enable-background="new 0 0 100 100" xml:space="preserve">
    <g>
        <line fill="none" stroke="#000000" stroke-width="8" stroke-linecap="round" stroke-miterlimit="10" x1="49.942" y1="49.843" x2="34.896" y2="34.865"/>
        <line fill="none" stroke="#000000" stroke-width="8" stroke-linecap="round" stroke-miterlimit="10" x1="49.942" y1="49.887" x2="64.896" y2="34.911"/>
        <line fill="none" stroke="#000000" stroke-width="8" stroke-linecap="round" stroke-miterlimit="10" x1="49.942" y1="49.887" x2="64.895" y2="64.865"/>
        <line fill="none" stroke="#000000" stroke-width="8" stroke-linecap="round" stroke-miterlimit="10" x1="49.942" y1="49.887" x2="34.99" y2="64.864"/>
    </g>
    <circle fill="none" stroke="#000000" stroke-width="8" stroke-miterlimit="10" cx="50" cy="49.917" r="39.833"/>
</svg>
```

After running the CLI command, a new file will be created with the following content:

```js
const React = require('react');

const Cross = () => (
    <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
        <g strokeLinecap="round" strokeWidth="8">
            <path d="M49.942 49.843L34.896 34.865M49.942 49.887l14.954-14.976M49.942 49.887l14.953 14.978M49.942 49.887L34.99 64.864" />
        </g>
        <circle cx="50" cy="49.917" r="39.833" strokeWidth="8" />
    </svg>
);

module.exports = Cross;
```

This is a React component ready to use and with the SVG already optimized. This will happen for all the svg files of the input folder.

### Usage

#### Create an npm script

In you package.json, create a script to run the **svgo-to-jsx** command.

```js
"scripts": {
    [...],
    "svgo-to-jsx": "svgo-to-jsx"
  },
```

#### Create two entries in your default.js config

```js
[...],
assets: {
    svg: {
        from: './app/assets/from',
        to: './app/assets/to',
    },
    [...],
},
```

The **from** value represents the directory where the raw svg images are stored. And the **to** directory is the output directory where the .js file components will be created.

#### Run the svgo CLI

```
$npm run svgo-to-jsx
```

The command will process recursively all the svg files inside the **from** folder, and create the .js file components in the **to** folder, by naming the component with the original filename.

If the config is not specified in the default.js config file, it could also be sent as arguments to the CLI:

```
$npm run svgo-to-jsx ./from ./to
```
## Develop

1) Install dependencies:

```bash
npm install
```

2) Build the component:

```bash
npm run build
```

3) Build the example app:

```bash
npm run build:examples
```

4) Run the example app:

```bash
npm run start-dev
npm run watch:examples // In case you want to watch your changes
```

5) Navigate to:

```
http://dev.mercadolibre.com.ar:8080/
```

## Contact

If you want to get in touch with the team behind this, you can contact directly the Frontend Core team (frontendcore@mercadolibre.com)

## License

© 2018 Mercado Libre
