/**
 * Module dependencies
 */
const React = require('react');
const PropTypes = require('prop-types');
const classNames = require('classnames');

const { log } = require('./utils');
const LazyLoading = require('./ImageLazyLoading');
const ImagePreload = require('./ImagePreload');
const { useImage } = require('./ImageProvider');

const DEFAULT_SRC = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
const LAZYLOAD_CLASS = 'lazy-loadable';
const ONLOAD_CLASS = 'onload-loadable';
const LAZYLOAD = 'lazy';
const ONLOAD = 'onload';

/**
  * Image
  */
const Img = (props) => {
  const ImageContext = useImage();

  const ref = React.useRef();

  function hasOnLoad(onload) {
    return onload === 'on';
  }

  function hasLazyLoading(lazyload) {
    return lazyload === 'on';
  }

  function getImageLoadMode({ lazyload, onload }) {
    let imageLoadMode = null;

    if (hasLazyLoading(lazyload)) {
      imageLoadMode = LAZYLOAD;
    }

    if (hasOnLoad(onload)) {
      imageLoadMode = ONLOAD;
    }

    return imageLoadMode;
  }

  const getClass = (propClassName, imageLoadMode) => {
    let classPerform = {};

    if (imageLoadMode === LAZYLOAD) {
      classPerform = {
        [LAZYLOAD_CLASS]: true,
      };
    }

    if (imageLoadMode === ONLOAD) {
      classPerform = {
        [ONLOAD_CLASS]: true,
      };
    }

    return classNames(propClassName, classPerform);
  };

  React.useEffect(() => {
    if (typeof window !== 'undefined'
        && typeof window.imageLazyLoading === 'function') {
      const imageLoadMode = getImageLoadMode(props);
      const className = getClass(null, imageLoadMode);
      window.imageLazyLoading(className, { loadMode: imageLoadMode }, ref.current);
    }
  });

  function hasPreload({ preload, lazyload, onload }) {
    return preload && !hasLazyLoading(lazyload) && !hasOnLoad(onload);
  }

  // Builds the image source depending on the environment
  function buildSrc(src) {
    if (!src || typeof src !== 'string') {
      const errorMsg = `Invalid image source. The 'src' must be a non empty string. Received value: ${src}`;
      log.error(errorMsg);
      return DEFAULT_SRC;
    }

    const trimmedSrc = src.trim();
    const protocolRegex = /^(data:|https?:).*/;

    if (protocolRegex.test(trimmedSrc)) {
      return trimmedSrc;
    }
    return ImageContext && ImageContext.images && ImageContext.images !== {} && ('prefix' in ImageContext.images)
      ? `${ImageContext.images.prefix}${trimmedSrc}`
      : DEFAULT_SRC;
  }

  function wasMountedToCarousel(options) {
    const {
      carousel,
      mounted,
    } = options;

    return carousel && mounted;
  }

  function showSrc(options) {
    const {
      onload,
      lazyload,
      lowEnd,
    } = options;
    let show = true;

    if (hasLazyLoading(lazyload)) {
      if (wasMountedToCarousel(options)) {
        show = true;
      } else {
        show = false;
      }
    }

    if (hasOnLoad(onload)) {
      show = !!wasMountedToCarousel(options);
    }

    if (lowEnd) {
      show = true;
    }

    return show;
  }


  function buildSrcSet(srcSet) {
    const noContext = !(ImageContext && ImageContext.images && ImageContext.images !== {} && ('prefix' in ImageContext.images));
    if (noContext && !srcSet) return DEFAULT_SRC;
    if (noContext && srcSet) return srcSet; // since each src should be a url

    const sourceSets = [];
    srcSet.split(',').forEach((src) => {
      if (src) {
        sourceSets.push(`${buildSrc(src)}`);
      }
    });
    return sourceSets.join(', ');
  }


  function getImgTagProps({
    src,
    srcSet,
    className,
    alt,
    onload,
    lazyload,
    lowEnd,
    mounted,
    carousel,
    preload,
    srcFallback,
    ...imageProps
  }) {
    const newProps = {};
    const showImageSrc = showSrc({
      onload,
      lazyload,
      mounted,
      carousel,
      lowEnd,
    });

    const imageLoadMode = getImageLoadMode({ lazyload, onload });

    Object.assign(newProps, imageProps, {
      src: showImageSrc ? buildSrc(src) : DEFAULT_SRC,
      srcSet: showImageSrc && srcSet ? buildSrcSet(srcSet) : undefined,
      className: getClass(className, imageLoadMode),
      'data-src': !showImageSrc ? buildSrc(src) : undefined,
      'data-srcset': !showImageSrc && srcSet ? buildSrcSet(srcSet) : null,
      'data-src-fallback': srcFallback ? buildSrc(srcFallback) : undefined,
    });
    if (hasLazyLoading(lazyload)) {
      // to avoid hydration warning in dev mode(race condition between react.hydrate & imageLazyLoading)
      newProps.suppressHydrationWarning = true;
    }
    return newProps;
  }

  return (
    <>
      {/* eslint-disable react/destructuring-assignment, nordic/no-img-tags */}
      {hasPreload(props) && <ImagePreload href={buildSrc(props.src)} />}
      <img key="image" {...getImgTagProps(props)} ref={ref} alt={props.alt} />
      {(hasLazyLoading(props.lazyload) || hasOnLoad(props.onload)) && <LazyLoading key="lazy-loading" />}
    </>
  );
};

Img.propTypes = {
  src: PropTypes.string.isRequired,
  srcFallback: PropTypes.string,
  srcSet: PropTypes.string,
  alt: PropTypes.string.isRequired,
  className: PropTypes.string,
  lazyload: PropTypes.oneOf(['on', 'off']),
  onload: PropTypes.oneOf(['on', 'off']),
  mounted: PropTypes.bool,
  carousel: PropTypes.bool,
  lowEnd: PropTypes.bool,
  preload: PropTypes.bool,
  decoding: PropTypes.oneOf(['async', 'sync', 'auto']),
};

Img.defaultProps = {
  lazyload: 'on',
  onload: 'off',
  mounted: false,
  carousel: false,
  srcFallback: null,
  srcSet: null,
  className: null,
  lowEnd: false,
  preload: false,
  decoding: 'async',
};


/**
  * Expose Image
  */
module.exports = Img;
exports = module.exports;
exports.Image = Img;
