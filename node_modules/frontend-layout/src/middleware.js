/* eslint-disable no-restricted-syntax */

/**
 * Module dependencies
 */
const Script = require('frontend-script');
const ScriptsBundler = require('frontend-script/bundler');
const Style = require('frontend-style');
const StylesBundler = require('frontend-style/bundler');
const MeliGA = require('frontend-analytics/meli-ga');
const { trafficControl } = require('perfill-agent');

const feConfig = require('frontend-config');
const MelidataTrack = require('frontend-melidata/melidata-track');
const { bundle: metricsBundler, rewind: metricsRewind } = require('@frontend-metrics/core');

const ReactDOMServer = require('react-dom/server');
const HeadSync = require('react-declarative-head');
const ChunkExtractor = require('frontend-lazy/server/extractor');
const React = require('react');

const { StyleSheetServer } = require('aphrodite');
const Navigations = require('frontend-navigations');
const env = require('frontend-env');
const layout = require('./utils/layout');
const getAssetsConfig = require('./utils/get-assets-config');
const getLayoutComponent = require('./utils/get-layout-component');
const getStats = require('./utils/get-stats');
const { isNone } = require('./utils/layout-type-detection');
const {
  getDynamicContentPromise,
  processDynamicMarkup,
} = require('./dynamic-content');
const { get: getLayoutType, Types: LayoutTypes } = require('./utils/layout/types');

const { getCDNProvider } = require('../config/head-config');

// CSS-in-JS for server-side rendering
const getStyleFromJs = require('./utils/get-style-from-js');
const getPreloadHeader = require('./utils/get-preload-header');
const {
  getPropsFromRenderOptions,
  showDeprecatedOptionWarnings,
} = require('./utils/render-options');
const { getMetaTagsConfig } = require('./utils/meta-tags');

const defaultRenderOptions = {};

const getOptionsParameters = (renderOptions) => {
  const renderOptionsType = typeof renderOptions;
  if (renderOptionsType === 'object') {
    return {
      renderOptions,
      done: renderOptions.done,
    };
  }

  if (renderOptionsType === 'function') {
    return {
      renderOptions: defaultRenderOptions,
      done: renderOptions,
    };
  }

  return {
    renderOptions: defaultRenderOptions,
  };
};

const getCSRFToken = (req) => (typeof req.csrfToken === 'function' ? req.csrfToken() : null);

const getActualLocation = (req, secure) => {
  const proto = secure ? 'https' : 'http';
  return `${proto}://${req.headers.host + req.originalUrl}`;
};

const getNavigation = (req, options, layoutOptions) => (layoutOptions.navigationId && Navigations.get(layoutOptions.navigationId))
  || options.navigation
  || Navigations.create(req);

/**
 * Layout Middleware
 */
function layoutMiddleware(options = {}) {
  // Return the middleware function
  return function layoutMiddlewareFn(req, res, next) {
    // Configure a custom layout or use the default
    const LayoutComponent = getLayoutComponent(options, req);
    const { prepareToRender } = LayoutComponent;

    function resRender(Component, appProps = {}, optionsDoneParameter) {
      const {
        done,
        renderOptions,
      } = getOptionsParameters(optionsDoneParameter);

      const feConfigEnvironment = feConfig.getEnvironment(req);

      const secure = req.headers.ml_ssl === '1' || req.connection.encrypted;
      const cdnProvider = getCDNProvider(appProps.cdn);

      appProps = { ...appProps, // eslint-disable-line no-param-reassign
        ...{
          cdnDomain: cdnProvider.link,
          queryString: req.query,
          referrer: req.headers.referer,
          pageId: env.APPLICATION || env.npm_package_name,
        },
      };

      const layoutOptions = getPropsFromRenderOptions(appProps, renderOptions, 'layout');
      showDeprecatedOptionWarnings(layoutOptions, 'layout');

      const navigationOptions = getPropsFromRenderOptions(appProps, renderOptions, 'navigation');

      if (req.device.webView) {
        navigationOptions.type = 'hidden';
      }

      let chunkExtractor;
      if (layoutOptions.loadable) {
        const entrypoints = typeof layoutOptions.loadable === 'string' ? [layoutOptions.loadable] : layoutOptions.loadable;
        chunkExtractor = new ChunkExtractor(entrypoints);
        Component = chunkExtractor.collectChunks(Component); // eslint-disable-line no-param-reassign
      }

      const calculatedLayoutProps = {
        user: req.user,
        device: req.device,
        platform: req.platform,
        browser: req.browser,
        actualLocation: getActualLocation(req, secure),
        scripts: null,
        criticalPath: {},
        perfill: trafficControl(req, feConfigEnvironment),
        Navigation: getNavigation(req, options, layoutOptions),
        feConfigEnvironment,
      };

      const prepareToRenderParams = {
        ...calculatedLayoutProps, ...options, ...appProps, ...layoutOptions, ...navigationOptions,
      };

      Promise.all([
        getDynamicContentPromise(req),
        prepareToRender(prepareToRenderParams, req, res),
      ])
        .then(async ([dynamicContent, prepareToRenderResult]) => {
          const {
            injectMarkup,
            getPositionMarkup,
          } = processDynamicMarkup(dynamicContent, req, res);

          const { layoutSpecificProps, ...prepareToRenderProps } = prepareToRenderResult || {};

          const shouldInjectMarkupOnBody = !!options.layout;
          const layoutComponentProps = Object.assign(
            prepareToRenderParams,
            prepareToRenderProps,
            layoutSpecificProps,
            shouldInjectMarkupOnBody ? {} : { getPositionMarkup },
          );
          const layoutType = req.device.webView ? LayoutTypes.webView.name : getLayoutType(layoutComponentProps.type).name;

          // CSS-in-JS for server-side
          const cssInJs = layoutOptions.cssInJs || options.cssInJs || false;

          /**
           * Create Layout with user, platform and device props,
           * then render the components (should be called before HeadSync.rewind,
           * MeliGa.rewind and other bundling scripts)
           */
          let html;
          let app;
          let css;
          try {
            // LAYOUT/NAVIGATION RENDERING
            if (!isNone(layoutComponentProps.type)) {
              const LayoutWithProps = React.createElement(LayoutComponent, layoutComponentProps);
              html = ReactDOMServer.renderToStaticMarkup(LayoutWithProps);
            }

            // APP RENDERING
            const appComponentProps = {
              ...calculatedLayoutProps, ...options, ...appProps, ...prepareToRenderProps,
            };

            // Render component with the given props
            // If cssInJs is set use aphrodite/StyleSheetServer to generated html, as well as the generated css
            if (cssInJs && !layoutComponentProps.staticMarkup) {
              const styleSheet = StyleSheetServer.renderStatic(() => (
                ReactDOMServer.renderToString(React.createElement(Component, appComponentProps))
              ));

              app = styleSheet.html;
              css = styleSheet.css;
            } else {
              app = Component ? ReactDOMServer[
                layoutComponentProps.staticMarkup ? 'renderToStaticMarkup' : 'renderToString'
              ](React.createElement(Component, appComponentProps)) : '';
            }
          } catch (err) {
            // Ensure we reset our side effects to avoid iconsistent states between request's
            // it also prevents memory leakage
            HeadSync.rewind();
            Style.rewind();
            Script.rewind();
            MeliGA.rewind();
            MelidataTrack.rewind();
            metricsRewind();

            // If a callback exist, pass an error to the callback
            if (done) {
              return done(err, null);
            }
            // Pass the exception to the next middleware otherwise
            return next(err);
          }
          // Start response
          res.header('Content-Type', 'text/html; charset=utf-8');

          /**
           * Get assets config for styles and scripts
           */
          const assetsConfig = getAssetsConfig({
            cdn: layoutComponentProps.cdn,
            feConfigEnvironment,
          });

          /**
           * Create promises
           */
          const headBundler = Promise.resolve(HeadSync.rewind());

          const nonceCSP = res.locals.nonce;
          const stylesBundler = new StylesBundler({
            ...assetsConfig,
            criticalKey: layoutComponentProps.criticalPath.key,
            criticalCookiePath: layoutComponentProps.criticalPath.cookiePath,
            criticalCookieDomain: layoutComponentProps.criticalPath.cookieDomain,
            nonceCSP,
          });

          const scriptsBundler = new ScriptsBundler(assetsConfig);

          const appendedScripts = [
            ...(await metricsBundler(req)),
          ];

          // Using the Promise.all to parallelize the bundling
          return Promise.all([
            headBundler,
            stylesBundler.bundle(req, res, Style),
            scriptsBundler.bundle(Script, req, null, appendedScripts, chunkExtractor),
          ])
            .then(([headBundle, stylesBundle, scriptsBundle]) => {
              const { styles, scripts } = getStyleFromJs(stylesBundle.styles, scriptsBundle.scripts, css, cssInJs);
              const preloadHeader = getPreloadHeader([
                headBundle,
                stylesBundle,
                scriptsBundle,
              ]);

              if (preloadHeader) {
                const prevLinks = res.getHeader('Link') ? `${res.getHeader('Link')},` : '';
                res.header('Link', `${prevLinks}${preloadHeader}`);
              }

              // Call get layout
              layout(layoutType, {
                app,
                nonceCSP,
                csrfToken: getCSRFToken(req),
                lowEnd: req.device.lowEnd,
                countryId: req.platform.countryId,
                initialState: layoutComponentProps.state,
                headsync: headBundle,
                styles,
                scripts,
                // TODO decouple code because next params are used only in the Base
                props: layoutComponentProps,
                req,
                html,
                chunkExtractor,
                metaTagsConfig: getMetaTagsConfig(req, feConfigEnvironment),
              }).then((output) => {
                const finalOutput = shouldInjectMarkupOnBody
                  ? injectMarkup(output)
                  : output;
                const statsInstance = layoutOptions.performanceStats ? getStats(Component.name) : null;
                if (statsInstance) {
                  layoutComponentProps.performanceStats(statsInstance());
                }

                // If a callback exist, pass output to the callback
                // callback works like http://expressjs.com/en/4x/api.html#res.render
                if (done) {
                  return done(null, finalOutput);
                }

                return res.send(finalOutput);
              });
            })
            // Catch and throw the error, which triggers the next
            // reject handler in the chain to be called.
            .catch((err) => {
              throw err;
            });
        })
        .catch((err) => {
          // If a callback exist, pass error to the callback
          if (done) {
            return done(err, null);
          }

          return next(err);
        });
    }

    // Overwrite res.render()
    res.render = resRender;
    next();
  };
}

/**
 * Expose layoutMiddleware
 */
module.exports = layoutMiddleware;
