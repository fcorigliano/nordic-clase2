const React = require('react');
const ReactDOMServer = require('react-dom/server');
const Style = require('frontend-style');
const Script = require('frontend-script');
const { parse } = require('node-html-parser');
const { send } = require('./utils/statsd');
const logger = require('./utils/logger');
const {
  NO_BODY,
  NO_DYNAMIC_CONTENT,
  DYNAMIC_CONTENT_INJECT_ERROR,
  DYNAMIC_CONTENT_PROCESS_ERROR,
  POSITION_NOT_SUPPORTED,
} = require('./constants/statsd');

const {
  positions: {
    TOP,
    BOTTOM,
  },
  types: {
    NONE,
    HTML,
  },
  requestNamespace,
} = require('./constants/dynamic-content');

const knownPositions = [
  TOP,
  BOTTOM,
];

const getErrorTags = (req) => ({
  host: req.get('host'),
  originalUrl: req.originalUrl,
});

const getDefaultDynamicContent = (req) => ({
  getDynamicContent: () => {
    send({
      req,
      key: NO_DYNAMIC_CONTENT,
    });

    logger.error('Error getting dynamic content from request', getErrorTags(req));

    return Promise.resolve({
      type: NONE,
    });
  },
});

const getDynamicContentPromise = (req) => ((req[requestNamespace] || getDefaultDynamicContent(req)).getDynamicContent || getDefaultDynamicContent(req).getDynamicContent)();

const mapCodeToChildren = ({ code: children, ...otherProps }) => ({
  ...otherProps,
  ...(!children
    ? null
    : { children }),
});

const processDynamicMarkup = (dynamicContent, req, res) => {
  try {
    const data = (dynamicContent.type === HTML && dynamicContent.data) || [];
    const initialTempData = knownPositions.reduce((tempData, position) => ({
      [position]: [],
      ...tempData,
    }), {});

    const hasSameSiteSupport = (req && req.browser && req.browser.support && req.browser.support.sameSite) || false;

    const markups = data.reduce((tempData, markupData) => {
      // discard unknown positions
      if (!tempData[markupData.position]) {
        send({
          req,
          key: POSITION_NOT_SUPPORTED,
          additionalTags: {
            position: markupData.position,
          },
        });
        return tempData;
      }

      // render styles and scripts so the bundler gets them and get output markup
      const toRender = markupData.styles.map((styleData) => React.createElement(Style, mapCodeToChildren(styleData)))
        .concat(markupData.scripts.map((scriptData) => React.createElement(Script, mapCodeToChildren(scriptData))));

      const styleScriptMarkup = toRender.length ? (ReactDOMServer.renderToStaticMarkup(toRender) || '') : '';

      // markup
      const markup = `${markupData.markup}${styleScriptMarkup}`;
      if (markup) {
        tempData[markupData.position].push(markup);
      }

      markupData.cookies.forEach((cookieData) => {
        const {
          name,
          value,
          metadata = {},
        } = cookieData;

        const {
          sameSite,
          ...otherMetadata
        } = metadata;

        const sameSiteMetadata = hasSameSiteSupport && sameSite
          ? { sameSite }
          : null;

        res.cookie(name, value, {
          ...otherMetadata,
          ...sameSiteMetadata,
        });
      });

      return tempData;
    }, initialTempData);

    const injectMarkup = (initialOutput) => {
      try {
        if (!knownPositions.some((position) => markups[position].length)) {
          return initialOutput;
        }

        const root = parse(initialOutput);
        const body = root.querySelector('body');

        if (!body) {
          send({
            req,
            key: NO_BODY,
          });

          logger.error('Error getting body from markup', getErrorTags(req));

          return initialOutput;
        }

        if (markups[TOP].length) {
          const toInsert = markups[TOP].join('');
          body.insertAdjacentHTML('afterbegin', toInsert);
        }

        if (markups[BOTTOM].length) {
          const toInsert = markups[BOTTOM].join('');
          body.insertAdjacentHTML('beforeend', toInsert);
        }

        return root.toString();
      } catch (e) {
        send({
          req,
          key: DYNAMIC_CONTENT_INJECT_ERROR,
        });

        const message = (e && e.message) || null;
        logger.error('Error injecting dynamic content', {
          ...getErrorTags(req),
          message,
        });

        return initialOutput;
      }
    };

    const getPositionMarkup = position => (markups[position] || []).join('');

    return {
      injectMarkup,
      getPositionMarkup,
    };
  } catch (e) {
    send({
      req,
      key: DYNAMIC_CONTENT_PROCESS_ERROR,
    });

    const message = (e && e.message) || null;
    logger.error('Error processing dynamic content', {
      ...getErrorTags(req),
      message,
    });

    const injectMarkup = (output) => output;

    const getPositionMarkup = () => '';

    return {
      injectMarkup,
      getPositionMarkup,
    };
  }
};

module.exports = {
  getDynamicContentPromise,
  processDynamicMarkup,
};
