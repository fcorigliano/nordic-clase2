const { EventEmitter } = require('events');
const debug = require('debug')('mock:request');

function mockRequest() {
  const req = new EventEmitter();

  // Using the names prefixed with underscore to not generate conflicts when the mocked request will be proxied to an
  // original http.request while fetching original data
  req._headers = {};
  req._headerNames = {};

  req.setHeader = function setHeader(name, value) {
    debug('setHeader', name, value);

    const key = name.toLowerCase();

    req._headers[key] = value;
    req._headerNames[key] = name;

    if (name === 'expect' && value.toLowerCase() === '100-continue') {
      setImmediate(() => {
        req.emit('continue');
      });
    }
  };

  req.getHeader = function getHeader(name) {
    if (!Object.keys(req._headers).length) {
      return null;
    }

    const key = name.toLowerCase();

    return req._headers[key];
  };

  req.abort = function abort() {
    debug('req.abort');

    const err = new Error('socket hang up');

    req.aborted = true;

    err.code = 'aborted';
    req.res.emit('close', err);

    req.emit('abort');

    process.nextTick(() => {
      err.code = 'ECONNRESET';
      req.emit('error', err);
    });
  };

  req.write = function write(buffer, encoding, callback) {
    debug('req.write', buffer, encoding);
    let result = false;

    if (typeof encoding === 'function' && arguments.length === 2) {
      callback = encoding;
      encoding = undefined;
    }

    if (buffer && !req.aborted) {
      if (!Buffer.isBuffer(buffer)) {
        buffer = Buffer.from(buffer, encoding);
      }

      if (typeof callback === 'function') {
        callback();
      }

      req.emit('data', buffer);
      result = true;
    }

    if (req.aborted) {
      process.nextTick(() => {
        req.emit('error', new Error('Request aborted'));
      });
    }

    setImmediate(() => {
      req.emit('drain');
    });

    return result;
  };

  req.end = function end(buffer, encoding, callback) {
    debug('req.end');

    // Since all parameters of req.end are optional but at the sema time it accepts up to three parameters
    // we need to handle all this cases in the right way.
    if (typeof buffer === 'function' && arguments.length === 1) { // callback function as the only argument
      callback = buffer;
      buffer = null;
    } else if (typeof encoding === 'function' && arguments.length === 2) { // callback function as the second argument
      callback = encoding;
      encoding = undefined;
    }

    // Write response content and call the callback only when request is not aborted
    if (!req.aborted) {
      req.write(buffer, encoding);

      if (typeof callback === 'function') {
        callback();
      }

      req.emit('finish');
      req.emit('end');
    }

    // Emit the request error event when requests is aborted atr this stage
    if (req.aborted) {
      process.nextTick(() => {
        req.emit('error', new Error('Request aborted'));
      });
    }
  };

  // Fill the rest of requests methods with empty function since they are not affects the functionality of mock but may
  // be called from other libraries
  ['setEncoding', 'setKeepAlive', 'setNoDelay'].forEach((key) => {
    req[key] = function () {};
  });

  return req;
}

module.exports = mockRequest;
