const url = require('url');
const qs = require('querystring');
const pathToRegexp = require('path-to-regexp');
const _ = require('lodash');
const debug = require('debug')('mock:interceptor');

/**
 * A list of all valid HTTP methods and a wildcard `*`.
 * Wildcard is used for backward compatibility, for better performance please consider to remove it in the future and
 *   indicate all intercepting methods explicitly.
 *
 * @type {string[]}
 */
const AVAILABLE_METHODS = ['*', 'GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'TRACE', 'PATCH'];

const SUPPORTED_PROTOS = ['http:', 'https:'];

/**
 * Registered interceptors collection
 *
 * @type {{}}
 */
let registeredInterceptors = {};

/**
 * Interceptor class
 */
class Interceptor {
  constructor() {
    this.interceptors = registeredInterceptors;
  }

  /**
   * Register a new interceptor
   *
   * @param {string} protocol
   * @param {string} hostname
   * @param {string|array|object} rules
   * @param {object} transformers
   * @return {*}
   */
  register(protocol, hostname, rules, transformers = {}) {
    debug('Registering new interceptor: %s, %s, %j, %j', protocol, hostname, rules, transformers);

    if (!protocol || !hostname) {
      throw new Error('protocol and hostname are required');
    }

    const { interceptors } = this;
    let interceptorRules = rules;

    if (!interceptorRules) {
      interceptorRules = [{ path: '/*' }];
    }

    if (typeof interceptorRules === 'string') {
      interceptorRules = [{ path: interceptorRules }];
    }

    if (typeof interceptorRules === 'object' && !Array.isArray(interceptorRules)) {
      interceptorRules = [interceptorRules];
    }

    interceptorRules.forEach((r) => {
      if (typeof r === 'string') {
        r = { path: r }; // eslint-disable-line no-param-reassign
      }

      if (r.path) {
        const path = r.path === '/' ? '/*' : r.path;
        const key = Interceptor.generateKey(r.method, protocol, hostname);

        if (!interceptors[key]) {
          interceptors[key] = {
            key,
            rules: [],
          };
        }

        interceptors[key].rules.push({
          path,
          transformers,
          headers: r.headers,
          query: r.query,
          body: r.body,
        });
      }
    });

    return interceptors;
  }

  /**
   * Remove all registered interceptors
   */
  deregisterAll() {
    registeredInterceptors = {};
    this.interceptors = registeredInterceptors;
  }

  /**
   * Deregister an interceptor
   *
   * If you have a doubt about "unregister" vs "deregister" please read this genial explanation http://english.stackexchange.com/a/40095
   *
   * @param protocol
   * @param hostname
   * @param path
   * @return {*}
   */
  deregister(protocol, hostname, rules) {
    debug('Deregistering the interceptor: %s, %s, %j', protocol, hostname, rules);

    const { interceptors } = this;

    if (!protocol || !hostname) {
      throw new Error('protocol and hostname are required');
    }

    let interceptorRules = rules;

    if (!interceptorRules) {
      interceptorRules = [{ path: '/*' }];
    }

    if (typeof interceptorRules === 'string') {
      interceptorRules = [{ path: interceptorRules }];
    }

    if (typeof interceptorRules === 'object' && !Array.isArray(interceptorRules)) {
      interceptorRules = [interceptorRules];
    }

    let result = false;

    interceptorRules.forEach((r) => {
      const key = Interceptor.generateKey(r.method, protocol, hostname);

      if (typeof r === 'string') {
        r = { path: r }; // eslint-disable-line no-param-reassign
      }
      const path = r.path === '/' ? '/*' : r.path;

      if (interceptors[key]) {
        result = interceptors[key].rules.some((rule, idx) => {
          if (_.isEqual({
            path: rule.path, headers: rule.headers, query: rule.query, body: rule.body,
          },
          {
            path, headers: r.headers, query: r.query, body: r.body,
          })) {
            interceptors[key].rules.splice(idx, 1);
            return true;
          }
          return false;
        });
      }
    });

    return result;
  }

  /**
   * Matches provided domain and path with the registered interceptors
   *
   * Uses the same options object as https://nodejs.org/api/http.html#http_http_request_options_callback
   *
   * @param {(String|Object)} options
   * @return {{matches: boolean, transformers: {}}}
   */
  match(options) {
    let opts = options;

    if (!opts) {
      throw new Error('Options parameter is required');
    } else if (typeof opts === 'string') {
      opts = url.parse(options);
    } else if (typeof opts !== 'object') {
      throw new Error('Options parameter must be an object');
    }

    debug('Matching the interceptor for %j', opts);

    const { interceptors } = this;
    const { protocol } = opts;
    const { hostname } = opts;
    const { path } = opts;
    const method = opts.method || 'GET';

    let match = false;

    const key = Interceptor.generateKey(method, protocol, hostname);
    // TODO: Due to backward compatibility we should check additionally for a wildcard match, please remove it in the future
    const keyWildcard = Interceptor.generateKey('*', protocol, hostname);

    const interceptor = interceptors[key] || interceptors[keyWildcard];

    if (!interceptor) {
      return {
        matches: match,
        transformers: {},
      };
    }

    let idx = 0;
    let transformers = {};
    while (match !== true && idx < interceptor.rules.length) {
      const rx = interceptor.rules[idx];
      const regex = pathToRegexp(rx.path);

      if (regex.exec(path) !== null || rx.path === options.pathname) {
        const matchHeaders = !rx.headers
          || Object.keys(rx.headers)
            .every((headerKey) => Interceptor.headerMatches(options, headerKey.toLowerCase(), rx.headers[headerKey])); // eslint-disable-line no-loop-func
        const matchQuery = !rx.query
          || Object.keys(rx.query)
            .every((queryKey) => Interceptor.queryMatches(options, queryKey, rx.query[queryKey])); // eslint-disable-line no-loop-func

        if (matchHeaders && matchQuery) {
          match = true;
          transformers = rx.transformers;
        }
      }

      idx += 1;
    }

    return {
      matches: match,
      transformers,
    };
  }

  static generateKey(method, protocol, hostname) {
    const verb = method && AVAILABLE_METHODS.includes(method.toUpperCase()) ? method.toUpperCase() : '*';
    const proto = protocol.endsWith(':') ? protocol : `${protocol}:`;

    if (!SUPPORTED_PROTOS.includes(proto)) {
      throw new Error(`Unsupported protocol ${proto}`);
    }

    return `${verb} ${proto}//${hostname}`;
  }

  static headerMatches(options, key, value) {
    // If request has no headers any additional comparisons make no sense
    if (!options.headers) {
      return false;
    }

    let reqHeaderValue = options.headers[key];
    if (reqHeaderValue && (typeof reqHeaderValue !== 'string') && reqHeaderValue.toString) {
      reqHeaderValue = reqHeaderValue.toString();
    }

    if (typeof value !== 'undefined' && typeof reqHeaderValue !== 'undefined') {
      if (typeof value === 'function') {
        return value(reqHeaderValue);
      } if (value instanceof RegExp) {
        return value.test(reqHeaderValue);
      }
      return reqHeaderValue === String(value);
    }

    return false;
  }

  static queryMatches(options, key, value) {
    // If request has no headers any additional comparisons make no sense
    if (!options.query) {
      return false;
    }

    let { query } = options;
    if (typeof query === 'string') {
      try {
        query = qs.parse(query);
      } catch (e) {} // eslint-disable-line no-empty
    }

    const reqQueryValue = query[key];

    if (typeof value !== 'undefined' && typeof reqQueryValue !== 'undefined') {
      if (typeof value === 'function') {
        return value(reqQueryValue);
      } if (value instanceof RegExp) {
        return value.test(reqQueryValue);
      }
      return reqQueryValue === String(value);
    }

    return false;
  }
}

module.exports = Interceptor;
