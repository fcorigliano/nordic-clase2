/**
 * Module dependencies
 */
const defaults = require('../../config/defaults');
const BaseClient = require('./BaseClient');
const logger = require('frontend-logger')('KVS');
const {
  KvsClient,
  KvsApiConfiguration,
  ContainerKvsClient,
  Item,
} = require('kvsclient');

/**
 * KvsCache with promises
 */
class KVSClient extends BaseClient {
  /**
   * Initialize client
   *
   * @param {Object} configs client specific configurations
   * @param {Object} options options for the implementation
   */
  constructor(configs = {}, options = {}) {
    super(configs, options, 'KVS');

    if (!configs.container) {
      throw new TypeError('You must to specify a "container" to use KVS cache client.');
    } else if (typeof configs.container !== 'string') {
      throw new TypeError('"container" must be string');
    }

    // Generate the configurations for the client
    this.config = { version: '',
      readTimeout: defaults.kvs.readTimeout,
      writeTimeout: defaults.kvs.writeTimeout,
      ...configs };

    // Initialize KVSClient
    this.kvsClient = new KvsClient({
      kvsApiConfiguration: new KvsApiConfiguration({
        readTimeout: this.config.readTimeout,
        writeTimeout: this.config.writeTimeout,
      }),
    });

    // Initialize KVS Container (client)
    this.client = new ContainerKvsClient({
      container: this.config.container,
      delegate: this.kvsClient,
    });
  }

  /**
   * Get value from key
   *
   * @param {String} key to find on cache
   * @returns {Promise<Object>} data from cache
   */
  get(key) {
    /* istanbul ignore next */ // eslint-disable-next-line no-unused-expressions
    this.shouldLog() && logger.debug(`Getting key "${key}"`);
    this.trace(BaseClient.OPERATIONS_ALLOWED.GET, this.name);

    return new Promise((resolve, reject) => {
      this.client.get(this.normalizeKey(key))
        .then((item) => { // eslint-disable-line consistent-return
          if (item && item instanceof Item) {
            return resolve(item.value);
          }
          return resolve(undefined);
        })
        .catch((err) => {
          /* istanbul ignore next */
          logger.error(`An error occurred getting the key "${key}": ${err.message}`);
          reject(err);
        });
    });
  }

  /**
   * Set value on a key with specific options
   *
   * @param {String} key to find on cache
   * @param {String} value from cache
   * @param {Number} [lifetime=86400] in seconds. The default is 24 hours
   * @returns {Promise<void>}
   */
  set(key, value, lifetime = this.lifetime) {
    return new Promise((resolve, reject) => { // eslint-disable-line consistent-return
      if (!key || !value) return reject(new Error('key and value are required'));

      /* istanbul ignore next */ // eslint-disable-next-line no-unused-expressions
      this.shouldLog() && logger.debug(`Setting key "${key}" with value "${JSON.stringify(value)}"`);
      this.trace(BaseClient.OPERATIONS_ALLOWED.SET, this.name);

      const item = new Item({
        key: this.normalizeKey(key),
        value,
        ttl: lifetime,
      });

      this.client.save(item)
        .then(() => resolve(true))
        .catch((err) => {
          /* istanbul ignore next */
          logger.error(`An error occurred setting the key "${key}": ${err.message}`);
          reject(err);
        });
    });
  }

  /**
   * Delete key from cache
   *
   * @param {String} key to find on cache
   */
  delete(key) {
    /* istanbul ignore next */ // eslint-disable-next-line no-unused-expressions
    this.shouldLog() && logger.debug(`Deleting key "${key}"`);
    this.trace(BaseClient.OPERATIONS_ALLOWED.DELETE, this.name);

    return new Promise((resolve, reject) => {
      this.client.delete(this.normalizeKey(key))
        .then(() => resolve(true))
        .catch((err) => {
          /* istanbul ignore next */
          logger.error(`An error occurred deleting the key "${key}": ${err.message}`);
          reject(err);
        });
    });
  }

  /**
   * Normalize key adding a version prefix.
   * @param {String} key
   * @return {String} key with version prefix
   */
  normalizeKey(key) {
    return this.config.version ? `${this.config.version}-${key}` : key;
  }
}

/**
 * Export KvsCache / LRUCachePromised instance.
 * Only use KVS in production.
 */
module.exports = KVSClient;
