/**
 * Module dependencies
 */
const BaseClient = require('./BaseClient');
const logger = require('frontend-logger')('Memcached');
const Memcached = require('memcached');

/**
 * Memcached with promises
 */
class MemcachedClient extends BaseClient {
  /**
   * Initialize client
   *
   * @param {Object} configs client specific configurations
   * @param {Object} options options for the implementation
   */
  constructor(configs = {}, options = {}) {
    super(configs, options, 'Memcached');

    if (!configs.nodesEndpoint) {
      throw new TypeError('You must specify a "nodesEndpoint" to use Memcached cache client.');
    } else if (typeof configs.nodesEndpoint !== 'string') {
      throw new TypeError('"nodesEndpoint" must be a string');
    }

    const nodes = configs.nodesEndpoint.split(/\s+/);

    // Remove nodesEndpoint from configuration to prevent send it to the memcached library
    delete configs.nodesEndpoint;

    this.client = new Memcached(nodes, configs);
  }

  /**
   * Get value from key
   *
   * @param {String} key to find on cache
   * @returns {Promise<Object>} data from cache
   */
  get(key) {
    /* istanbul ignore next */ // eslint-disable-next-line no-unused-expressions
    this.shouldLog() && logger.debug(`Getting key "${key}"`);
    this.trace(BaseClient.OPERATIONS_ALLOWED.GET, this.name);

    return new Promise((resolve, reject) => {
      this.client.get(key, (err, data) => { // eslint-disable-line consistent-return
        if (err) {
          /* istanbul ignore next */
          logger.error(`An error occurred getting the key "${key}": ${err.message}`);
          return reject(err);
        }
        resolve(data);
      });
    });
  }

  /**
   * Set value on a key with specific options
   *
   * @param {String} key to find on cache
   * @param {String} value from cache
   * @param {Object} options to be pass to the client
   * @param {Number} [lifetime=86400] in seconds. The default is 24 hours
   */
  set(key, value, lifetime = this.lifetime) {
    return new Promise((resolve, reject) => { // eslint-disable-line consistent-return
      if (!key || !value) return reject(new Error('key and value are required'));

      /* istanbul ignore next */ // eslint-disable-next-line no-unused-expressions
      this.shouldLog() && logger.debug(`Setting key "${key}" with value "${JSON.stringify(value)}"`);
      this.trace(BaseClient.OPERATIONS_ALLOWED.SET, this.name);

      this.client.set(key, value, lifetime, (err) => { // eslint-disable-line consistent-return
        if (err) {
          /* istanbul ignore next */
          logger.error(`An error occurred setting the key "${key}": ${err.message}`);
          return reject(err);
        }
        resolve(true);
      });
    });
  }

  /**
   * Delete key from cache
   *
   * @param {String} key to find on cache
   */
  delete(key) {
    return new Promise((resolve, reject) => {
      /* istanbul ignore next */ // eslint-disable-next-line no-unused-expressions
      this.shouldLog() && logger.debug(`Deleting key "${key}"`);
      this.trace(BaseClient.OPERATIONS_ALLOWED.DELETE, this.name);

      this.client.del(key, (err) => { // eslint-disable-line consistent-return
        if (err) {
          /* istanbul ignore next */
          logger.error(`An error occurred deleting the key "${key}": ${err.message}`);
          return reject(err);
        }
        resolve(true);
      });
    });
  }

  /**
   * Cleans all the cache
   *
   * @returns {Promise<any>} indicating if the clean was correctly done
   */
  reset() {
    return new Promise((resolve, reject) => {
      this.client.flush((err) => { // eslint-disable-line consistent-return
        if (err) {
          /* istanbul ignore next */ // eslint-disable-next-line no-unused-expressions
          logger.error(`An error occurred flushing the cache: ${err.message}`);
          return reject(err);
        }
        resolve(true);
      });
    });
  }
}

module.exports = MemcachedClient;
