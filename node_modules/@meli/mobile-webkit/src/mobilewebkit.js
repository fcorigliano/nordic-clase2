/**
 *  This SDK is used by frontends to comunicates to native apps.
 *  Web -> Native:
 *    - use method `executeNative(invocationParams)`
 *  Native -> Web:
 *    - add a listener for an event
 */
var NativeMobileWebViewSDK = new function() {
	// "global" this to use internally on functions, etc
	var that = this;
	
	/************************************
	 * [Internal] Constants
	 ************************************/
	
	var SDK_VERSION = __SDK_VERSION__;
	// Time to wait for the native app response
	var CONNECTION_TIMEOUT = 1000;
	// Wait time between retries when connection with native app occurs
	var CONNECTION_RETRY_TIME = 0;
	// Number of retries to
	var CONNECTION_RETRY_COUNT_ON_TIMEOUT = 3;

	// Protocol messages types to be used from JS to Native
	var JS_TO_NATIVE_PROTOCOL_MESSAGES = [
		// used from js to app
		"connect", // used to establish connection with app
		"js_request", // used to request a method execution on app
		"js_multi_request", // used to request multiples methods on app
		"js_execution_result" // used to respond with a result of a frontend execution to app
	];

	// Protocol messages types to be used from Native to JS
	var NATIVE_TO_JS_PROTOCOL_MESSAGES = [
		"native_request", // request execution on web from app
		"native_execution_result", // response with result/error from native app
		"native_multi_execution_result", // response with array of response for each from native app for multi request and an error
		"metadata" // app requires js sdk metadata
	];
	
	/************************************
	 * [Internal] Instance variables
	 ************************************/
	
	var connectedWithApp = false;
	var callbacksGenerator = 1;
	var callbacks = {};
	
	// error codes to be handled by callbacks in frontenders code
	var errorCodes = {
		"no_app_connection_error_code": "connection_code",
		"timeout_error_code": "timeout_code",
		"native_error_code": "native_code",
		"unknown_message_code": "unknown_message"
	};

	// default invocation to use
	var defaultInvocation = {
		"timeout": 0,
		"retries_on_timeout": 0,
		"retry_time_on_timeout": 0,
		"internal_data": {
			"current_retry_on_timeout": 0
		}
	};
	
	/*************************************
	 *
	 *************************************/
	
	/*************************************
	 * [Internal] Make This an EventTarget
	 *************************************/
	
	function Emitter() {
		var eventTarget = document.createDocumentFragment()
		
		var mappings = {
			"addEventListener": "addEventListener",
			"removeEventListener": "removeEventListener",
			"dispatchEvent": "dispatchEvent",

			"on": "addEventListener",
			"off": "removeEventListener",
			"emit": "dispatchEvent"
		};

		function delegate(method) {
			var targetMethod = mappings[method];
			this[method] = eventTarget[targetMethod].bind(eventTarget)
		}
		
		[
		 "addEventListener",
		 "dispatchEvent",
		 "removeEventListener",
		 "on",
		 "off",
		 "emit"
		 ].forEach(delegate, this)
	}
	
	Emitter.call(this);
	
	/************************************
	 * [Internal] Methods
	 ************************************/
	
	// Methods in variable to be used internally and not exposed
	
	var log = function(txt) {
		console.log("SDK js: " + txt);
	}
	
	/**
	 *  [Internal] Assert if a request from JS code to Native code is valid
	 */
	var assertNativeCallInvocation = function(nativeCallInvocation) {
		if (!nativeCallInvocation.method) {
			log("Invalid invocation");
			return false;
		}
		return true;
	};

	/**
	 *  [Internal] Assert multiinvocation from JS code to Native code
	 */
	var assertMultiCallInvocation = function(invocation) {
		if (!invocation || !invocation.args || invocation.args.length <= 0) {
			log("Invalid multi invocation");
			return false;
		}

		var i, len = invocation.args.length;
		for (i = 0; i < len; i ++) {
			var req = invocation.args[i];
			if (!assertNativeCallInvocation(req)) {
				log("Invalid multi invocation");
				return false;
			}
		}

		return true;
	};

	/**
	 *  [Internal] Assert if a protocol message form JS is valid
	 */
	var assertJSToNativeProtocolMessage = function(protocolMessage) {
		var messageType = protocolMessage.message_type;
		if (!messageType || 
			JS_TO_NATIVE_PROTOCOL_MESSAGES.indexOf(messageType) == -1) {
			log("Invalid protocol message");
			return false;
		}

		if (messageType === "js_request" && !protocolMessage.method) {
			log("Invalid protocol message js_request without method");
			return false;
		} else if (messageType === "js_multi_request") {
			var requests = protocolMessage.args;

			var i; len = requests.length;
			for (i = 0; i < len; i++) {
				var req = requests[i];
				if (!req.method) {
					log("Invalid protocol message js_multi_request with some request without method");
					return false;
				}
			}
		}

		return true;
	};

	/**
	 *  [Internal] Assert if a protocol message from app is valid
	 */
	var assertNativeToJSProtocolMessage = function(protocolMessage) {
		var messageType = protocolMessage.message_type;
		if (!messageType || 
			NATIVE_TO_JS_PROTOCOL_MESSAGES.indexOf(messageType) == -1) {
			log("Invalid protocol message");
			return false;
		}

		if (messageType === "native_request" && !protocolMessage.method) {
			log("Invalid protocol message native_request without method");
			return false;
		}

		return true;
	};
	
	/**
	 * [Internal] Assert if a request from native code to JS code is valid
	 */
	var assertNativeToJSCallInvocation = function(invocation) {
		if (!invocation.method) {
			log("Invalid invocation");
			return false;
		}
		return true;
	};

	/**
	 *  [Internal] Asserts app is connected.
	 *
	 * @param callback to use if not connected to responds with error
	 * @param data to add on error body
	 */
	var assertAppConnected = function(callback, data) {
		if (!connectedWithApp) {
			log("not connected with app");
			if (callback) {
				callback(undefined, {
					"code": errorCodes.no_app_connection_error_code,
					"data": data
				});
			}
			return false;
		}
		return true
	};
	
	/**
	 *  [Internal] Cleanup the callback data when a request from JS to App has been made
	 */
	var cleanCallbackData = function(callbackId) {
		var callback = callbacks[callbackId];
		if (callback) {
			delete callbacks[callbackId];
		}
		return callback;
	};
	
	/**
	 *  [Internal] Returns true if exists a callback otherwhise false
	 */
	var existsCallbackData = function(callbackId) {
		var callback = callbacks[callbackId];
		return !!callback;
	}
	
	/**
	 *  [Internal] forward declaration to be used on timeoutHandler and sendMessageToAppWithDefault
	 */
	var sendMessageToApp = null;

	/**
	 *  [Internal] Handle timeouts, removing callbacks data and create a timeout error message
	 *  If 'retries_on_timeout' was set and its value is greater than 0 pospone excecution to callback
	 *  and retries again after 'retry_time_on_timeout'
	 */
	var timeoutHandler = function(message) {
		var invocation = message.invocation;
		var nativeMessage = message.message;
		var callbackId = invocation.internal_data.callback_id;
		
		// if there is no callback then exit
		// This occur on last excecution, the timeout will always execute
		// this line prevents retries innecesary on the next lines
		if (!existsCallbackData(callbackId)) {
			return;
		}
		
		// Check if must retry on timeout
		var retriesOnTimeout = invocation.retries_on_timeout;
		var currentRetryOnTimeout = invocation.internal_data.current_retry_on_timeout;
		if (retriesOnTimeout > 0 && currentRetryOnTimeout < retriesOnTimeout) {
			// increment retry counter
			invocation.internal_data.current_retry_on_timeout = currentRetryOnTimeout + 1;
			setTimeout(sendMessageToApp, invocation.retry_time_on_timeout, invocation);
			
			return;
		}
		
		// callback_id must exists because timeouts always
		// are included when exists callbacks.
		var callback = cleanCallbackData(callbackId);
		if (callback) {
			var timeout = invocation.timeout;
			callback(undefined, {
				"code": errorCodes.timeout_error_code,
				"data": {
					"timeout": timeout,
					"invocation": invocation
				}
			});
		}
	};

	/**
	 *  [Internal] This method decorate the param with default values before pass to "sendMessageToApp"
	 */
	var sendMessageToAppWithDefault = function(nativeCallInvocation) {
		// Use mergeObjects instead of Object.assign becaus en ES5 not exists
		function mergeObjects() {
			var resObj = {};
			for (var i=0; i < arguments.length; i += 1) {
				var obj = arguments[i],
				keys = Object.keys(obj);
				for (var j = 0; j < keys.length; j += 1) {
					resObj[keys[j]] = obj[keys[j]];
				}
			}
			return resObj;
		}

		var defaultCopy = JSON.parse(JSON.stringify(defaultInvocation));
		var invocationWithDefaults = mergeObjects(defaultCopy, nativeCallInvocation);
		sendMessageToApp(invocationWithDefaults);
	};

	/**
	 *  [Internal] This method send the message to native code
	 *  The message is internal so can be mutated without affecting objects from client (fends)
	 *
	 *  Result will be delivered in an async way using callback_success / callback_error field
	 *  An example of invocation is this
	 *		{
	 *			"message_type": "message_type_value", // Required. Valid values are listed on JS_TO_NATIVE_PROTOCOL_MESSAGES.
	 *			"method": "native_method_name", // Required for request with message type "js_request", otherwise is not used. Method to execute on native app
	 *			"args": "native_method_params", // Optional, argument to pass to native app
	 *			"callback": function(result, error) {  // Optional, callback to execute when invocation ends
	 *			},
	 *			"timeout": 50 // Optional, time in millis, default 0;
	 *			"retries_on_timeout": 4 // Optional, number of retries before return with error, default 0. Used in conjunction with 'timeout'.
	 *			"retry_time_on_timeout": 5 // Optional, wait time between retries on timeout in millis, default 0. Used in conjunction with 'timeout' and 'retries_on_timeout'.
	 *
	 *			"internal_data": { // only for internal use, frontenders don't uses it
	 *				"current_retry_on_timeout": 2 // current retry number on timeout, used for internal retries, default 0
	 *				"callback_id": // store callback_id to prevent generation of news callback_id on retries
	 *			}
	 *		}
	 */
	sendMessageToApp = function(nativeCallInvocation) {
		// assertions
		if (!assertJSToNativeProtocolMessage(nativeCallInvocation)) {
			return;
		}
		
		var messageType = nativeCallInvocation.message_type;
		var callback = nativeCallInvocation.callback;
		
		// check if connection with app exists, otherwise callback with error
		// the assertion is duplicated here to be validate on retries
		if ((messageType === "js_request" || messageType === "js_multi_request") && 
			!assertAppConnected(callback, nativeCallInvocation)) {

			return;
		}
											  
		// extract fields values
		var method = nativeCallInvocation.method;
		var args = nativeCallInvocation.args;
		var timeout = nativeCallInvocation.timeout;
		
		// build message to forward to app
		// Message has a form of this
		// {
		//		"message_type": "protocol_message_value", // debe ser un valor del array JS_TO_NATIVE_PROTOCOL_MESSAGES 
		// 		"method": "methodName", <- por las dudas se manda el metodo si existe
		// 		"args": ...js obj..., <- argumentos del metodos
		//		"callback_msg": ...., <- msg to be forwarded from native app, is used to call callbacks on frontend
		// }
		var message = {
			"message_type": messageType
		};
		
		if (method !== undefined) {
			message.method = method;
		}

		if (args !== undefined) {
			message.args = args;
		}
		
		// save callback to receive results
		// adjust timeout to receive errors in callback
		if (callback) {
			// save callback if not was registered
			var callbackId = nativeCallInvocation.internal_data.callback_id;
			if (!callbackId) {
				callbacksGenerator = callbacksGenerator + 1;
				callbackId = "" + callbacksGenerator;
				callbacks[callbackId] = callback;
				nativeCallInvocation.internal_data.callback_id = callbackId;
			}
			
			message.callback_msg = callbackId;
			
			// adjust timeout and pass all info to timeout
			if (timeout > 0) {
				setTimeout(timeoutHandler, timeout, {
					"invocation": nativeCallInvocation,
					"message": message
				});
			}
		}
		
		// TODO: improve validation using userAgent or other info
		// Check Android channel or UIWebView channel
		var serializedMessage = JSON.stringify(message);
		log("js -> native: send message -> " + serializedMessage);
		if (typeof WebviewSDKCommunicationChannel !== 'undefined') {
			WebviewSDKCommunicationChannel.executeNative(serializedMessage);

		// Check iOS WKWebView channel
		} else if (window.webkit &&
				   window.webkit.messageHandlers &&
				   window.webkit.messageHandlers.webviewSDKCommunicationChannel) {
			window.webkit.messageHandlers.webviewSDKCommunicationChannel.postMessage(serializedMessage);
		} else {
			log("No connection to app");
		}
	};
	
	/************************************
	 * Exposed Methods
	 ************************************/

	/**
	 *  Use this method to call native's ones
	 *  Result will be delivered in an async way using callback_success / callback_error field
	 *  An example of invocation is this
	 *		{
	 *			"method": "native_method_name", // Required, Method to execute on native app
	 *			"args": "native_method_params", // Optional, argument to pass to native app
	 *			"callback": function(result, error) {  // Optional, callback to execute when invocation ends
	 *			},
	 *			"timeout": 50 // Optional, time in millis, default 0;
	 *			"retries_on_timeout": 4 // Optional, number of retries before return with error, default 0. Used in conjunction with 'timeout'.
	 *			"retry_time_on_timeout": 5 // Optional, wait time between retries on timeout in millis, default 0. Used in conjunction with 'timeout' and 'retries_on_timeout'.
	 *		}
	 *
	 *  Internal implementation build a protocol message with type 'request' indicating that is a request from frontend.
	 */
	this.executeNative = function(nativeCallInvocation) {
		// assertions
		if (!assertNativeCallInvocation(nativeCallInvocation)) {
			return;
		}
		
		var method = nativeCallInvocation.method;
		var callback = nativeCallInvocation.callback;
		
		// check if connection with app exists, otherwise callback with error
		if (!assertAppConnected(callback, nativeCallInvocation)) {
			return;
		}

		// clone client request to prevent modifications and add callback function if exists
		var message = JSON.parse(JSON.stringify(nativeCallInvocation));
		if (callback) {
			message.callback = callback;
		}
										  
		// set protocol message type
		message.message_type = "js_request";

		// send to app
		sendMessageToAppWithDefault(message);
	};

	/**
	 *  This method execute multiples invocations on native code.
	 *  
	 *  The schema for the message is this
	 *		{
	 *			"args": [
	 *				{
	 *					"method": "native_method_name", // Required, Method to execute on native app
	 *					"args": "native_method_params", // Optional, argument to pass to native app
	 *				}
	 *			],
	 *			"callback": function(responses, error) {  // Optional, callback to execute when invocation ends, responses are array of object {result:...., error:...}
	 *			},
	 *			"timeout": 50 // Optional, time in millis, default 0;
	 *			"retries_on_timeout": 4 // Optional, number of retries before return with error, default 0. Used in conjunction with 'timeout'.
	 *			"retry_time_on_timeout": 5 // Optional, wait time between retries on timeout in millis, default 0. Used in conjunction with 'timeout' and 'retries_on_timeout'.
	 *		}
	 *
	 */
	this.multiExecuteNative = function(multiInvocation) {
		if (!assertMultiCallInvocation(multiInvocation)) {
			return;
		}
		
		var callback = multiInvocation.callback;
		
		// check if connection with app exists, otherwise callback with error
		if (!assertAppConnected(callback, multiInvocation)) {
			return;
		}

		// clone client request to prevent modifications and add callback function if exists
		var message = JSON.parse(JSON.stringify(multiInvocation));
		if (callback) {
			message.callback = callback;
		}
										  
		// set protocol message type
		message.message_type = "js_multi_request";

		// send to app
		sendMessageToAppWithDefault(message);
	};
	
	/**
	 *  [Internal] Receive message from native app
	 *  Only for internal use, frontends must not use this method.
	 *  It is exposed because native call executes it
	 *  
	 *  @param message the message from native app
	 *
	 *  Should be the form of
	 *  {
	 *		"message_type": "....", // Required, some value of NATIVE_TO_JS_PROTOCOL_MESSAGES
	 *		"method": "", // Required only when messaget_type is native_request
	 *		"args": ....json object ..., // Optional
	 *		"callback_msg": ...  // Required, used to respond to app for native_request or when arrive a response from app
	 *							so we can find which callback to execute from frontend
	 *  }
	 */
	this.receiveMessageFromApp = function(message) {
		log("native -> js: receive message -> " + JSON.stringify(message));
		if (!assertNativeToJSProtocolMessage(message)) {
			return;
		}
		
		var messageType = message.message_type;
		
		if (messageType === "metadata") {
			sendMessageToAppWithDefault({
				"message_type": "js_execution_result",
				"args": {
					"callback_msg": message.callback_msg,
					"result": {
						"sdk_version": SDK_VERSION
					}
				}
			});
		} else if (messageType === "native_request") {
			var event = document.createEvent('Event');
			event.initEvent("native_request", false, false);
			event.method = message.method;
			event.args = message.args;
			event.callback = function(response) {
				// TODO: podemos evitar mandar mensaje a la app si no hay callback_msg.
				// 		 agregar el if
				sendMessageToAppWithDefault({
					"message_type": "js_execution_result",
					"args": {
						"callback_msg": message.callback_msg,
						"result": response.result,
						"error": response.error
					}
				});
			};
			
			that.dispatchEvent(event);
		} else if (messageType === "native_execution_result") {
			var callbackId = message.callback_msg;

			// cleanup memory for callbacks
			var callback = cleanCallbackData(callbackId);
			if (callback) {
				var resultContent = undefined;
				var errorContent = undefined;
				
				// resultMsg mustbe undefined or be an object
				var resultMsg = message.args;
				if (resultMsg) {
					// result value might be any value
					resultContent = resultMsg.result
					
					if (resultMsg.error) {
						errorContent = {
							"code": errorCodes.native_error_code,
							"data": resultMsg.error
						};
					}
				}
				
				callback(resultContent, errorContent);
			}
		} else if (messageType === "native_multi_execution_result") {
			var callbackId = message.callback_msg;

			// cleanup memory for callbacks
			var callback = cleanCallbackData(callbackId);
			if (callback) {
				var resultContent = undefined;
				var errorContent = undefined;
				
				// resultMsg mustbe undefined or be an object
				var resultMsg = message.args;
				if (resultMsg) {
					// result value is an array of responses, one for each request
					resultContent = resultMsg.result
					if (resultContent) {

						// set each error with a schema {code:.., data:..}
						var i, len = resultContent.length;
						for (i = 0; i < len; i++) {
							var resp = resultContent[i];
							if (resp.error) {
								resp.error = {
									"code": errorCodes.native_error_code,
									"data": resp.error
								};
							}
						}
					}
					
					if (resultMsg.error) {
						errorContent = {
							"code": errorCodes.native_error_code,
							"data": resultMsg.error
						};
					}
				}
				
				callback(resultContent, errorContent);
			}
		} else {
			sendMessageToAppWithDefault({
				"message_type": "js_execution_result",
				"args": {
					"callback_msg": callbackMsg,
					"error": {
						"code": errorCodes.unknown_message_code,
						"data": message
					}
				}
			});
		}
	}
	
	/**
	 *  Connect to native app
	 *  The handshake will pass the info needed by native component
	 *  to initiate functions calls for its side
	 */
	this.connect = function() {
		log("connecting to native");
		sendMessageToAppWithDefault({
			"message_type": "connect",
			"args": {
				"js_invocation": {
					"call_script": "window.MobileWebKit.receiveMessageFromApp($___message___$)",
					"call_placeholder": "$___message___$"
				}
			},
			"callback": function(result, error) {
				if (error) {
					log(error);
					return;
				}

				connectedWithApp = true;
				log("connected with app");
						   
				var event = document.createEvent('Event');
				event.initEvent('connect', false, false);
				event.data = result;
				that.dispatchEvent(event);
			},
			"timeout": CONNECTION_TIMEOUT,
			"retries_on_timeout": CONNECTION_RETRY_COUNT_ON_TIMEOUT,
			"retry_time_on_timeout": CONNECTION_RETRY_TIME
		});
	};

	/**
	 *  Return current connection status
	 *  @returns true if conntected, false otherwise
	 */
	this.isConnected = function() {
		return connectedWithApp;
	};
											  
	// start handshake as soon as posible
	setTimeout(this.connect, 0);
};

module.exports = NativeMobileWebViewSDK;