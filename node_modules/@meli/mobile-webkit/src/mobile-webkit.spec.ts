import { NativeChannel } from "./channel/native-channel";
import { DefaultConfig } from "./config/default-config";
import { MobileWebkit } from "./mobile-webkit";
import { buildRequestInfo, FromNativeMessageType, MessageFromNative, MultipleRequest, ProtocolValidator, Request, RequestInfo, ToNativeMessageType } from "./models";
import { Logger } from "./utils";

describe("MobileWebkit", () => {

    let channel: NativeChannel;
    let validator: ProtocolValidator;
    let mobileWebKit: MobileWebkit;

    beforeEach(() => {
        (window as any).__SDK_VERSION__ = 1;
        channel = {
            sendMessageToApp: () => { },
            isAppConnected: () => { },
            receiveMessageFromApp: () => { }
        } as any;

        validator = new ProtocolValidator(new Logger());

        mobileWebKit = new MobileWebkit();
        mobileWebKit["channel"] = channel;
        mobileWebKit["validator"] = validator;
    });

    describe("connect", () => {
        it("should send message to app with a request info", () => {
            // Given
            const sendMessageToAppSpy = jest.spyOn(channel, "sendMessageToApp");
            const req: Request = {
                args: {
                    js_invocation: {
                        call_script: mobileWebKit.CALL_SCRIPT,
                        call_placeholder: mobileWebKit.CALL_PLACEHOLDER
                    }
                }
            };
            const reqInfo = buildRequestInfo(ToNativeMessageType.Connect, req, DefaultConfig.connect);

            // When
            mobileWebKit.connect();

            // Then
            const requestSent = sendMessageToAppSpy.mock.calls[0][0];
            delete requestSent.callback;
            expect(requestSent).toEqual(reqInfo);

        });
    });

    describe("executeNative", () => {
        it("should do nothing if request has not a method", () => {
            // Given
            const request = {} as Request;
            const sendMessageToAppSpy = jest.spyOn(channel, "sendMessageToApp");

            // When
            mobileWebKit.executeNative(request);

            // Then
            expect(sendMessageToAppSpy).not.toHaveBeenCalled();

        });
        it("should do nothing if app is not connected", () => {
            /// Given
            const request = { method: "test method" } as any;
            mobileWebKit.isConnected = () => false;
            const sendMessageToAppSpy = jest.spyOn(channel, "sendMessageToApp");

            // When
            mobileWebKit.executeNative(request);

            // Then
            expect(sendMessageToAppSpy).not.toHaveBeenCalled();
        });
        it("should send message to app with a request info", () => {
            /// Given
            const request = { method: "test method", args: {} };
            const requestInfo = buildRequestInfo(ToNativeMessageType.JSRequest, request, DefaultConfig.request);

            channel.isAppConnected = () => true;
            const sendMessageToAppSpy = jest.spyOn(channel, "sendMessageToApp");

            // When
            mobileWebKit.executeNative(request);

            // Then
            const requestSent = sendMessageToAppSpy.mock.calls[0][0];
            delete requestSent.callback;
            expect(requestSent).toEqual(requestInfo);
        });
    });

    describe("multiExecuteNative", () => {
        it("should do nothing if request is not valid", () => {
            // Given
            const request = {} as MultipleRequest;
            const sendMessageToAppSpy = jest.spyOn(channel, "sendMessageToApp");

            // When
            mobileWebKit.multiExecuteNative(request);

            // Then
            expect(sendMessageToAppSpy).not.toHaveBeenCalled();

        });
        it("should do nothing if app is not connected", () => {
            /// Given
            const request: any = {
                args: [
                    { method: "test method" }
                ]
            };
            channel.isAppConnected = () => false;
            const sendMessageToAppSpy = jest.spyOn(channel, "sendMessageToApp");

            // When
            mobileWebKit.multiExecuteNative(request);

            // Then
            expect(sendMessageToAppSpy).not.toHaveBeenCalled();

        });
        it("should send message to app with a request info", () => {
            /// Given
            const request: any = {
                args: [
                    { method: "test method", args: {} }
                ]
            };
            const requestInfo = buildRequestInfo(ToNativeMessageType.JSMultiRequest, request, DefaultConfig.request);

            channel.isAppConnected = () => true;
            const sendMessageToAppSpy = jest.spyOn(channel, "sendMessageToApp");

            // When
            mobileWebKit.multiExecuteNative(request);

            // Then
            const requestSent = sendMessageToAppSpy.mock.calls[0][0];
            delete requestSent.callback;
            expect(requestSent).toEqual(requestInfo);
        });
    });

    describe("receiveMessageFromApp", () => {
        it("should do nothing if message is not valid", () => {
            // Given
            const message: any = {
                message_type: "invalid type"
            };
            const receiveMessageFromAppSpy = jest.spyOn(channel, "receiveMessageFromApp");

            // When
            mobileWebKit.receiveMessageFromApp(message);

            // Then
            expect(receiveMessageFromAppSpy).not.toHaveBeenCalled();

        });
        it("should send message to channel", () => {
            // Given
            const message: any = {
                message_type: FromNativeMessageType.NativeRequest,
                method:"test method"
            };
            const receiveMessageFromAppSpy = jest.spyOn(channel, "receiveMessageFromApp");

            // When
            mobileWebKit.receiveMessageFromApp(message);

            // Then
            expect(receiveMessageFromAppSpy).toHaveBeenCalledWith(message);
        });
    });
});