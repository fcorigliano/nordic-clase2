import { Callback, CallbackContainer, TimeoutHandler } from ".";
import { ErrorCodes, RequestInfo } from "../models";

describe("TimeoutHandler", () => {
    let callbackContainer: CallbackContainer;
    let retry: (requestInfo: RequestInfo) => void;
    let timeoutHandler: TimeoutHandler;

    beforeEach(() => {
        callbackContainer = new CallbackContainer();
        retry = jest.fn();
        timeoutHandler = new TimeoutHandler(callbackContainer, retry);
    });

    describe("run", () => {
        it("should do nothing if timeout is zero", () => {
            // Given
            const handleTimeoutSpy = jest.fn();
            timeoutHandler["handleTimeout"] = handleTimeoutSpy;
            const req = givenRequestInfo({ timeout: 0 });

            // When
            timeoutHandler.run(req);
             
            return delay(100).then(()=>{
                // Then
                expect(handleTimeoutSpy).not.toBeCalled();
            });
        });
        it("should do nothing if not exists callback", () => {
            // Given
            const getAndRemoveSpy = jest.spyOn(callbackContainer, "getAndRemove");
            const req = givenRequestInfo({
                internal_data: {
                    callback_id: 1,
                    current_retry_on_timeout: 0
                },
                timeout: 20
            })

            // When
            timeoutHandler.run(req);
            return delay(100).then(()=>{
                // Then
                expect(getAndRemoveSpy).not.toBeCalled();
            });
        });

        it("should retry if retries account is bigger than zero", () => {
            // Given
            const callback: Callback = () => { }
            const callbackId = callbackContainer.add(callback);
            const req = givenRequestInfo({
                internal_data: {
                    callback_id: callbackId,
                    current_retry_on_timeout: 0
                },
                retries_on_timeout: 1,
                retry_time_on_timeout: 5,
                timeout: 10
            });

            // When
            timeoutHandler.run(req);
            return delay(100).then(()=>{
                // Then
                expect(retry).toBeCalled();
            });
        });

        it("should call the callback with a timeout error", () => {
            // Given
            const callback: Callback = jest.fn();
            const callbackId = callbackContainer.add(callback);
            const req = givenRequestInfo({
                timeout: 10,
                internal_data: {
                    callback_id: callbackId,
                    current_retry_on_timeout: 0
                },
                retries_on_timeout: 0
            });

            // When
            timeoutHandler.run(req);
            return delay(100).then(()=>{
                // Then
                // Then
            expect(callback).toBeCalledWith(undefined, {
                code: ErrorCodes.Timeout,
                data: {
                    timeout: req.timeout,
                    invocation: req
                }
            })
            });
            
        });
    });


});

function givenRequestInfo(data: Partial<RequestInfo>): RequestInfo {
    return data as any;
}

function delay(ms: number) {
    return new Promise(resolve => setTimeout(resolve, ms));
}