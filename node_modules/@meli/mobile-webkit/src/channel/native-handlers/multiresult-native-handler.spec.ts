import { ErrorCodes, FromNativeMessageType, MessageFromNative, MessageToNative, NativeResult } from "../../models";
import { Callback, CallbackContainer } from "../../utils";
import { MultiResultNativeHandler } from "./multiresult-native-handler";

describe("MultiResultNativeHandler", () => {

    let callbackContainer: CallbackContainer;
    let multiResultHandler: MultiResultNativeHandler;

    beforeEach(() => {
        callbackContainer = new CallbackContainer();
        multiResultHandler = new MultiResultNativeHandler(callbackContainer);
    });

    it("should do nothing if result has not arguments", () => {
        // Given
        const callback: Callback = jest.fn();
        const callbackId = callbackContainer.add(callback);
        const message = givenMessageFromNative(callbackId, null);

        // When
        multiResultHandler.handleMessage(message);

        // Then
        expect(callback).not.toBeCalled();

    });
    it("should call callback with a result and error", () => {
        // Given
        const callback: Callback = jest.fn();
        const callbackId = callbackContainer.add(callback);
        const message = givenMessageFromNative(callbackId, {
            result: [
                {
                    result: 1,
                    error: "error"
                }
            ],
            error: "error"
        });

        // When
        multiResultHandler.handleMessage(message);

        // Then
        expect(callback).toBeCalledWith([
            {
                result: 1, error: {
                    code: ErrorCodes.Native,
                    data: "error"
                }
            }
        ], {
            code: ErrorCodes.Native,
            data: "error"
        });

    });
});

function givenMessageFromNative(callbackId: number = 1, args: NativeResult = {}): MessageFromNative {
    return {
        args,
        callback_msg: callbackId,
        message_type: FromNativeMessageType.NativeMultiExecutionResult,
        method: "test method"
    };
}