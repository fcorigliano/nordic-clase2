import { EventEmitter } from "../events/event-emitter";
import {
    ErrorCodes, FromNativeMessageType, MessageFromNative, MessageToNative, RequestInfo, requestToMessage, ToNativeMessageType
} from "../models";
import { PlatformFactory } from "../platforms/platform-factory";
import { Callback, CallbackContainer, Logger, TimeoutHandler, findItem } from "../utils";
import { MetadataNativeHandler } from "./native-handlers/metadata-native-handler";
import { MultiResultNativeHandler } from "./native-handlers/multiresult-native-handler";
import { NativeHandler } from "./native-handlers/native-handler";
import { RequestNativeHandler } from "./native-handlers/request-native-handler";
import { ResultNativeHandler } from "./native-handlers/result-native-handler";

export class NativeChannel {

    isConnected = false
    private timeoutHandler = new TimeoutHandler(this.callbackContainer, (requestInfo) => this.sendMessageToApp(requestInfo));
    private nativeHandlers: NativeHandler[] = [
        new MetadataNativeHandler(this),
        new RequestNativeHandler(this.eventEmitter, this),
        new ResultNativeHandler(this.callbackContainer),
        new MultiResultNativeHandler(this.callbackContainer)
    ];

    constructor(
        private logger: Logger,
        private callbackContainer: CallbackContainer,
        private eventEmitter: EventEmitter,
        private platformFactory: PlatformFactory = new PlatformFactory(logger)) { }

    isAppConnected(callback?: Callback, errorData?: any): boolean {
        if (this.isConnected) {
            return true;
        }
        this.logger.log("not connected with app");
        if (callback) {
            callback(undefined, {
                code: ErrorCodes.NoAppConnection,
                data: errorData
            });
        }
        return false;
    }

    sendMessageToApp(requestInfo: RequestInfo) {
        const messageType = requestInfo.message_type;
        if ((messageType == ToNativeMessageType.JSRequest || messageType == ToNativeMessageType.JSMultiRequest)
            && !this.isAppConnected(requestInfo.callback, requestInfo)) {
            return;
        }

        const message = requestToMessage(requestInfo);
        this.prepareCallback(requestInfo, message);

        const serializedMessage = JSON.stringify(message);
        this.logger.log("js -> native: send message -> " + serializedMessage);
        this.platformFactory.getPlaform()?.sendMessage(serializedMessage);
    }

    private prepareCallback(requestInfo: RequestInfo, message: MessageToNative) {
        if (!requestInfo.callback) {
            return
        }

        let callbackId = requestInfo.internal_data.callback_id;
        if (!callbackId) {
            callbackId = this.callbackContainer.add(requestInfo.callback);
            requestInfo.internal_data.callback_id = callbackId;
        }
        message.callback_msg = callbackId;
        this.timeoutHandler.run(requestInfo);
    }

    receiveMessageFromApp(message: MessageFromNative) {
        const messageType: FromNativeMessageType = message.message_type;
        const nativeHandler = findItem(this.nativeHandlers, handler => handler.messageType == messageType);
        if (nativeHandler) {
            nativeHandler.handleMessage(message);
        } else {
            this.sendMessageToApp({
                message_type: ToNativeMessageType.JSExecutionResult,
                args: {
                    callback_msg: message.callback_msg,
                    error: {
                        code: ErrorCodes.UnknownMessage,
                        data: message
                    }
                }
            });
        }
    }

}