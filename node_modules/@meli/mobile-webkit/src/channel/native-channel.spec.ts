import { EventEmitter } from "../events/event-emitter";
import { ErrorCodes, FromNativeMessageType, MessageFromNative, RequestInfo, requestToMessage, ToNativeMessageType } from "../models";
import { Platform } from "../platforms/platform";
import { PlatformFactory } from "../platforms/platform-factory";
import { CallbackContainer, Logger, TimeoutHandler } from "../utils";
import { NativeChannel } from "./native-channel";
import { NativeHandler } from "./native-handlers/native-handler";

describe("NativeChannel", () => {

    let nativeChannel: NativeChannel;
    let callbackContainer: CallbackContainer;
    let eventEmitter: EventEmitter;
    let platform: Platform;
    let timeoutHandler: TimeoutHandler;

    beforeEach(() => {
        (window as any).__SDK_VERSION__ = 1;
        platform = { isAvailable: () => true, sendMessage: () => { } };
        const platformFactory: PlatformFactory = {
            getPlaform: () => platform
        } as PlatformFactory

        eventEmitter = {dispatchEvent: jest.fn()} as any;
        callbackContainer = new CallbackContainer();
        timeoutHandler = {run:()=>{}} as any;

        nativeChannel = new NativeChannel(new Logger(), callbackContainer, eventEmitter, platformFactory);
        nativeChannel["timeoutHandler"] = timeoutHandler;
    });

    describe("isAppConnected", () => {
        it("should return true if isConnected is true", () => {
            // Given
            nativeChannel.isConnected = true;

            // When 
            const result = nativeChannel.isAppConnected();

            // Then
            expect(result).toBeTruthy();

        });
        it("should call the callback with a error NoAppconnected if isConnected is false", () => {
            // Given
            const errorData = "error test";
            const callback = jest.fn();

            nativeChannel.isConnected = false;

            // When
            nativeChannel.isAppConnected(callback, errorData);

            // Then
            expect(callback).toBeCalledWith(undefined, {
                code: ErrorCodes.NoAppConnection,
                data: errorData
            });

        });
        it("should return false if isConnected is false", () => {
            // Given
            nativeChannel.isConnected = false;

            // When 
            const result = nativeChannel.isAppConnected();

            // Then
            expect(result).toBeFalsy();

        });
    });
    describe("sendMessageToApp", () => {
        it("should do nothing if app is not connected", () => {
            // Given
            const prepareCallbackSpy = jest.fn();
            const request = givenRequestInfo();
            nativeChannel.isConnected = false;
            nativeChannel["prepareCallback"] = prepareCallbackSpy;

            // When
            nativeChannel.sendMessageToApp(request);

            // Then
            expect(prepareCallbackSpy).not.toBeCalled();

        });
        it("should add callback if is not null", () => {
            // Given
            const runSpy = jest.spyOn(timeoutHandler, "run");
            const request = givenRequestInfo({
                callback: () => { }
            });
            nativeChannel.isConnected = true;

            // When
            nativeChannel.sendMessageToApp(request);

            // Then
            const requestInfo = runSpy.mock.calls[0][0];
            expect(requestInfo.internal_data.callback_id).toEqual(1);
            expect(callbackContainer["callbacks"].size).toEqual(1);


        });
        it("should not add callback if has a internal id", () => {
            // Given
            const request = givenRequestInfo({
                callback: () => { },
                internal_data: {
                    callback_id: 3,
                    current_retry_on_timeout: 0
                }
            });
            nativeChannel.isConnected = true;

            // When
            nativeChannel.sendMessageToApp(request);

            // Then
            expect(callbackContainer["callbacks"].size).toEqual(0);

        });
        it("should not add callback if is null", () => {
            const request = givenRequestInfo();
            nativeChannel.isConnected = true;

            // When
            nativeChannel.sendMessageToApp(request);

            // Then
            expect(callbackContainer["callbacks"].size).toEqual(0);

        });
        it("should send message to platform if app is connected", () => {
            // Given
            const sendMessageSpy = jest.spyOn(platform, "sendMessage");
            const request = givenRequestInfo({
                args: 123,
                method: "test method",
                callback: () => { },
                internal_data: {
                    callback_id: 12,
                    current_retry_on_timeout: 0
                }
            });
            nativeChannel.isConnected = true;

            const message = requestToMessage(request);
            const serialized = JSON.stringify(message);

            // When
            nativeChannel.sendMessageToApp(request);

            // Then
            expect(sendMessageSpy).toBeCalledWith(serialized);
        });
    });
    describe("recieveMessageFromApp", () => {
        it("should send a error messate to app if there not a native handler", () => {
            // Given
            nativeChannel["nativeHandlers"] = [];
            const message: MessageFromNative = {
                message_type: FromNativeMessageType.NativeRequest,
                args: 123,
                method: "method test",
                callback_msg: 1
            };
            const sendMessageToAppSpy = jest.spyOn(nativeChannel, "sendMessageToApp");

            // When
            nativeChannel.receiveMessageFromApp(message);

            // Then
            expect(sendMessageToAppSpy).toBeCalledWith({
                message_type: ToNativeMessageType.JSExecutionResult,
                args: {
                    callback_msg: message.callback_msg,
                    error: {
                        code: ErrorCodes.UnknownMessage,
                        data: message
                    }
                }
            });

        });
        it("should handle message with a nativeHandler", () => {
            // Given
            const handler: NativeHandler = { messageType: FromNativeMessageType.NativeRequest, handleMessage: jest.fn() };
            nativeChannel["nativeHandlers"] = [handler];
            const message: MessageFromNative = {
                message_type: FromNativeMessageType.NativeRequest,
                args: 123,
                method: "method test",
                callback_msg: 1
            };

            // When
            nativeChannel.receiveMessageFromApp(message);

            // Then
            expect(handler.handleMessage).toBeCalledWith(message);

        });
    })
});

function givenRequestInfo(data: Partial<RequestInfo> = {}): RequestInfo {
    return {
        message_type : ToNativeMessageType.JSRequest,
        internal_data: {} as any,
        ...data
    } as RequestInfo;
}
