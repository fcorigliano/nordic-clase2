import { MobileWebkit } from "../../../mobile-webkit";
import { ActionCommands } from "./../actions_commands";
import { ErrorCodes, ErrorMessage } from "../../../models";
import { DownloadImageOptions } from "./../download_image_options";
import { PickImageOptions } from "../pick_image_options";
import { UnavailableArgs } from "../../utils/command-backsupport";
import { BacksupportCallback } from "../../utils/command-backsupport";
import { ShareImageOptions } from "./../share_image_options";
import { ActionCommandsLegacy } from "./actions_commands_legacy";

describe.only("ActionsCommandsLegacy", () => {

    let executeNativeSpy: jest.Mock<any, any>;
    let mobileWebKit: MobileWebkit;
    let commands: ActionCommands;

    beforeEach(() => {
        executeNativeSpy = jest.fn();
        mobileWebKit = {
            executeNative: executeNativeSpy
        } as any;
        commands = new ActionCommandsLegacy(mobileWebKit);
    })

    describe("shareImage", () => {
        it("shareImage should call executeNative with method share_image", () => {
            // Given 
            const args: ShareImageOptions = {
                path: "/path",
                params: {}
            };

            // When
            commands.shareImage(args);

            // Then
            expect(executeNativeSpy).toHaveBeenCalledWith({
                method: "share_image",
                args
            });
        });
    });

    describe("downloadImage", () => {
        it("downloadImage should call executeNative with method download_image", () => {
            // Given 
            const args: DownloadImageOptions = {
                path: "/path",
                method: "GET"
            };

            // When
            commands.downloadImage(args);

            // Then
            expect(executeNativeSpy).toHaveBeenCalledWith({
                method: "download_image",
                args
            });
        });
    });

    describe.only("pickImage", () => {

        const returnValue = "Success";
        let backsupportCallback: BacksupportCallback;

        beforeEach(() => {
            executeNativeSpy.mockResolvedValue(returnValue);
            backsupportCallback = jest.fn();
        });

        it("should call executeNative with method pick_image with updated args", () => {
            // Given 
            const args: PickImageOptions = {
                is_base64: true,
                max_size: 1000,
                mime_types: ["jpg"]
            };

            // When
            commands.pickImage(args);

            // Then
            expect(executeNativeSpy).toHaveBeenCalledWith({
                method: "pick_image",
                args: {
                    isBase64: true,
                    maxSize: 1000,
                    mimeTypes: ["jpg"]
                }
            });
        });

        it("pickImage should return an error if backSupportCallback is not set", () => {
            // Given 
            const args: PickImageOptions = {};

            // When
            return commands.pickImage(args).catch(error => {
                // Then
                const expectedUnavailable: UnavailableArgs = [];
                const expectedError: ErrorMessage = {
                    code: ErrorCodes.UnavailableCommand,
                    data: {
                        command: "pick_image",
                        unavailableArgs: expectedUnavailable
                    }
                };
                expect(error).toEqual(expectedError);
            });
        });
    });

    describe("shareImage", () => {
        it("share should call executeNative with method share", () => {
            // Given 
            const title = "Test title";
            const data = "test data";

            // When
            commands.share(title, data);
            // Then
            expect(executeNativeSpy).toHaveBeenCalledWith({
                method: "share",
                args: {
                    title,
                    data
                }
            });
        });
    });
});