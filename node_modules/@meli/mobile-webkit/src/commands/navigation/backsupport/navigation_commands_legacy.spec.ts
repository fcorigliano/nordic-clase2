import { NavigationCommandsLegacy } from "./navigation_commands_legacy";
import { MobileWebkit } from "../../../mobile-webkit";
import { PushOptions } from "./../push_options";
import { ErrorCodes, ErrorMessage } from "../../../models";
import { BacksupportCallback } from "../../utils/command-backsupport"

describe("NavigationCommandsLegacy", () => {

    let executeNativeSpy: jest.Mock<any, any>;
    let mobileWebKit: MobileWebkit;
    let navigationCommands: NavigationCommandsLegacy;

    beforeEach(() => {
        executeNativeSpy = jest.fn();
        mobileWebKit = {
            executeNative: executeNativeSpy
        } as any;
        navigationCommands = new NavigationCommandsLegacy(mobileWebKit);
    });

    it("reload should not call executeNative and return an error", () => {
        // Given
        const error: ErrorMessage = {
            code: ErrorCodes.UnavailableCommand,
            data: {
                command: "reload",
                unavailableArgs: [],
            }
        };

        //When
        const promise = navigationCommands.reload();

        //Then
        expect(executeNativeSpy).not.toHaveBeenCalled();
        return promise.catch(value => expect(value).toEqual(error));
    })

    it("reload should not call executeNative and return success if callback exists", () => {
        // Given
        const error: ErrorMessage = {
            code: ErrorCodes.UnavailableCommand,
            data: {
                command: "reload",
                unavailableArgs: [],
            }
        };
        const callBackSpy = jest.fn();

        //When
        const promise = navigationCommands.reload().then(callBackSpy());

        //Then
        expect(executeNativeSpy).not.toHaveBeenCalled();
        expect(callBackSpy).toHaveBeenCalled();
        return promise.catch(value => expect(value).toEqual(error));
    })

    it("push should call executeNative with method open_internal_deeplink", () => {

        // Given
        const returnValue = "Success";
        let backsupportCallback: BacksupportCallback;
        executeNativeSpy.mockResolvedValue(returnValue);
        backsupportCallback = jest.fn();
        const deeplink = "test deeplink";
        const args: PushOptions = {
            screens_group: "test",
            replace: false,
            transition: "present"
        }

        // When
        navigationCommands.push(deeplink, args, backsupportCallback);

        // Then
        expect(executeNativeSpy).toHaveBeenCalledWith({
            method: "open_internal_deeplink",
            args: {
                deeplink,
                replace: false,
            }
        });
    });

    it("pop should call executeNative with method close on default", () => {
        // Given
        const args = {
            screens: 3
        }

        // When
        navigationCommands.pop(args);

        // Then
        expect(executeNativeSpy).toHaveBeenCalledWith({
            method: "close",
            args
        });
    });

    it("pop should call executeNative with method back on isHistoryEnabled true", () => {
        // Given
        const args = {
            screens: 3,
            isHistoryEnabled: true,
        }

        // When
        navigationCommands.pop(args);

        // Then
        expect(executeNativeSpy).toHaveBeenCalledWith({
            method: "back",
            args
        });
    });

    it("openForResult should not call executeNative and return an error", () => {

        // Given
        const deeplink = "test deeplink";
        const requestCode = 1;
        const error: ErrorMessage = {
            code: ErrorCodes.UnavailableCommand,
            data: {
                command: "open_for_result",
                unavailableArgs: [],
            }
        };

        // When
        const promise = navigationCommands.openForResult(deeplink, requestCode);

        // Then
        expect(executeNativeSpy).not.toHaveBeenCalled();
        return promise.catch(value => expect(value).toEqual(error));
    })

    it("closeScreenGroup should not call executeNative and return an error", () => {
        // Given
        const args = {
            result: 123
        };
        const error: ErrorMessage = {
            code: ErrorCodes.UnavailableCommand,
            data: {
                command: "close_screen_group",
                unavailableArgs: [],
            }
        };

        // When
        const promise =  navigationCommands.closeScreenGroup(args);

        // Then
        expect(executeNativeSpy).not.toHaveBeenCalled();
        return promise.catch(value => expect(value).toEqual(error));
    });


    it("canOpenDeeplink should call executeNative with method can_open_deeplink", () => {
        // Given
        const args = {
            only_current_app: true
        };
        const deeplink = "test deeplink";
        // When
        navigationCommands.canOpenDeeplink(deeplink, args);

        // Then
        expect(executeNativeSpy).toHaveBeenCalledWith({
            method: "can_open_deeplink",
            args: {
                deeplink,
                ...args
            }
        });
    });

    it("openLinkInAppBrowser should call executeNative with method open_in_app_browser", () => {
        // Given
        const args = {
            show_title: true
        };
        const url = "test url";
        // When
        navigationCommands.openLinkInAppBrowser(url, args);

        // Then
        expect(executeNativeSpy).toHaveBeenCalledWith({
            method: "open_url",
            args: {
                url,
                ...args
            }
        });
    });

    it("openLinkOutsideApp should call executeNative with method open_external_url", () => {
        // Given
        const url = "test url";

        // When
        navigationCommands.openLinkOutsideApp(url);

        // Then
        expect(executeNativeSpy).toHaveBeenCalledWith({
            method: "open_external_url",
            args: {
                url
            }
        });
    });

    describe("getGroupStore Legacy", () => {
        it("should not call executeNative and return an error", () => {
            // Given
            executeNativeSpy.mockReturnValue(Promise.resolve("{}"));
            const error: ErrorMessage = {
                code: ErrorCodes.UnavailableCommand,
                data: {
                    command: "get_group_store",
                    unavailableArgs: [],
                }
            };

            // When
            const promise = navigationCommands.getGroupStore();

            // Then
            expect(executeNativeSpy).not.toHaveBeenCalled();
            return promise.catch(value => expect(value).toEqual(error));
    
        });

        it("should not return a store object", () => {
            // Given
            const store = { value: "Test" };
            const storeString = JSON.stringify(store);
            executeNativeSpy.mockReturnValue(Promise.resolve(storeString));
            const error: ErrorMessage = {
                code: ErrorCodes.UnavailableCommand,
                data: {
                    command: "get_group_store",
                    unavailableArgs: [],
                }
            };

            // When
            const promise = navigationCommands.getGroupStore();

            // Then
            expect(executeNativeSpy).not.toHaveBeenCalled();
            return promise.catch(value => expect(value).toEqual(error));
        });
    });

    describe("setGroupStore Legacy", () => {
        it("should not call executeNative and return an error", () => {
            // Given
            const store = { value: "Test" };
            const value2 = 123;
            const storeString = JSON.stringify(store);
            const getGroupStoreSpy = jest.fn();
            navigationCommands.getGroupStore = getGroupStoreSpy;

            getGroupStoreSpy.mockReturnValue(Promise.resolve(store));
            const error: ErrorMessage = {
                code: ErrorCodes.UnavailableCommand,
                data: {
                    command: "set_group_store",
                    unavailableArgs: [],
                }
            };

            // When
            const promise = navigationCommands.setGroupStore(store => ({ ...store, value2 }));

            // Then
            expect(executeNativeSpy).not.toHaveBeenCalled();
            return promise.catch(value => expect(value).toEqual(error));
        });

    });
});
