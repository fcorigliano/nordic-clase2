import { MobileWebkit } from "../../../mobile-webkit";
import { PushOptions } from "../push_options";
import { BacksupportCallback, sendUnavailableArgsError } from "../../utils/command-backsupport";
import { ArgsBackSupport, getSupportArgs } from "../../utils/args-backsupport";
import { NavigationCommands } from "../navigation_commands";

export class NavigationCommandsLegacy implements NavigationCommands {

    private readonly openInternalDeeplinkArgs: ArgsBackSupport= {
        deeplink: { field : "deeplink" },
        replace: {field: "replace" }
    }

    constructor(private mobileWebKit: MobileWebkit) { }

    reload(backsupport?: BacksupportCallback) : Promise<string>{
        return sendUnavailableArgsError({
            command: "reload",
            backsupportCallback: backsupport,
            unavailableArgs: []
        });
    }

    push(deeplink: string, receivedArgs?: PushOptions, backsupport?: BacksupportCallback): Promise<string> {
        const { args, unavailable } = getSupportArgs(receivedArgs, this.openInternalDeeplinkArgs)
        return this.mobileWebKit.executeNative({
            method: "open_internal_deeplink",
            args: {
                deeplink,
                ...args
            },
        }).then(result => sendUnavailableArgsError({
            command: "push",
            expectedResult: result,
            unavailableArgs: unavailable,
            backsupportCallback: backsupport
        }));
    }

    pop(args?: { screens?: number, isHistoryEnabled?: boolean}): Promise<string> {
        if (args.isHistoryEnabled) {
            return this.mobileWebKit.executeNative({
                method: 'back',
                args
            });
        }
        return this.mobileWebKit.executeNative({
            method: 'close',
            args
        });
    }

    // TODO: se deberia subscribir a un evento para capturar el resultado?
    openForResult(deeplink: string, request_code: number, backsupport?: BacksupportCallback): Promise<any> {
        return sendUnavailableArgsError({
            command: "open_for_result",
            backsupportCallback: backsupport,
            unavailableArgs: []
        });
    }

    closeScreenGroup(args?: { result?: any }, backsupport?: BacksupportCallback): Promise<string> {
        return sendUnavailableArgsError({
            command: "close_screen_group",
            backsupportCallback: backsupport,
            unavailableArgs: []
        });
    }

    canOpenDeeplink(deeplink: string, args: { only_current_app: boolean }): Promise<boolean> {
        return this.mobileWebKit.executeNative({
            method: "can_open_deeplink",
            args: {
                deeplink,
                ...args
            }
        });
    }

    openLinkInAppBrowser(url: string, args: { show_title: boolean }): Promise<string> {
        return this.mobileWebKit.executeNative({
            method: "open_url",
            args: {
                url,
                ...args
            }
        });
    }

    openLinkOutsideApp(url: string): Promise<string> {
        return this.mobileWebKit.executeNative({
            method: "open_external_url",
            args: {
                url
            }
        });
    }

    getGroupStore(selector?: string, backsupport?: BacksupportCallback): Promise<any> {
        return sendUnavailableArgsError({
            command: "get_group_store",
            backsupportCallback: backsupport,
            unavailableArgs: []
        });
    }

    setGroupStore(newStore: (store: any) => any, selector?: string, backsupport?: BacksupportCallback): Promise<string> {
        return sendUnavailableArgsError({
            command: "set_group_store",
            backsupportCallback: backsupport,
            unavailableArgs: []
        });
    }
}
