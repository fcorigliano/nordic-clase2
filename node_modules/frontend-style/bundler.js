const path = require('path');
const fs = require('fs');
const { PRODUCTION, TEST } = require('frontend-env');
const LinkHeader = require('http-link-header');
const log = require('frontend-logger')('frontend-style');
const {
  URI,
  CONTENT,
} = require('./src/constants/render-types');
const { expireTimeWindow } = require('./src/constants/cookies');

const manifestsCache = {};

const stylesCache = new Map();

// In the production Fury env the VERSION is defined in environment variables
let { VERSION } = process.env;
// If for a some reason VERSION is not defined use the version value from app package.json
// Also it is used for development
if (!VERSION) {
  try {
    VERSION = require(path.join(path.resolve('./'), 'package.json')).version; // eslint-disable-line
  } catch (e) {
    VERSION = '1.0.0';
  }
}

const defaults = {
  useCache: PRODUCTION,
  manifest: 'manifest.json',
  useManifest: false,
  prefix: null,
  basePath: 'build',
  criticalKey: null,
  criticalCookiePath: '/',
  criticalCookieDomain: null,
};

const emptyContent = {
  type: CONTENT,
  content: '',
};

class StylesBundler {
  constructor(config = {}) {
    // eslint-disable-next-line prefer-object-spread
    this.config = Object.assign({}, defaults, config);
    this.basePath = path.resolve(this.config.basePath);
  }

  bundle(req, res, Style) {
    const propsList = Style.rewind();

    if (!(propsList && propsList.length)) {
      return Promise.resolve({ styles: '', preload: '' });
    }

    const {
      stylesForPrefetch,
      stylesForPreload,
      stylesToRender,
      cookiesToSet,
    } = this.getPropsStyles(propsList, req);

    return Promise.all([
      this.getPrefetchOut(stylesForPrefetch, cookiesToSet, req, res),
      this.getPreloadOut(stylesForPreload),
      this.getStylesOut(stylesToRender),
    ])
      .then(([prefetchOut, preloadOut, stylesOut]) => ({
        styles: `${stylesOut}${prefetchOut}`,
        preload: preloadOut,
      }))
      .catch(() => ({
        styles: '',
        preload: '',
      }));
  }

  getPropsStyles(propsList, req) {
    const { cookies } = req;

    const stylesForPrefetch = [];
    const stylesForPreload = [];
    const stylesToRender = [];
    const cookiesToSet = [];

    const bundledFileNames = {};
    const renderedContent = {};


    propsList.forEach((style) => {
      const isHrefExternal = style.href && this.isExternal(style.href);

      const children = typeof style.children === 'string' && style.children.trim();

      // if the children style was rendered in place mark it as rendered content
      if (style.renderChildrenInPlace && children && !style.critical && !style.firstRequestInlineStyles) {
        renderedContent[children] = true;
      }

      if (style.href) {
        if (!style.inline) {
          // First request inline styles
          const {
            key,
            value,
          } = style.firstRequestInlineStyles || {
            key: style.critical && this.config.criticalKey,
            value: VERSION,
          };

          if (key && value) {
            if (key === true || cookies[`c_${key}`] !== value) {
              // Cookie does not match
              // Render embedded style with linked styles prefetching
              if (isHrefExternal) {
                if (children) {
                  // <Style critical href="https://some-external-url.css">{'.white {color: white;}'}</Style>
                  stylesToRender.push(this.getStyleFromContent(children, style, renderedContent));

                  // Prefetch files
                  stylesForPrefetch.push({
                    type: URI,
                    content: style.href,
                    key,
                    value,
                  });

                  // Mark external resource as bundled to avoid content duplication
                  bundledFileNames[style.href] = true;
                  return;
                }

                // <Style href="some-external-file.css" firstRequestInlineStyles={{ key: 'key', value: 'value' }} />
                // <Style href="some-external-file.css" critical />
                // set the cookie but send linked styles
                stylesToRender.push(this.getStyleFromUrl(style, bundledFileNames, stylesForPreload));
                cookiesToSet.push({
                  key,
                  value,
                });
              } else {
                // <Style critical href="local-file-path.css" />
                // Take the content from file
                stylesToRender.push(this.getStyleFromFile(style.href, style, bundledFileNames));

                // Prefetch file
                const normalizedHref = this.normalizeStylePath(style)
                  .then((data) => ({
                    ...data,
                    key,
                    value,
                  }));

                stylesForPrefetch.push(normalizedHref);
                return;
              }
            } else {
              // Cookie matches

              // <Style critical href="demo.css" />
              // <Style critical href="some-external-url.css" />
              stylesToRender.push(this.getStyleFromUrl(style, bundledFileNames, stylesForPreload));
              return;
            }
          }
        }

        if (isHrefExternal || !style.inline) {
          // <Style href="https://some-external-url.css" />
          // <Style href="demo.css" />
          stylesToRender.push(this.getStyleFromUrl(style, bundledFileNames, stylesForPreload));
        } else if (style.inline) {
          // <Style href="demo.css" inline />
          stylesToRender.push(this.getStyleFromFile(style.href, style, bundledFileNames));
        }
      }

      if (children) {
        // <Style renderChildrenInPlace={false}>{'.white {color: white;}'}</Style>
        stylesToRender.push(this.getStyleFromContent(children, style, renderedContent));
      }
    });

    return {
      stylesForPrefetch,
      stylesForPreload,
      stylesToRender,
      cookiesToSet,
    };
  }

  getStylesOut(stylesToRender) {
    return Promise.all(stylesToRender)
      .then((stack) => stack.reduce((out, style) => {
        if (!style.content) {
          return out;
        }
        const mediaAttribute = style.media ? ` media="${style.media}"` : '';
        const styleOut = style.type === CONTENT
          ? `<style${mediaAttribute}>${style.content}</style>`
          : `<link href="${style.content}" rel="stylesheet" type="text/css"${mediaAttribute} onerror="(window['_pfl'] = window['_pfl'] || []).push(['css', this.href])" />`;

        return `${out}${styleOut}\n`;
      }, ''));
  }

  getPreloadOut(stylesForPreload) {
    if (!stylesForPreload.length) {
      return '';
    }
    return Promise.all(stylesForPreload)
      .then((preloads) => {
        const link = new LinkHeader();
        preloads.forEach((s) => {
          // [ { type: 'uri', content: '/home.desktop.css' } ]
          if (s.type === URI) {
            link.set({
              rel: 'preload',
              uri: s.content,
              as: 'style',
              crossorigin: 'anonymous',
            });
          }
        });
        return link.toString();
      });
  }

  getPrefetchOut(stylesForPrefetch, cookiesToSet, req, res) {
    return Promise.all(stylesForPrefetch)
      .then((prefetches) => {
        prefetches
          .concat(cookiesToSet)
          .reduce((prefetchedKeys, prefetch) => {
            if (!prefetchedKeys[prefetch.key] && typeof prefetch.key === 'string') {
              this.setCriticalPathCookie(req, res, prefetch);
              prefetchedKeys[prefetch.key] = true; // eslint-disable-line no-param-reassign
            }
            return prefetchedKeys;
          }, {});

        return this.getPrefetchScript(prefetches, req.browser && req.browser.support && req.browser.support.prefetch);
      });
  }

  getStyleFromUrl(style, bundledFileNames, stylesForPreload) {
    if (bundledFileNames[style.href]) {
      return Promise.resolve(emptyContent);
    }

    bundledFileNames[style.href] = true; // eslint-disable-line no-param-reassign

    const normalizedHref = this.isExternal(style.href)
      ? {
        type: URI,
        content: style.href,
        media: style.media,
      }
      : this.normalizeStylePath(style);

    if (style.preload) {
      // <Style critical href="demo.css" preload />
      stylesForPreload.push(normalizedHref);
    }

    return normalizedHref;
  }

  getStyleFromContent(content, style, renderedContent) {
    if (renderedContent[content]) {
      return emptyContent;
    }

    renderedContent[content] = true; // eslint-disable-line no-param-reassign
    return {
      type: CONTENT,
      content,
      media: style.media,
    };
  }

  getStyleFromFile(filename, style, bundledFileNames) {
    if (!filename || bundledFileNames[filename]) {
      return emptyContent;
    }

    // Mark filename as bundled
    bundledFileNames[filename] = true; // eslint-disable-line no-param-reassign

    return this.getNormalizedFileName(filename)
      .then((normalizedFilename) => { // eslint-disable-line consistent-return
        if (!normalizedFilename) {
          if (!TEST) {
            log.error(`File not found in manifest. Filename: ${filename}`);
          }
          return emptyContent;
        }

        if (this.config.useCache) {
          const content = stylesCache.get(normalizedFilename);
          if (content) {
            return {
              type: CONTENT,
              content,
              media: style.media,
            };
          }
        }

        const filePath = path.join(this.basePath, normalizedFilename);

        return new Promise((resolve) => fs.readFile(filePath, (err, content) => {
          if (err) {
            if (!TEST) {
              log.error(`Unable to read file ${normalizedFilename}`, err);
            }
            return resolve(emptyContent);
          }

          const fileContentRaw = content.toString().trim();
          const fileContent = fileContentRaw.replace(/\/\*# sourceMappingURL=[-_A-Za-z0-9.]+\.css\.map\*\//g, '');

          stylesCache.set(normalizedFilename, fileContent);

          return resolve({
            type: CONTENT,
            content: fileContent,
            media: style.media,
          });
        }));
      });
  }

  getNormalizedFileName(href) {
    const { manifest, useManifest } = this.config;
    return (
      useManifest
        ? this.getManifest(manifest).then((manifestData) => manifestData[href])
        : Promise.resolve(href)
    );
  }

  normalizeStylePath(style) {
    const { prefix } = this.config;

    return this.getNormalizedFileName(style.href)
      .then((fileName) => ({
        type: URI,
        content: `${prefix || ''}${fileName}`,
        media: style.media,
      }));
  }

  getManifest(manifest) {
    if (this.config.useCache && manifestsCache[manifest]) {
      return Promise.resolve(manifestsCache[manifest]);
    }

    return new Promise((resolve) => {
      fs.readFile(path.join(this.basePath, manifest), (err, content) => {
        if (err) {
          if (!TEST) {
            log.error('Unable to read manifest', err);
          }
          return resolve(emptyContent);
        }

        let manifestData;

        try {
          manifestData = JSON.parse(content);
        } catch (e) {
          if (!TEST) {
            log.error('Unable to parse manifest', e);
          }
          return resolve(emptyContent);
        }
        manifestsCache[manifest] = manifestData;

        return resolve(manifestData);
      });
    });
  }

  isExternal(href) {
    return href.startsWith('http') || href.startsWith('//');
  }

  setCriticalPathCookie(req, res, prefetch) {
    const cookieConfig = {
      expires: new Date(Date.now() + expireTimeWindow),
      domain: this.config.criticalCookieDomain || req.hostname,
      path: this.config.criticalCookiePath,
      httpOnly: true,
    };

    if (req.browser && req.browser.support && req.browser.support.sameSite) {
      cookieConfig.sameSite = 'none';
    }

    if (req.headers.ml_ssl === '1' || req.connection.encrypted) {
      cookieConfig.secure = true;
    }

    res.cookie(`c_${prefetch.key}`, prefetch.value, cookieConfig);
  }

  getPrefetchScript(assets, supportsPrefetch) {
    if (!assets || !assets.length) {
      return '';
    }

    const assetsList = assets.map((a) => JSON.stringify(a.content)).join(',');
    let preloadCriticalPathFn;

    if (supportsPrefetch) {
      preloadCriticalPathFn = `
function preloadCriticalPath() {
  var head = doc.getElementsByTagName('head')[0],
      assets = [${assetsList}],
      link,
      i;
  for(i = 0; i < assets.length; i++) {
    link = doc.createElement('link');
    link.rel = 'prefetch';
    link.href = assets[i];
    link.onerror = function(e) {
      (window['_pfl'] = window['_pfl'] || []).push(['css', e.target.href]);
    }
    head.appendChild(link);
  }
}`;
    } else {
      preloadCriticalPathFn = `
function preloadCriticalPath() {
  var body = doc.getElementsByTagName('body')[0],
      assets = [${assetsList}],
      object,
      isIE = navigator.appName.indexOf('Microsoft') === 0,
      i;
  for(i = 0; i < assets.length; i++) {
    if(isIE) {
      new Image().src = assets[i];
    } else {
        object = doc.createElement('object');
        object.data = assets[i];
        object.width = 0;
        object.height = 0;
        object.style.position = 'absolute';
        body.appendChild(object);
      }
    }
}`;
    }

    const nonceAttribute = this.config.nonceCSP
      ? ` nonce="${this.config.nonceCSP}"`
      : '';

    return `
<script${nonceAttribute}>
(function(win, doc) {
  ${preloadCriticalPathFn}
  if (doc.readyState === 'complete') {
    setTimeout(preloadCriticalPath, 0);
  } else {
    win.addEventListener('load', function() {
      preloadCriticalPath();
    });
  }
})(window, document);
</script>
`;
  }
}

module.exports = StylesBundler;
