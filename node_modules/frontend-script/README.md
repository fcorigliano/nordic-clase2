# Frontend Script component

> React component to load 3rd party scripts

## Installation

```sh
npm install -S frontend-script
```

## Features

- Allows to enqueue external scripts from any component at any
  point of your React app.
- Does not emit DOM. Ever.
- Can be defined in many places throughout the application.
- Does not allow duplicated scripts.

## Usage

### `src`

You can pass an array of script locations through the `src` attribute and they'll be loaded
in that order.

Keep in mind all these scripts will share the same priority you specify, if you need
different individual priorities, use different calls to `Script` with the desired values.

**Example:**

```jsx
const Script = require('frontend-script');

// Enqueue Backbone and its dependencies
<div>
  <Script
    src={[
      'https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js',
      'https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js',
      'https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.3.3/backbone-min.js'
    ]}
  />
</div>
```


### `priority`

In case you need to force some scripts to load before others even though they're defined
down in the React tree, you can achieve that by assigning them a fixed `priority`. A
`piority` is a number that helps order the scripts, it starts from 1 meaning that's the
first script to be loaded, but has no maximum limit.

**Note:** *By default all scripts loaded will get a priority value of 100 if you don't
specify one yourself.*

When deciding the order between different sources with the same `priority`, `Script` will
load them in the order they were found.

As `Script` filters duplicates so you load your desired scripts only once, there's a catch
with the `priority`. Whenever `Script` finds a duplicate script, the resulting priority will
be the highest one (lowest actual number).

**Example:**

The same result can be achieved with multiple `Script` elements as with the previous example
using an array in `src`:

```jsx
const Script = require('frontend-script');

<div>
  // Enqueue Underscore
  <Script
    src={'https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js'}
    priority={50}
  />

  // Enqueue Backbone
  <Script
    src={'https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.3.3/backbone-min.js'}
    priority={51}
  />

  // Enqueue jQuery but before the other scripts (Higher Priority)
  <Script
    src={'https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js'}
    priority={40}
  />
</div>
```

The resulting loading order is : `jQuery` -> `Underscore` -> `Backbone`

**Mixing priority and default priority**:

This is an example of a tricky situation that can happen to you once you start using
`priority`, so beware of it:

```jsx
const Script = require('frontend-script');

<div>
  <Script src="script-a.js" />
  <Script src="script-b.js" priority={10} />
  <Script src="script-c.js" />
</div>
```

The resulting loading order of this arrangement is:

`script-b` -> `script-a` -> `script-c`

But what happens if we add a priority to `script-c`?

```jsx
const Script = require('frontend-script');

<div>
  <Script src="script-a.js" />
  <Script src="script-b.js" priority={10} />
  <Script src="script-c.js" priority={20} />
</div>
```

Now the loading order is:

`script-b` -> `script-c` -> `script-a`

Keep this in mind whenever adding a priority to a script, that it might load before all
other scripts without default priority and you might be introducing an unexpected loading
order bug in your app.

### `on`

You can specify when the script loader should execute the desired script. The accepted
values are:

 * `"load"` _(default)_: Scripts are run on window load
 * `"now"`: Scripts are run immediately (blocking).

### `inline`

The most of scripts can be embedded directly into the document to avoid the additional requests. It is useful for small
 scripts but is not recommended for large files since the embedded content cannot be cached.

To embed the content of some file just add an `inline` property to the `<Script>` element. Please note that external
 resources located on HTTP network cannot be embedded. To embed the script defined as entryPoint just use its name as
 a `src` value, use path relative to the current working directory to embed some script from the project. To embed some
 resource from node_modules just use a `require`-like style by providing the package's name as a base and a path suffix
 after the module name separated by `/` symbol.

**Examples:**

Embed the content of `page.js` entry point:

```jsx
const Script = require('frontend-script');

<Script src="page.js" inline />
```

Embed the content of `app/utils.js` located in the project's root:

```jsx
const Script = require('frontend-script');

<Script src="./app/utils.js" inline />
```

Embed the content of `merge.js` located in the `lodash` package:

```jsx
const Script = require('frontend-script');

<Script src="lodash/merge.js" inline />
```

### `preload`

Allows to preload scripts that have a positive `preload` value. Those scripts will be extracted to a string in a format
 defined by [RFC 5988](https://tools.ietf.org/html/rfc5988#section-5) that can be used as a value for Link HTTP header:

 * `false` _(default)_: Load scripts in a common way
 * `true`: Load scripts in a two phases, first preload them without execution and later depending on `on` parameter execute
   when document is loaded or immediately

*Please note that inline script cannot be preloaded.*

**Examples:**

Preload the `page.js` entry point:

```jsx
const Script = require('frontend-script');

<Script src="page.js" preload />
```

Preload some external JavaScript file:

```jsx
const Script = require('frontend-script');

<Script src="https://unpkg.com/react@16/umd/react.production.min.js" preload />
```

### Embedded scripts

`Script` as well as the traditional `<script>` tag can have text content. The same
properties as when using `src` apply.

**Example:**

```jsx
<Script>
  {`
    window.__PRELOADED_STATE__ = ${serialize(preloadedState, { isJSON: true })};
  `}
</Script>
```

## Scripts loading (Server Side Rendering)

Inside the library there is a helper that allows you to generate a loader function
  and call it with the queued scripts.

```js
const Script = require('frontend-script');
const ScriptsBundler = require('frontend-script/bundler');
const scriptsBundler = new ScriptsBundler({
  prefix: 'https://http2.mlstatic.com/resources/frontend/myapp/',
});

// bundle method is async, use with promises or async/await
scriptsBundler.bundle(Script)
  .then(({ scriptsLoader, preloadHeader }) => {
    // will contain a complete script code including the scripts loader (currently jcors),
    // scripts prefixed with a CDN prefix and revisioned filenames from manifest.json file.
    console.log(scriptsLoader);
    
    // Will provide a ready to use preload header value that should be used as a part of Link HTTP header 
    console.log(preloadHeader);
  });
```

## Polyfills middleware

This module exposes the `polyfillsMiddleware` useful for determining whether a browser should be treated as `legacy` (older browsers that need polyfills for modern Javascript).

### How does it work?

The middleware sets the `req.legacyBrowser` boolean that determines whether the current request is from a legacy browser or not.

### Configuration options

#### defaultBrowsers

Type: `boolean`

Default: `undefined`

This property is used to indicate whether the list of browser versions to be considered as legacy is the [default for Nordic applications](#default-browsers-list).

```js
// server/index.js

const polyfillsMiddleware = require('nordic/script/polyfills-middleware');

router.use(polyfillsMiddleware({ defaultBrowsers: true }));
```

#### limits

Type: `object`

Default: `undefined`

This property is an object that defines the threshold for legacy browsers. Unspecified browsers will not receive polyfills.

```js
const options = {
  limits: {
    [browserName]: version
  }
}
```

- `browserName`: The browser name. It must match the ones provided by [req.browser.name](https://nordic.adminml.com/docs/api/Nordic%20Deep%20Modules/frontend-device_detection#reqbrowser)

- `version`: The version from which you want to start providing polyfills. Previous versions to it will be considered legacy.

Full example:

```js
// server/index.js

const polyfillsMiddleware = require('nordic/script/polyfills-middleware');

const options = {
  limits: {
    edge: '15',
  },
};

router.use(polyfillsMiddleware(options));
```

##### Default browsers list

```js
{
  chrome: '54',
  firefox: '52',
  edge: '14',
  safari: '10.1',
  android: '67',
  'chrome mobile': '54',
  'mobile safari': '10.3',
}
```
