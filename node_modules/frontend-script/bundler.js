const path = require('path');
const fs = require('fs');
const logger = require('frontend-logger');
const { PRODUCTION, TEST } = require('frontend-env');
const LinkHeader = require('http-link-header');
const invert = require('lodash.invert');
const jcors = require('./src/jcors');

const manifestsCache = new Map();
const inlineScriptsCache = new Map();
const log = logger('frontend-script');

const defaults = {
  useCache: PRODUCTION,
  manifest: 'manifest.json',
  prefix: null,
  basePath: 'build',
  enableJcorsLoading: false,
};

class ScriptsBundler {
  constructor(config = {}) {
    // eslint-disable-next-line prefer-object-spread
    this.config = Object.assign({}, defaults, config);
    this.basePath = path.resolve(this.config.basePath);
  }

  bundle(Script, req, prepend, append, chunkExtractor) {
    const { manifest } = this.config;
    let scripts = [];

    scripts = scripts.concat(this.normalizeSourcesFormat(prepend));

    const mainScripts = Script.rewind();
    if (mainScripts) {
      scripts = scripts.concat(mainScripts);
    }

    scripts = scripts.concat(this.normalizeSourcesFormat(append));

    if (!scripts.length) {
      return Promise.resolve({ scripts: '', preload: '' });
    }

    return new Promise((resolve, reject) => {
      this.getManifest(manifest)
        .then((manifestData) => {
          if (chunkExtractor) {
            const chunks = chunkExtractor.getChunkScripts();
            if (chunks.length > 0) {
              const manifestDataInverted = invert(manifestData);
              chunks
                .map((chunk) => (
                  manifestDataInverted[chunk.src] ? { ...chunk, src: manifestDataInverted[chunk.src] } : chunk
                ))
                .forEach((chunk) => { // add only if not already added, e.g user added manually the script with Script src="vendor.js"
                  if (!scripts.find((s) => s.src === chunk.src)) {
                    scripts.push(chunk);
                  }
                });
            }
          }

          const onloadSources = scripts.reduce((ss, s) => {
            if (s.on === 'load') {
              ss.push(this.getFullSrc(s, manifestData, req)
                .then((source) => ({ source, children: s.children, id: s.id })));
            }
            return ss;
          }, []);

          /**
           * Result of the next operation goes directly to the client so applied some kind of manual minification
           * Where `s` is a key for `source` and `c` is for `children`
           * @type {Promise<string>}
           */
          const onload = Promise.all(onloadSources)
            .then((onloadQueue) => onloadQueue
              .filter((q) => q.source || q.children)
              .map((q) => (q.children
                ? `{s:${q.source}${q.id ? `,id:"${q.id}",` : ','}c:${Array.isArray(q.children) ? `function(){ ${q.children.map((c) => `(${c})()`).join(';')} }` : q.children}}`
                : `{s:${q.source}${q.id ? `,id:"${q.id}"` : ''}}`))
              .join(','))
            .catch(() => '');

          const onnowSources = scripts.reduce((ss, s) => {
            if (s.on === 'now') {
              ss.push(this.getFullSrc(s, manifestData, req)
                .then((source) => ({ source, children: s.children, id: s.id })));
            }
            return ss;
          }, []);

          /**
           * Result of the next operation goes directly to the client so applied some kind of manual minification
           * Where `s` is a key for `source` and `c` is for `children`
           * @type {Promise<string>}
           */
          const onnow = Promise.all(onnowSources)
            .then((onnowQueue) => onnowQueue
              .filter((q) => q.source || q.children)
              .map((q) => (q.children
                ? `{s:${q.source}${q.id ? `,id:"${q.id}",` : ','}c:${Array.isArray(q.children) ? `function(){ ${q.children.map((c) => `(${c})()`).join(';')} }` : q.children}}`
                : `{s:${q.source}${q.id ? `,id:"${q.id}"` : ''}}`))
              .join(','))
            .catch(() => '');

          const preloadSources = scripts.reduce((ss, s) => {
            if (s.preload && s.type !== 'function' && !s.inline) {
              ss.push(this.getFullSrc(s, manifestData, req));
            }
            return ss;
          }, []);

          const preloadsList = Promise.all(preloadSources)
            .catch(() => []);

          Promise.all([onload, onnow, preloadsList])
            .then(([onloadScript, onnowScript, preloads]) => {
              const scriptsOut = this.config.enableJcorsLoading
                ? this.renderUsingJcors(onnowScript, onloadScript) : this.renderUsingDefer(onnowScript, onloadScript);

              let preloadOut = '';
              if (preloads.length) {
                const link = new LinkHeader();
                preloads.forEach((s) => {
                  // trim `"` character since we have JSON.stringify all external script URLs
                  // http-link-header escapes all specials chars when needed but can throw on not allowed characters
                  try {
                    link.set({
                      rel: 'preload',
                      uri: s.replace(/^"|"$/g, ''),
                      as: 'script',
                      crossorigin: 'anonymous',
                    });
                  } catch (e) { } // eslint-disable-line
                });
                preloadOut = link.toString();
              }

              resolve({ scripts: scriptsOut, preload: preloadOut });
            })
            .catch((err) => reject(err));
        });
    });
  }

  renderUsingJcors(onnowScripts, onloadScripts) {
    let output = jcors;
    if (onnowScripts) {
      output += `jcors(${onnowScripts});`;
    }
    if (onloadScripts) {
      output += `
(function(win, doc) {
  var scripts = [${onloadScripts}];
  if (doc.readyState === 'complete') {
   jcors.apply(win, scripts);
  } else {
    win.addEventListener('load', function() {
      jcors.apply(win, scripts);
    });
  }
})(window, document);
`;
    }

    return output;
  }

  renderUsingDefer(onnowScripts, onloadScripts) {
    if (!onnowScripts && !onloadScripts) {
      return '';
    }

    const output = `
(function(win, doc){
  function loadScripts (s) {
    if (!s || !s.length) return;
    s = s.slice(0);
    var h = doc.head || doc.getElementsByTagName('head')[0];
    var cbStack = {}; var cbChild = {};

    for (var i = 0; i < s.length; i++) {
      var c = s[i];
      var t = doc.createElement('script');

      if (typeof c.s === 'function') {
        t.textContent = '(' + c.s + ').apply(window);';
      } else {
        t.async = false;
        t.defer = true;
        t.crossOrigin = 'anonymous';
        if (c.id) t.id = c.id;

        if (c.s) t.src = c.s;
        var x = t.src;
        cbStack[x] = [];
        while(s[i+1] && typeof s[i+1].s === 'function') {
          cbStack[x].push(s[i+1].s);
          i++;
        }
        if (typeof c.c === 'function') { 
          cbChild[x] = c.c 
        } else if (c.c) {
          t.textContent = c.c;
        }
        t.onerror = function(err) {
          cbStack[err.target.src] && cbStack[err.target.src].forEach(function(cb){ (cb).apply(window) });

          var perfillNamespace = '_pfl';
          (window[perfillNamespace] = window[perfillNamespace] || []).push(['script', err.target.src])

          if (typeof meli_ga !== 'undefined') {
            meli_ga('send', {
              hitType: 'event',
              eventCategory: 'FRONTEND-ERROR',
              eventAction: 'SCRIPT-LOAD-ERROR',
              eventLabel: err.target.src,
              nonInteraction: true,
            });
          }
        }
        t.onload = function(e) {
          cbChild[e.target.src] && (cbChild[e.target.src]).apply(window);
          cbStack[e.target.src] && cbStack[e.target.src].forEach(function(cb){ (cb).apply(window) });
        }
      }
      h.appendChild(t);
    }
  }
  loadScripts([${onnowScripts}]);
  var scripts = [${onloadScripts}];
  if (doc.readyState === 'complete') {
    loadScripts(scripts);
  } else {
    win.addEventListener('load', function(){ loadScripts(scripts); });
  }
})(window, document);`;

    return output;
  }

  normalizeSourcesFormat(sources) {
    let normalized = [];

    if (Array.isArray(sources)) {
      normalized = sources.map((s) => {
        if (typeof s === 'string') {
          return {
            src: s,
            on: 'load',
          };
        }

        if (!s.on) {
          s.on = 'load'; // eslint-disable-line
        }

        return s;
      });
    }

    return normalized;
  }

  getFullSrc(script, manifestData = {}, req) {
    const { prefix } = this.config;

    return new Promise((resolve) => {
      /**
       * case: embedded code as child of the Script tag.
       * <Script>`const a = 2` </Script>
       */
      if (script.type === 'function') {
        return resolve(script.src);
      }

      /**
       * case: an asset fetched from a different server
       */
      if (this.isExternal(script.src)) {
        return resolve(JSON.stringify(script.src));
      }

      /**
       * case: a script tag with prop `inline=true`
       * <Script src='asset.js' inline>
       */
      if (script.inline) {
        if (inlineScriptsCache.has(script.src)) {
          return resolve(inlineScriptsCache.get(script.src));
        }

        let scriptPath;

        if (manifestData[script.src]) {
          const fileName = this.getLocalAssetURI(script, req, manifestData);
          scriptPath = path.join(process.cwd(), this.config.basePath, fileName);
        } else {
          const isRelative = /^[./]/.test(script.src);

          if (isRelative) {
            // Local file with relative path, definitely not an entry point
            scriptPath = path.join(process.cwd(), script.src);
          } else {
            if (!PRODUCTION) {
              // Only in development mode look for the built files, please note that in dev mode manifest is not generating
              const possiblePath = path.join(process.cwd(), this.config.basePath, script.src);
              try {
                const stats = fs.statSync(possiblePath);
                if (stats.isFile()) {
                  scriptPath = possiblePath;
                }
              } catch (err) { } // eslint-disable-line
            }

            if (!scriptPath) {
              scriptPath = path.join(process.cwd(), 'node_modules', script.src);
            }
          }
        }

        return fs.readFile(scriptPath, (err, cnt) => {
          if (err) {
            log.error(err.stack);
            return resolve('');
          }

          let scriptContent = `function(){${cnt}}`;
          if (script.inline) {
            scriptContent = scriptContent.replace(/\/\/# sourceMappingURL=[-_A-Za-z0-9.]+\.js\.map/, '');
          }
          if (this.config.useCache) {
            inlineScriptsCache.set(script.src, scriptContent);
          }

          return resolve(scriptContent);
        });
      }

      /**
       * case: assets that webpack has built
       */
      const src = this.getLocalAssetURI(script, req, manifestData);

      return resolve(JSON.stringify(`${prefix || ''}${src}`));
    });
  }

  getLocalAssetURI(script, req, manifest) {
    /**
     * Made to be used only for server assets, not external ones.
     * It'll match what your webpack config built,
     */
    const { src: scriptSrc } = script;
    const legacySrc = scriptSrc.replace('.js', '.legacy.js');
    const useLegacySrc = !!(req && !req.nordicPages && req.legacyBrowser && manifest[legacySrc]);
    if (useLegacySrc) {
      return manifest[legacySrc];
    }

    return manifest[scriptSrc];
  }

  getManifest(manifest) {
    if (this.config.useCache && manifestsCache.has(manifest)) {
      return Promise.resolve(manifestsCache.get(manifest));
    }

    return new Promise((resolve) => {
      fs.readFile(path.join(this.basePath, manifest), (err, content) => {
        if (err) {
          if (!TEST) {
            log.error('Unable to read manifest', err);
          }
          return resolve({});
        }

        let manifestData;
        try {
          manifestData = JSON.parse(content);
        } catch (e) {
          if (!TEST) {
            log.error('Unable to parse manifest', e);
          }
          return resolve({});
        }
        manifestsCache.set(manifest, manifestData);

        return resolve(manifestData);
      });
    });
  }

  isExternal(src) {
    return /^https?:/.test(src) || src.startsWith('//');
  }
}

module.exports = ScriptsBundler;
