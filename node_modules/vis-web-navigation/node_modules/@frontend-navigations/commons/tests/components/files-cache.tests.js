const { join } = require('path');
const os = require('os');
const {
  REST_CLIENT_TIMEOUT,
  RETRY_TIME_WINDOW,
} = require('../../constants/first-request-inline-styles');
const PromiseMock = require('jest-mock-promise').default;
const path = require('path');

const localUiNavigationVersion = 'local-ui-navigation-version';
jest.mock('ui-navigation/package.json', () => ({ version: 'local-ui-navigation-version' }));

jest.mock('frontend-config', () => ({
  addUpdateHandler: jest.fn(),
}));

const defaultData = {
  fileName: 'some-file-name',
  platformId: 'some-platform-id',
  siteId: 'some-site-id',
  environment: 'some-config-environment',
  uiNavigationVersion: 'some-ui-navigation-version',
  platformName: 'some-platform-name',
};

const moduleName = 'frontend-navigations/commons';

const localUiNavigationDistPath = '/ui-navigation-absolute-path/dist';

const filesFolder = join(os.tmpdir(), 'frontend-navigations-files', 'files-cache');

const restClientExpectedConfig = expect.objectContaining({
  context: expect.anything(),
});

const getNodeModulesFilePath = data => join(localUiNavigationDistPath, data.platformName, data.fileName);
const getAPIFilePath = data => join(filesFolder, data.uiNavigationVersion, data.platformName, data.fileName);

const mockFs = (options = {}) => {
  const fileContent = 'file-content';
  const toString = jest.fn().mockReturnValueOnce(fileContent);

  const readFile = options.readFile
    || jest.fn().mockImplementation((filePath, callback) => setTimeout(() => callback(null, { toString })));

  const writeFile = options.writeFile
    || jest.fn().mockImplementation((filePath, content, writeOptions, callback) => setTimeout(() => callback(null)));

  const unlink = options.unlink
    || jest.fn().mockImplementation((filePath, callback) => setTimeout(() => callback(null)));

  const existsSync = options.existsSync || jest.fn().mockReturnValue(true);
  const mkdirSync = options.mkdirSync || jest.fn();
  jest.doMock('fs', () => ({
    readFile,
    existsSync,
    mkdirSync,
    writeFile,
    unlink,
  }));

  return {
    fileContent,
    mocks: {
      existsSync,
      mkdirSync,
      readFile,
      readFileToString: toString,
      writeFile,
      unlink,
    },
  };
};

const mockRestClient = (options = {}) => {
  const apiContent = 'api-content';
  const getPromiseMock = new PromiseMock();
  const get = options.get || jest.fn().mockImplementation(() => getPromiseMock);

  const restClient = options.restClient || jest.fn().mockImplementation(() => ({ get }));
  jest.doMock('frontend-restclient', () => restClient);

  const expectRestClientCall = () => {
    expect(restClient).toBeCalledWith(expect.objectContaining({
      timeout: REST_CLIENT_TIMEOUT,
    }));
  };

  const resolveGetPromiseMock = (resolveData = { data: apiContent }) => getPromiseMock.resolve(resolveData);

  return {
    apiContent,
    expectRestClientCall,
    resolveGetPromiseMock,
    mocks: {
      restClient,
      get,
    },
  };
};

describe('Commons', () => {
  beforeEach(() => {
    jest.resetAllMocks();
    jest.resetModules();
  });

  describe('Css component files-cache', () => {
    describe('getFileContent', () => {
      const getFileContent = options => require('../../components/css/files-cache').getFileContent(options);

      describe('without cached content', () => {
        it('should return null if content was not found on disk', () => {
          mockFs();

          const contentResult = getFileContent(defaultData);

          expect(contentResult).toEqual(null);
        });

        it('should schedule get file content from API', () => {
          jest.useFakeTimers('legacy');

          const data = defaultData;

          const apiFilePath = getAPIFilePath(data);

          const readFile = jest.fn().mockImplementation((filePath, callback) => setTimeout(() => callback(new Error('File not found'))));
          const existsSync = jest.fn()
            .mockReturnValueOnce(true)
            .mockReturnValueOnce(false)
            .mockReturnValue(true);

          const { mocks: fsMocks } = mockFs({
            readFile,
            existsSync,
          });

          const {
            mocks: restClientMocks,
            expectRestClientCall,
            apiContent,
            resolveGetPromiseMock,
          } = mockRestClient();

          const url = 'some-url';
          const getHref = jest.fn().mockImplementation(() => url);
          jest.doMock('../../services/ui-navigation', () => ({ getHref }));

          const firstRequestContentResult = getFileContent(data);

          // Assert null result
          expect(firstRequestContentResult).toEqual(null);

          // Assert readFile call
          jest.runOnlyPendingTimers();

          expect(readFile).toBeCalledWith(apiFilePath, expect.any(Function));

          // readFile mock has a setTimeout
          jest.runAllTimers();

          // Assert rest client call
          expectRestClientCall();
          expect(getHref).toBeCalledWith(null, data.fileName, data.uiNavigationVersion, data.platformName);
          expect(restClientMocks.get).toBeCalledWith(url, restClientExpectedConfig);

          resolveGetPromiseMock();

          // Assert writeFile call
          const apiFilePathDirName = path.dirname(apiFilePath);
          expect(existsSync).toBeCalledWith(apiFilePathDirName);
          expect(fsMocks.mkdirSync).toBeCalledWith(apiFilePathDirName);
          expect(existsSync).toBeCalledWith(path.dirname(apiFilePathDirName));
          expect(fsMocks.writeFile).toBeCalledWith(apiFilePath, apiContent, expect.any(Object), expect.any(Function));

          jest.resetAllMocks();

          // Assert cached result
          const secondRequestContentResult = getFileContent(data);
          expect(secondRequestContentResult).toEqual(apiContent);

          // Assets no service is called once cached
          expect(existsSync).not.toBeCalled();
          expect(fsMocks.writeFile).not.toBeCalled();
          expect(restClientMocks.get).not.toBeCalled();
          expect(getHref).not.toBeCalled();
          expect(readFile).not.toBeCalled();
        });

        it('should log a request error and schedule a new request', () => {
          jest.useFakeTimers('legacy');

          const data = defaultData;

          const readFile = jest.fn().mockImplementation((filePath, callback) => setTimeout(() => callback(new Error('File not found'))));
          mockFs({ readFile });

          const getPromiseMock = new PromiseMock();
          const get = jest.fn()
            .mockReturnValueOnce(getPromiseMock)
            .mockReturnValue(new PromiseMock());
          mockRestClient({ get });

          const url = 'some-url';
          const getHref = jest.fn().mockImplementation(() => url);
          jest.doMock('../../services/ui-navigation', () => ({ getHref }));

          const error = jest.fn();
          const loggerFactory = jest.fn().mockReturnValue({ error });
          jest.doMock('../../logger/factory', () => ({ create: loggerFactory }));

          getFileContent(data);

          // Assert readFile call
          jest.runOnlyPendingTimers();

          // readFile mock has a setTimeout
          jest.runAllTimers();

          const errorMessage = 'some-error-message';
          const err = new Error(errorMessage);
          getPromiseMock.reject(err);

          // Assert logging
          expect(loggerFactory).toBeCalledWith(moduleName);
          expect(error).toBeCalledWith({
            err,
            errorType: 'files-cache-request-error',
            message: `Navigation CSS file cache - Error getting ${url}. Error message: ${errorMessage}`,
            tags: {
              url,
            },
          });

          expect(setTimeout).toBeCalledWith(expect.any(Function), RETRY_TIME_WINDOW);

          jest.clearAllMocks();

          jest.runOnlyPendingTimers();

          expect(getHref).toBeCalledWith(null, data.fileName, data.uiNavigationVersion, data.platformName);
          expect(get).toBeCalledWith(url, restClientExpectedConfig);
        });

        it('should log a file write error', () => {
          jest.useFakeTimers('legacy');

          const data = defaultData;

          const apiFilePath = getAPIFilePath(data);

          const readFile = jest.fn().mockImplementation((filePath, callback) => setTimeout(() => callback(new Error('File not found'))));
          const errorMessage = 'error-message';
          const mkdirSyncError = new Error(errorMessage);
          const mkdirSync = jest.fn().mockImplementation(() => {
            throw mkdirSyncError;
          });
          const existsSync = jest.fn()
            .mockReturnValueOnce(true)
            .mockReturnValueOnce(false)
            .mockReturnValue(true);
          mockFs({
            readFile,
            mkdirSync,
            existsSync,
          });

          const { resolveGetPromiseMock } = mockRestClient();

          const url = 'some-url';
          const getHref = jest.fn().mockImplementation(() => url);
          jest.doMock('../../services/ui-navigation', () => ({ getHref }));

          const error = jest.fn();
          const loggerFactory = jest.fn().mockReturnValue({ error });
          jest.doMock('../../logger/factory', () => ({ create: loggerFactory }));

          getFileContent(data);

          // Assert readFile call
          jest.runOnlyPendingTimers();

          // readFile mock has a setTimeout
          jest.runAllTimers();

          resolveGetPromiseMock();

          // Assert writeFile call
          expect(existsSync).toBeCalledWith(path.dirname(apiFilePath));
          expect(mkdirSync).toBeCalledWith(path.dirname(apiFilePath));
          expect(loggerFactory).toBeCalledWith(moduleName);
          expect(error).toBeCalledWith({
            err: mkdirSyncError,
            errorType: 'files-cache-writing-error',
            message: `Navigation CSS file cache - Error writing file ${apiFilePath}. Error message: ${errorMessage}`,
            tags: {
              filePath: apiFilePath,
            },
          });
        });

        it('should queue get file content from API if there\'s more ongoing requests than MAX_CONCURRENT_REQUESTS configuration', () => {
          jest.useFakeTimers('legacy');

          const actualConstants = jest.requireActual('../../constants/first-request-inline-styles');
          jest.doMock('../../constants/first-request-inline-styles', () => ({
            ...actualConstants,
            MAX_CONCURRENT_REQUESTS: 2,
          }));

          const data = defaultData;

          const readFile = jest.fn().mockImplementation((filePath, callback) => setTimeout(() => callback(new Error('File not found'))));
          const { mocks: fsMocks } = mockFs({ readFile });

          // hacky workaround because there's no way to flush promises
          // https://github.com/facebook/jest/issues/2157
          const firstGetPromiseMock = {
            __hackyObject: {
              executeFirstThen: (thenData) => {
                const firstThen = firstGetPromiseMock.__hackyObject.firstThenFn;
                if (firstThen) {
                  firstThen(thenData);
                }
              },
              executeSecondThen: (thenData) => {
                const secondThen = firstGetPromiseMock.__hackyObject.secondThenFn;
                if (secondThen) {
                  secondThen(thenData);
                }
              },
            },
            then: (firstThenFn) => {
              firstGetPromiseMock.__hackyObject.firstThenFn = firstThenFn;
              return {
                catch: () => ({
                  then: (secondThenFn) => {
                    firstGetPromiseMock.__hackyObject.secondThenFn = secondThenFn;
                  },
                }),
              };
            },
          };
          const secondGetPromiseMock = new PromiseMock();
          const thirdGetPromiseMock = new PromiseMock();
          const get = jest.fn()
            .mockReturnValueOnce(firstGetPromiseMock)
            .mockReturnValueOnce(secondGetPromiseMock)
            .mockReturnValueOnce(thirdGetPromiseMock);
          const { mocks: restClientMocks } = mockRestClient({ get });

          const firstCallUrl = 'first-url';
          const secondCallUrl = 'second-url';
          const thirdCallUrl = 'third-url';
          const getHref = jest.fn()
            .mockReturnValueOnce(firstCallUrl)
            .mockReturnValueOnce(secondCallUrl)
            .mockReturnValueOnce(thirdCallUrl);
          jest.doMock('../../services/ui-navigation', () => ({ getHref }));

          getFileContent(data);
          const secondRequestData = {
            ...data,
            fileName: 'second-file-name',
          };
          getFileContent(secondRequestData);
          const thirdRequestData = {
            ...data,
            fileName: 'third-file-name',
          };
          getFileContent(thirdRequestData);

          // Assert readFile call
          jest.runOnlyPendingTimers();

          // readFile mock has a setTimeout
          jest.runAllTimers();

          // Assert first rest client call
          expect(getHref).toBeCalledWith(null, data.fileName, data.uiNavigationVersion, data.platformName);
          expect(restClientMocks.get).toBeCalledWith(firstCallUrl, restClientExpectedConfig);

          // Assert second rest client call
          expect(getHref).toBeCalledWith(null, secondRequestData.fileName, secondRequestData.uiNavigationVersion, secondRequestData.platformName);
          expect(restClientMocks.get).toBeCalledWith(secondCallUrl, restClientExpectedConfig);

          // Assert third rest client call was not called
          expect(getHref).not.toBeCalledWith(null, thirdRequestData.fileName, thirdRequestData.uiNavigationVersion, thirdRequestData.platformName);
          expect(restClientMocks.get).not.toBeCalledWith(thirdCallUrl, restClientExpectedConfig);

          const firstFileContent = 'first-file-content';
          firstGetPromiseMock.__hackyObject.executeFirstThen({ data: firstFileContent });
          firstGetPromiseMock.__hackyObject.executeSecondThen();

          // Assert third rest client call was called
          expect(getHref).toBeCalledWith(null, thirdRequestData.fileName, thirdRequestData.uiNavigationVersion, thirdRequestData.platformName);
          expect(restClientMocks.get).toBeCalledWith(thirdCallUrl, restClientExpectedConfig);

          jest.clearAllMocks();

          const secondRequestApiFilePath = getAPIFilePath(secondRequestData);

          // Assert writeFile call not called
          expect(fsMocks.existsSync).not.toBeCalledWith(path.dirname(secondRequestApiFilePath));

          const secondFileContent = 'second-file-content';
          secondGetPromiseMock.resolve({ data: secondFileContent });

          // Assert writeFile call
          expect(fsMocks.existsSync).toBeCalledWith(path.dirname(secondRequestApiFilePath));
          expect(fsMocks.writeFile).toBeCalledWith(secondRequestApiFilePath, secondFileContent, expect.any(Object), expect.any(Function));

          jest.clearAllMocks();

          const thirdRequestApiFilePath = getAPIFilePath(thirdRequestData);

          const thirdFileContent = 'third-file-content';
          thirdGetPromiseMock.resolve({ data: thirdFileContent });

          // Assert writeFile call
          expect(fsMocks.existsSync).toBeCalledWith(path.dirname(thirdRequestApiFilePath));
          expect(fsMocks.writeFile).toBeCalledWith(thirdRequestApiFilePath, thirdFileContent, expect.any(Object), expect.any(Function));

          jest.clearAllMocks();

          // Assert cached results
          const secondRequestContentResult = getFileContent(secondRequestData);
          expect(secondRequestContentResult).toEqual(secondFileContent);

          const thirdRequestContentResult = getFileContent(thirdRequestData);
          expect(thirdRequestContentResult).toEqual(thirdFileContent);

          // Assets no service is called once cached
          expect(fsMocks.existsSync).not.toBeCalled();
          expect(fsMocks.writeFile).not.toBeCalled();
          expect(restClientMocks.get).not.toBeCalled();
          expect(getHref).not.toBeCalled();
          expect(readFile).not.toBeCalled();
        });
      });

      describe('frontend-config update', () => {
        it('should add update handler content on new frontend config environments', () => {
          mockFs();

          getFileContent(defaultData);

          const frontendConfig = require('frontend-config');
          expect(frontendConfig.addUpdateHandler).toBeCalledWith(expect.any(Function), defaultData.environment);
        });

        it('should update files content if frontend-config handler is triggered, removing not used ones and preserving used ones', () => {
          jest.useFakeTimers('legacy');

          /* fs mocks */

          // read file calls before update
          const firstFileContent = 'file-content-1';
          const secondFileContent = 'file-content-2';
          const firstFileBufferToString = jest.fn().mockReturnValueOnce(firstFileContent);
          const secondFileBufferToString = jest.fn().mockReturnValueOnce(secondFileContent);

          // read file calls after update
          const updatedFirstFileContent = `${firstFileContent}-updated`;
          const updatedSecondFileContent = `${secondFileContent}-updated`;
          const updatedFirstFileBufferToString = jest.fn().mockReturnValueOnce(updatedFirstFileContent);
          const updatedSecondFileBufferToString = jest.fn().mockReturnValueOnce(updatedSecondFileContent);

          // readFile mock
          const readFile = jest.fn()
            .mockImplementationOnce((filePath, callback) => setTimeout(() => callback(null, { toString: firstFileBufferToString })))
            .mockImplementationOnce((filePath, callback) => setTimeout(() => callback(null, { toString: secondFileBufferToString })))
            .mockImplementationOnce((filePath, callback) => setTimeout(() => callback(null, { toString: updatedFirstFileBufferToString })))
            .mockImplementationOnce((filePath, callback) => setTimeout(() => callback(null, { toString: updatedSecondFileBufferToString })));

          const { mocks } = mockFs({ readFile });

          /* frontend-config mocks */

          // addUpdateHandler mock
          let updateHandler;
          const addUpdateHandler = jest.fn().mockImplementation((handler) => {
            updateHandler = handler;
          });

          // get mock
          const firstNewUiNavigationVersion = `${defaultData.uiNavigationVersion}-some-modification-1`;
          const secondNewUiNavigationVersion = `${defaultData.uiNavigationVersion}-some-modification-2`;

          const secondPlatformName = `${defaultData.platformName}-2`;

          const secondFileData = {
            ...defaultData,
            fileName: 'other-file-name',
            platformId: 'other-platform-id',
            siteId: 'other-site-id',
            platformName: secondPlatformName,
          };

          // third request uses the same file than second one
          const thirdFileData = {
            ...secondFileData,
            siteId: 'other-site-id-3',
          };
          const get = jest.fn()
            .mockReturnValueOnce(firstNewUiNavigationVersion)
            .mockReturnValueOnce(secondNewUiNavigationVersion)
            .mockReturnValueOnce(thirdFileData.uiNavigationVersion);

          jest.doMock('frontend-config', () => ({
            addUpdateHandler,
            get,
          }));

          /* services/ui-navigation mocks */
          const firstFileData = defaultData;

          const firstPlatformName = firstFileData.platformName;
          const getPlatformName = jest.fn()
            .mockReturnValueOnce(firstPlatformName)
            .mockReturnValueOnce(secondPlatformName);
          jest.doMock('../../services/ui-navigation', () => ({ getPlatformName }));

          // execute for the first time
          getFileContent(firstFileData);
          getFileContent(secondFileData);
          getFileContent(thirdFileData);

          /* first execution assets */
          expect(addUpdateHandler).toBeCalledWith(expect.any(Function), firstFileData.environment);

          // readFile timeouts
          jest.runAllTimers();

          const firstFilePath = getAPIFilePath(firstFileData);
          expect(readFile).toBeCalledWith(firstFilePath, expect.any(Function));
          expect(firstFileBufferToString).toBeCalledWith();

          const secondFilePath = getAPIFilePath(secondFileData);
          const thirdFilePath = getAPIFilePath(thirdFileData);

          // assert file path just in case something changes
          expect(secondFilePath).toBe(thirdFilePath);

          expect(readFile).toBeCalledWith(secondFilePath, expect.any(Function));
          expect(secondFileBufferToString).toBeCalledWith();

          jest.clearAllMocks();

          updateHandler();

          // readFile timeouts
          jest.runAllTimers();

          const updatedFirstFileData = {
            ...firstFileData,
            uiNavigationVersion: firstNewUiNavigationVersion,
          };

          const updatedSecondFileData = {
            ...secondFileData,
            uiNavigationVersion: secondNewUiNavigationVersion,
          };

          const updatedFirstFilePath = getAPIFilePath(updatedFirstFileData);
          expect(readFile).toBeCalledWith(updatedFirstFilePath, expect.any(Function));

          const updatedSecondFilePath = getAPIFilePath(updatedSecondFileData);
          expect(readFile).toBeCalledWith(updatedSecondFilePath, expect.any(Function));

          // should keep cache, so it shouldn't try to read it again
          expect(readFile).not.toBeCalledWith(thirdFilePath, expect.any(Function));

          expect(updatedFirstFileBufferToString).toBeCalledWith();
          expect(updatedSecondFileBufferToString).toBeCalledWith();

          const updatedFirstContentResult = getFileContent(updatedFirstFileData);
          const updatedSecondContentResult = getFileContent(updatedSecondFileData);
          const thirdContentResult = getFileContent(thirdFileData);

          expect(updatedFirstContentResult).toBe(updatedFirstFileContent);
          expect(updatedSecondContentResult).toBe(updatedSecondContentResult);
          expect(thirdContentResult).toBe(secondFileContent);

          expect(mocks.unlink).toBeCalledWith(firstFilePath, expect.any(Function));
          expect(mocks.unlink).not.toBeCalledWith(secondFilePath, expect.any(Function));
        });

        it('should log error if platform name was not found', () => {
          jest.useFakeTimers('legacy');

          /* fs mocks */
          mockFs();

          /* frontend-config mocks */

          // addUpdateHandler mock
          let updateHandler;
          const addUpdateHandler = jest.fn().mockImplementation((handler) => {
            updateHandler = handler;
          });

          // get mock
          jest.doMock('frontend-config', () => ({ addUpdateHandler }));

          /* services/ui-navigation mocks */
          const getPlatformName = jest.fn()
            .mockReturnValue(null);
          jest.doMock('../../services/ui-navigation', () => ({ getPlatformName }));

          const error = jest.fn();
          jest.doMock('../../logger/factory', () => ({ create: jest.fn().mockReturnValue({ error }) }));

          // execute for the first time
          getFileContent(defaultData);

          /* first execution assets */
          expect(addUpdateHandler).toBeCalledWith(expect.any(Function), defaultData.environment);

          // readFile timeouts
          jest.runAllTimers();

          jest.clearAllMocks();

          updateHandler();

          expect(error).toBeCalledWith({
            errorType: 'files-cache-unknown-platform',
            message: `Navigation CSS file cache - Unknown platform ${defaultData.platformId}`,
            tags: {
              platformId: defaultData.platformId,
            },
          });
        });
      });
    });

    describe('local files folder creation', () => {
      it('should not create the folder if it already exists', () => {
        const { mocks } = mockFs();

        require('../../components/css/files-cache');

        expect(mocks.existsSync).toBeCalledWith(filesFolder);
        expect(mocks.mkdirSync).not.toBeCalled();
      });

      it('should not create the folder if it does not exist', () => {
        const existsSync = jest.fn().mockReturnValue(false);
        const { mocks } = mockFs({ existsSync });

        require('../../components/css/files-cache');

        expect(mocks.existsSync).toBeCalledWith(filesFolder);
        expect(mocks.mkdirSync).toBeCalledWith(filesFolder, { "recursive": true });
      });
    });
  });
});
