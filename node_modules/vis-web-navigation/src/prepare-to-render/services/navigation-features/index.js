/* eslint-disable security/detect-object-injection */
const headerSuffixes = ['', '-test'];
const VERSION_SEPARATOR = '=';
const FEATURE_SEPARATOR = ';';
const HEADER_NAME = 'x-navigation-features';

/**
 * Returns a list of features with their versions parsed from the raw navigation
 * feature header. the format from that header is `feature-1=x.x.x;feature-2=x.x.x;`
 * @param {object} headers - key/value with the request headers and their values
 * @param {string} key - header key to retrieve the features from
 */
const getFeatures = (headers, key) => {
  if (headers && headers[key]) {
    const featuresVersions = headers[key].split(FEATURE_SEPARATOR);

    return featuresVersions;
  }

  return [];
};

/**
 * Checks whether the raw feature has a version configured. Format could be `feature-1=x.x.x;`
 * @param {string} feature - raw feature string
 */
const hasSpecificVersionConfigured = feature => feature.indexOf(VERSION_SEPARATOR) !== -1;

/**
 * Returns a key/value object of features with their versions parsed from the raw navigation
 * feature header. the format from that header is `feature-1=x.x.x;feature-2=x.x.x;`
 * @param {object} headers - key/value with the request headers and their values
 * @param {string} headerName - navigation feature header to check
 */
const getFeaturesFromHeader = (headers, headerName) => {
  const features = {};

  /**
   * Navigation features header in production is called `x-navigation-features` but for testing envs,
   * it is called `x-navigation-features-test`. In order to check the version that needs to be used
   * we check both headers to obtain the different versions.
   */
  headerSuffixes.forEach((suffix) => {
    const headerNameWithSuffix = headerName + suffix;
    const featuresVersions = getFeatures(headers, headerNameWithSuffix);

    featuresVersions.forEach((featureString) => {
      if (hasSpecificVersionConfigured(featureString)) {
        const keyValue = featureString.split(VERSION_SEPARATOR);
        const featureKey = keyValue[0];
        const featureVersion = keyValue[1];
        features[featureKey] = featureVersion;
      } else if (featureString.length) {
        features[featureString] = true;
      }
    });
  });

  return features;
};

const overrideDiscountsFeature = (features, platform) => features.discounts && features.discounts.indexOf(platform.siteId) !== -1;

const getNavigationFeatures = (headers, platform) => {
  const features = getFeaturesFromHeader(headers, HEADER_NAME);
  features.discountsEnabled = overrideDiscountsFeature(features, platform);

  return features;
};

module.exports = req => Promise.resolve(getNavigationFeatures(req.headers, req.platform));
