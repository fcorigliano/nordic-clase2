const defaultConfig = require('../../src/defaultConfig');

jest.mock('frontend-config', () => ({
  get: () => {},
}));

describe('StatsD', () => {
  beforeEach(() => {
    jest.resetModules();
    jest.resetAllMocks();
  });

  it('should return an instance of StatsD (hot-shots)', () => {
    const StatsDClientModule = require('hot-shots');
    jest.mock('hot-shots');

    const statsd = require('../../src/statsd');

    expect(statsd).toBeInstanceOf(StatsDClientModule);
  });

  it('should use defaultConfig when no frontendConfig exists', () => {
    const StatsDClientModule = require('hot-shots');
    jest.mock('hot-shots');

    // We need this to execute statsd
    require('../../src/statsd');

    const initializationCall = StatsDClientModule.mock.calls[0];
    const initializationArg = initializationCall[0];
    expect(initializationArg).toEqual(defaultConfig);
  });

  it('should use defaultConfig when no frontendConfig.statsd exists', () => {
    const StatsDClientModule = require('hot-shots');
    jest.mock('hot-shots');

    const mockedProjectConfig = {};

    jest.mock('frontend-config', () => ({
      get: () => mockedProjectConfig,
    }));

    // We need this to execute statsd
    require('../../src/statsd');

    const initializationCall = StatsDClientModule.mock.calls[0];
    const initializationArg = initializationCall[0];

    expect(initializationArg).toEqual(defaultConfig);
  });

  it('should use frontendConfig.statsd over defaultConfig', () => {
    const StatsDClientModule = require('hot-shots');
    jest.mock('hot-shots');

    const mockedProjectConfig = {
      statsd: {
        maxBufferSize: 20000,
      },
    };

    jest.mock('frontend-config', () => ({
      get: key => mockedProjectConfig[key],
    }));

    // We need this to execute statsd
    require('../../src/statsd');

    const initializationCall = StatsDClientModule.mock.calls[0];
    const initializationArg = initializationCall[0];

    expect(initializationArg.maxBufferSize).toEqual(mockedProjectConfig.statsd.maxBufferSize);
  });

  it('should not use frontendConfig.statsd.prefix if it exists', () => {
    const StatsDClientModule = require('hot-shots');
    jest.mock('hot-shots');

    const mockedProjectConfig = {
      statsd: {
        prefix: 'some.datadog.random.name',
      },
    };

    jest.mock('frontend-config', () => ({
      get: key => mockedProjectConfig[key],
    }));

    // We need this to execute statsd
    require('../../src/statsd');

    const initializationCall = StatsDClientModule.mock.calls[0];
    const initializationArg = initializationCall[0];

    expect(initializationArg).not.toEqual(
      expect.objectContaining({ prefix: mockedProjectConfig.statsd.prefix }),
    );
  });

  it('should not allow frontend-config tags to override defaultConfig defined tags', () => {
    const StatsDClientModule = require('hot-shots');
    jest.mock('hot-shots');

    const mockedProjectConfig = {
      statsd: {
        globalTags: {
          platform: 'mi pc',
          application: 'app',
          scope: 'scope',
        },
      },
    };

    jest.mock('frontend-config', () => ({
      get: key => mockedProjectConfig[key],
    }));

    // We need this to execute statsd
    require('../../src/statsd');

    const initializationCall = StatsDClientModule.mock.calls[0];
    const initializationArg = initializationCall[0];

    expect(initializationArg).not.toEqual(
      expect.objectContaining({ globalTags: mockedProjectConfig.statsd.prefix }),
    );
  });

  it('should allow frontend-config to add tags', () => {
    const StatsDClientModule = require('hot-shots');
    jest.mock('hot-shots');

    const mockedProjectConfig = {
      statsd: {
        globalTags: {
          myCustomTag: 'something',
        },
      },
    };

    jest.mock('frontend-config', () => ({
      get: key => mockedProjectConfig[key],
    }));

    // We need this to execute statsd
    require('../../src/statsd');

    const initializationCall = StatsDClientModule.mock.calls[0];
    const initializationArg = initializationCall[0];

    expect(initializationArg.globalTags).toEqual(
      expect.objectContaining({ myCustomTag: mockedProjectConfig.statsd.globalTags.myCustomTag }),
    );
  });

  it('should not use mock when running on Fury', () => {
    const StatsDClientModule = require('hot-shots');
    jest.mock('hot-shots');

    jest.mock('frontend-env', () => ({
      FURY: true,
    }));

    // We need this to execute statsd
    require('../../src/statsd');

    const initializationCall = StatsDClientModule.mock.calls[0];
    const initializationArg = initializationCall[0];

    expect(initializationArg.mock).toBeFalsy();
  });

  it('should use mock when running on CI', () => {
    const StatsDClientModule = require('hot-shots');
    jest.mock('hot-shots');

    jest.mock('frontend-env', () => ({
      IS_CI: true,
    }));

    // We need this to execute statsd
    require('../../src/statsd');

    const initializationCall = StatsDClientModule.mock.calls[0];
    const initializationArg = initializationCall[0];

    expect(initializationArg.mock).toEqual(true);
  });

  it('should use mock when running on build in CI', () => {
    const StatsDClientModule = require('hot-shots');
    jest.mock('hot-shots');

    jest.mock('frontend-env', () => ({
      CI_CONTEXT: 'build',
    }));

    // We need this to execute statsd
    require('../../src/statsd');

    const initializationCall = StatsDClientModule.mock.calls[0];
    const initializationArg = initializationCall[0];

    expect(initializationArg.mock).toEqual(true);
  });

  it('should define globalTags based on env variables', () => {
    const StatsDClientModule = require('hot-shots');
    jest.mock('hot-shots');

    const mockedEnv = {
      PLATFORM: 'platform',
      APPLICATION: 'app',
      SCOPE: 'scope',
    };

    jest.mock('frontend-env', () => (mockedEnv));

    // We need this to execute statsd
    require('../../src/statsd');

    const initializationCall = StatsDClientModule.mock.calls[0];
    const initializationArg = initializationCall[0];

    const expectedGlobalTags = {
      platform: mockedEnv.PLATFORM,
      application: mockedEnv.APPLICATION,
      scope: mockedEnv.SCOPE,
    };

    expect(initializationArg.globalTags).toEqual(
      expect.objectContaining(expectedGlobalTags),
    );
  });

  it('should use maxBufferSize when running on Fury / Production environment', () => {
    const StatsDClientModule = require('hot-shots');
    jest.mock('hot-shots');

    jest.mock('frontend-env', () => ({
      FURY: true,
      PRODUCTION: true,
    }));

    // We need this to execute statsd
    require('../../src/statsd');
    const initializationCall = StatsDClientModule.mock.calls[0];
    const initializationArg = initializationCall[0];

    expect(initializationArg.maxBufferSize).toEqual(8192);
  });

  it('should not use maxBufferSize when running outside Fury / Production environment', () => {
    const StatsDClientModule = require('hot-shots');
    jest.mock('hot-shots');
    jest.mock('frontend-env', () => ({}));

    // We need this to execute statsd
    require('../../src/statsd');
    const initializationCall = StatsDClientModule.mock.calls[0];
    const initializationArg = initializationCall[0];

    expect(initializationArg.maxBufferSize).toEqual(0);
  });
});
