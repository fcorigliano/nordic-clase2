import type { OutgoingHttpHeaders } from 'http';
import type { Request } from 'express';
import type {
  AxiosStatic,
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError,
} from 'nordic-axios';

declare class RetryPolicy {
  static hasToRetry(error: AxiosError): boolean;
}
declare class ServerErrorPolicy extends RetryPolicy {}
declare class IdempotentTimeoutPolicy extends RetryPolicy {}
declare class TransportRetryPolicy extends RetryPolicy {}
declare class NonIdempotentPolicy extends RetryPolicy {}

type RetryPoliciesObject = {
  RetryPolicy: typeof RetryPolicy;
  ServerErrorPolicy: typeof ServerErrorPolicy;
  IdempotentTimeoutPolicy: typeof IdempotentTimeoutPolicy;
  TransportRetryPolicy: typeof TransportRetryPolicy;
  NonIdempotentPolicy: typeof NonIdempotentPolicy;
};

type RetryConfig = false | {
  /**
   * The maximum amount of times to retry.
   * @default 1
   */
  maxRetries?: number;

  /**
   * The number of milliseconds before starting the first retry.
   * @default 0
   */
  delay?: number;

  /**
   * The maximum number of milliseconds between two retries.
   * @default Infinity
   */
  maxDelay?: number;

  /**
   * The type of retries factor to use (disabled by default).
   * @default 1
   */
  factor?: number;

  /**
   * The retry policy to use
   * @default TransportRetryPolicy
   *
   * @example
   * const { RestClient, retryPolicies } = require('frontend-restclient');
   *
   * class CustomPolicy extends retryPolicies.RetryPolicy {
   *   static hasToRetry(error) {
   *     return error.response.status = 429; // Retry only on code 429
   *   }
   * }
   *
   * const request = RestClient({
   *   retry: {
   *     policy: CustomPolicy,
   *   },
   * });
   */
  policy?: RetryPolicy;
};

export interface CacheConfig {
  /**
   * Maximum cache size.
   * @default 500
   */
  maxSize?: number;

  /**
   * Time in seconds after which items will expire.
   * @default Infinity
   */
  maxAge?: number;

  /**
   * Time in seconds, after maxAge has expired, when items are marked as stale but still usable.
   * @default 0
   */
  staleWhileRevalidate?: number;

  // Leave interface open for unknown configs
  [key: string]: unknown;
}

// ETag types taken from stale-lru-cache type defs
// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/8545dff8567f3acf0a93147230f038102809364a/types/stale-lru-cache/index.d.ts#L24-L41
interface SetOptions<K, V> {
  maxAge?: number | undefined;
  staleWhileRevalidate?: number | undefined;
  revalidate?: RevalidationCallback<K, V> | undefined;
}

type OptionsCallback<K, V> = (error: any, value?: V, options?: string | SetOptions<K, V>) => void;
type RevalidationCallback<K, V> = (key: K, callback: OptionsCallback<K, V>) => void;
export interface ETagCacheConfig<K = any, V = any> {
  /**
   * Cache max size.
   * @default 100
   */
  maxSize?: number;
  maxAge?: number;
  staleWhileRevalidate?: number;
  revalidate?: RevalidationCallback<K, V>;
  getSize?(value: V, key: K): number;
}

export interface RestClientConfig extends AxiosRequestConfig {
  /**
   * Indicates that a retry strategy should be used in case a request fails (only for Node).
   *
   * Only applicable for request methods 'GET', 'HEAD' and 'OPTIONS'.
   *
   * By default all of these methods will retry unless specified otherwise with: `retry: false`
   *
   * Please refer to the [retry documentation](https://github.com/mercadolibre/fury_frontend-restclient#retry-strategies-only-for-node) on how to use it.
   *
   * @default { maxRetries: 1, delay: 0, maxDelay: Infinity, factor: 1 }
   */
  retry?: RetryConfig;

  /**
   * Specifies a cache client (only for Node). // Default in-memory cache client.
   */
  cacheClient?: () => any;

  /**
   * Cache configuration to use.
   *
   * Please refer to the [cache documentation](https://github.com/mercadolibre/fury_frontend-restclient#cache-only-for-node) on how to use it.
   *
   * @example
   * request.get('/site_domains/50', {
   *   cache: {
   *     maxAge: 600, // cache from 10 minutes
   *   }
   * }).then((response) => {
   *   console.log(response.data);
   * });
   */
  cache?: CacheConfig;

  /**
   * Specifies if an in-memory cache should be used for ETag header caching (only for Node).
   *
   * Please refer to the [ETag Cache documentation](https://github.com/mercadolibre/fury_frontend-restclient#etag-cache) on how to use it.
   *
   * @default { maxSize: 100 }
   *
   * @example
   * const restclient = require('frontend-restclient');
   *
   * const request = restclient({
   *   eTagCache: { maxSize: 100 },
   * });
   */
  eTagCache?: ETagCacheConfig;
  headers?: OutgoingHttpHeaders;

  /**
   * The request hook is a function that will be executed before the requests are made.
   *
   * @example
   * const request = RestClient({
   *   baseURL: 'https://internal-api.mercadolibre.com/',
   *   requestHook: (requestConfig) => {
   *     // Register some metric on some condition
   *     if (request.headers['generate-addicional-metric']) {
   *       yourMetricFunction();
   *     }
   *   },
   * });
   */
  requestHook?: (config: AxiosRequestConfig) => void;

  /**
   * The request hook is a function that will be executed right after the response is returned.
   *
   * @example
   * const request = RestClient({
   *   baseURL: 'https://internal-api.mercadolibre.com/',
   *   responseHook: (response) => {
   *      console.log('This is your response hook being executed. The response object is:', response)
   *   },
   * });
   */
  responseHook?: <T = any>(response: AxiosResponse<T>) => void;

  /**
   * Indicates if errors should be logged (only for Node).
   *
   * @default true
   */
  logErrors?: boolean;
}

export interface NordicRequestConfig extends Omit<RestClientConfig, 'cacheClient' | 'cache' | 'eTagCache'> {
  /**
   * Meli Context that must be passed in all requests made from our server.
   *
   * Please refer to the [Context documentation](https://github.com/mercadolibre/fury_frontend-restclient#context-only-for-node) on how to use it.
   *
   * @example
   * const restclient = require('frontend-restclient');
   * const buildRestClientContext = require('frontend-restclient/src/build-context');
   *
   * const request = restclient();
   *
   * function fetchData(req, res, next) {
   *   request.get('/site_domains/50', {
   *     context: buildRestClientContext(req), // `req` is the request object avaliable in Express.
   *   });
   * }
   */
  context?: Record<string, string>;

  /**
   * Indicates that the response should be got from cache instead of network (only for Node).
   *
   * @default false
   */
  cache?: boolean;

  /**
   * Indicates that the client should cache responses with the `ETag` header,
   * send the `If-None-Match` header with cached etag on requests,
   * and use cached content on responses with 304 statuses (only for Node).
   *
   * @default true
   */
  eTagCache?: boolean;
}

type HttpMethod = <T = any, R = AxiosResponse<T>>(url: string, config?: NordicRequestConfig) => Promise<R>;
export interface RestClientInstance {
  get: HttpMethod;
  post: HttpMethod;
  put: HttpMethod;
  patch: HttpMethod;
  delete: HttpMethod;
  head: HttpMethod;
  options: HttpMethod;
  purge: HttpMethod;
  all: AxiosStatic['all'];
}

export const RestClient: (config?: RestClientConfig) => RestClientInstance;
export function buildContext(req: Request): Record<string, string>;
export function buildFlowStarterContext(): Record<string, string>;
export const retryPolicies: RetryPoliciesObject;
