# RestClient

> A promise-based RestClient for Node and Browser.

## Installation

```sh
npm install frontend-restclient
```
<br />

## Table of Contents

- [Usage](#usage)
- [API](#api)
- [Response Schema](#response-schema)
- [Handling Errors](#handling-errors)
- [Resquest hook](#request-hook-only-for-node)
- [Response hook](#response-hook-only-for-node)
- [Context (server only)](#Context-only-for-Node)
- [Retry Strategies (server only)](#Retry-Strategies-only-for-Node)
- [Retry policies (server only)](#Retry-policies-only-for-Node)
  - [Usage](#Usage-1)
  - [Implementing a custom retry policy](#Implementing-a-custom-retry-policy)
- [Pool and Agents (server only)](#pool-and-agents-only-for-Node)
- [Downloading data to stream (server only)](#downloading-data-to-stream-only-for-Node)
- [Uploading multipart data](#uploading-multipart-data)
- [Interceptors (server only)](#Interceptors-only-for-Node)
- [Cache (server only)](#Cache-only-for-Node)
  - [Control-Cache](#Control-Cache)
  - [ETag Cache](#ETag-Cache)
- [Cancellation](#Cancellation)

## Usage
```js
/**
 * Module dependencies
 */
const { RestClient, buildContext } = require('frontend-restclient');

// Or the legacy way
const RestClient = require('frontend-restclient');
const buildContext = require('frontend-restclient/src/build-context');

/**
 * Create a new restclient with a custom config
 */
const request = RestClient({
  'baseURL': 'https://internal-api.mercadolibre.com/',
  'timeout': 5000,
});

/**
 * Middleware
 */
exports.fetchData = function fetchData(req, res, next) {
  request.get('/site_domains', {
    'params': {
      'id': 'mercadolibre.com.ar'
    },
    context: buildContext(req), // `req` is the request object avaliable in Express.
  })
    .then((response) => {
      res.locals.data = response.data;
      /*
      {
        "id": "mercadolibre.com.ar",
        "site_id": "MLA",
        "country_id": "AR",
        "locale": "es_AR",
        "tag": "ML"
      }
      */
      next();
    })
    .catch(err => next(err));
};
```

Optionally the request above could also be done as:
```js
request
  .get('/site_domains?id=mercadolibre.com.ar', {
    context: buildContext(req), // `req` is the request object avaliable in Express.
  })
  .then((response) => {
    console.log(response.data);
    /*
      {
        "id": "mercadolibre.com.ar",
        "site_id": "MLA",
        "country_id": "AR",
        "locale": "es_AR",
        "tag": "ML"
      }
    */
  })
  .catch((error) => {
    console.log(error);
  });
```

Performing multiple concurrent requests:
```js
const ar = () => request.get('/site_domains?id=mercadolibre.com.ar');
const br = () => request.get('/site_domains?id=mercadolivre.com.br');

request
  .all([ar(), br()])
  .then((res) => {
    console.log(res[0].data);
    /*
      {
        "id": "mercadolibre.com.ar",
        "site_id": "MLA",
        "country_id": "AR",
        "locale": "es_AR",
        "tag": "ML"
      }
    */

    console.log(res[1].data);
    /*
      {
        "id": "mercadolivre.com.br",
        "site_id": "MLB",
        "country_id": "BR",
        "locale": "pt_BR",
        "tag": "ML"
      }
    */
  });
```

## API

### Instance and request config
You are able to configure a RestClient instance or a particular request with custom `config`.

The `config` will be merged with an order of precedence. The order is library defaults found in `config/defaults.js`, then defaults property of the instance, and finally config argument for the request. The latter will take precedence over the former.

```js
const request = RestClient(config); // Instance config (used to all request).
```

```js
const request = RestClient();
request.get(url, config); // Request config.
```

These are the available `config` for making requests:

```js
const configExample = {
  // `baseURL` will be prepended to `url` unless `url` is absolute.
  // It can be convenient to set `baseURL` for an instance of RestClient to pass relative URLs
  // to methods of that instance.
  baseURL: 'http://internal.mercadolibre.com' || 'https://internal-api.mercadolibre.com', // defaults

  // `headers` are custom headers to be sent
  headers: {
    // gzip compression by default
    // compression can be disabled configuring 'accept-encoding': ''
    'accept-encoding': 'gzip'
  },

  // `params` are the URL parameters to be sent with the request
  // Must be a plain object or a URLSearchParams object
  params: {
    ID: 12345
  },

  // `data` is the data to be sent as the request body
  // Only applicable for request methods 'PUT', 'POST', and 'PATCH'
  // When no `transformRequest` is set, must be of one of the following types:
  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
  // - Browser only: FormData, File, Blob
  // - Node only: Stream, Buffer
  data: {
    firstName: 'Fred'
  },

  // `timeout` specifies the number of milliseconds before the request times out.
  // If the request takes longer than `timeout`, the request will be aborted.
  timeout: 3000, // default

  // `responseType` indicates the type of data that the server will respond with
  // options are 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'
  responseType: 'json', // default

  // `maxRedirects` defines the maximum number of redirects to follow in node.js.
  // If set to 0, no redirects will be followed.
  maxRedirects: 0, // default

  // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http
  // and https requests, respectively, in node.js.
  httpAgent: new http.Agent({
    keepAlive: true,
    keepAliveMsecs: 1000,
    maxSockets: 100,
    maxFreeSockets: 50,
  }),
  httpsAgent: new https.Agent({
    keepAlive: true,
    keepAliveMsecs: 2000,
    maxSockets: 100,
    maxFreeSockets: 60,
  }),

  // `retry` indicates that a retry strategy should be used in case a request fails (only for Node).
  // Only applicable for request methods 'GET', 'HEAD' and 'OPTIONS'.
  // By default all of these methods will retry unless specified otherwise with: `retry: false`
  retry: {
    maxRetries: 1, // The maximum amount of times to retry. // default
    delay: 0, // The number of milliseconds before starting the first retry. // default
    maxDelay: Infinity, // The maximum number of milliseconds between two retries. // default
    factor: 1, // The type of retries factor to use (disabled by default). // default
    policy: TransportRetryPolicy // The retry policy to be used // default
  },

  // `cacheClient` specifies a cache client (only for Node). // Default in-memory cache client.
  cacheClient: Function,

  // `requestHook` is a function that will be run before the requests
  requestHook: function(request) {
    // Do something usefull here
  },

  // `responseHook` is a function that will be run after the response is given
  responseHook: function(response) {
    // Do something usefull here
  },,

  // `eTagCache` specifies if an in-memory cache should be used for ETag header caching (only for Node).
  eTagCache: true,

  // `auth` indicates that HTTP Basic auth should be used, and supplies credentials.
  // This will set an `Authorization` header, overwriting any existing
  // `Authorization` custom headers you have set using `headers`.
  auth: {
    username: 'janedoe',
    password: 's00pers3cret'
  },

  // 'proxy' defines the hostname and port of the proxy server
  // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and
  // supplies credentials.
  // This will set an `Proxy-Authorization` header, overwriting any existing
  // `Proxy-Authorization` custom headers you have set using `headers`.
  proxy: {
    host: '127.0.0.1',
    port: 9000,
    auth: {
      username: 'mikeymike',
      password: 'rapunz3l'
    }
  },

  // `maxContentLength` defines the max size of the http response content allowed
  maxContentLength: 2000,

  // `onUploadProgress` allows handling of progress events for uploads
  onUploadProgress: function (progressEvent) {
    // Do whatever you want with the native progress event
  },

  // `onDownloadProgress` allows handling of progress events for downloads
  onDownloadProgress: function (progressEvent) {
    // Do whatever you want with the native progress event
  },

  // `transformRequest` allows changes to the request data before it is sent to the server
  // This is only applicable for request methods 'PUT', 'POST', and 'PATCH'
  // The last function in the array must return a string or an instance of Buffer, ArrayBuffer,
  // FormData or Stream
  transformRequest: [function (data) {
    // Do whatever you want to transform the data

    return data;
  }],

  // `transformResponse` allows changes to the response data to be made before
  // it is passed to then/catch
  transformResponse: [function (data) {
    // Do whatever you want to transform the data

    return data;
  }],

  // `validateStatus` defines whether to resolve or reject the promise for a given
  // HTTP response status code. If `validateStatus` returns `true` (or is set to `null`
  // or `undefined`), the promise will be resolved; otherwise, the promise will be
  // rejected.
  validateStatus: function (status) {
    return status >= 200 && status < 300; // default
  },

  // `cancelToken` specifies a cancel token that can be used to cancel the request
  // (see Cancellation section below for details)
  cancelToken: new CancelToken(function (cancel) { ... }),

  // `sendCSRFToken` specifies whether to set the x-csrf-token header or not
  sendCSRFToken: true,

  // allows to disable the error log
  logErrors: true //default
}
```

### RestClient#get(url [, config])
### RestClient#delete(url [, config])
### RestClient#head(url [, config])
### RestClient#post(url [, config]])
### RestClient#put(url[, config]])
### RestClient#patch(url[, config]])

- `url` is the server URL that will be used for the request. Only the `url` is required.
- `config` is optional. These are the available `config` only to use in requests:

```js
const instanceConfig = {
  // `cache` indicates that the response should be got from cache instead of network (only for Node).
  cache: false, // default

  // `eTagCache` indicates that the client should cache responses with the `ETag` header, send the `If-None-Match` header with cached etag on requests, and use cached content on responses with 304 statuses (only for Node).
  eTagCache: false, // default

  // `context` defines a valid and unique id for each request.
  // `context.requestId` must be a valid `uuid/v4`.
  // You shoud use the helpers `buildContext(req)` or `buildFlowStarterContext()`.
  context: buildContext(req),

  // allows to disable the error log
  logErrors: true //default
}
```

### RestClient#all([...request]])
A method for dealing with concurrent requests.

```js
const getUserAccount = () => request.get('/user');
const getUserPermissions = () => request.get('/permissions');
request.all([getUserAccount(), getUserPermissions()])
  .then((responses) => {
    // Both requests are now complete
    console.log(responses) // [ reponseUserAccount, responseUserPermissions ]
});
```

## Response schema
The response for a request contains the following information.

```json
{
  // `data` is the response that was provided by the server
  "data": {},

  // `status` is the HTTP status code from the server response
  "status": 200,

  // `statusText` is the HTTP status message from the server response
  "statusText": "OK",

  // `headers` the headers that the server responded with
  "headers": {},

  // `config` is the config that was provided for the request
  "config": {},

  // `retries` is the quantity of retries done to achieve a successful response
  "retries": 0
}
```

## Handling Errors
If the requests generate an error with status code > 500, the restclient automatically triggers an error log with the error data. In development environments it is triggered for all status codes in order to have more information about the error to help troubleshooting.

Additionally a throw of the error is made so that it can be handled from the consumer.

```js
request
  .get('/site_domains/50')
  .catch( (error) => {
    if (error.response) {
      // The request was made, but the server responded with a status code
      // that falls out of the range of 2xx
      console.log(error.response.data);
      console.log(error.response.status);
      console.log(error.response.statusText);
      console.log(error.response.headers);
    } else {
      // Something happened in setting up the request that triggered an Error
      console.log('Error', error.message);
    }
  });
```

## Request hook (only for node)

The request hook is a function that will be executed before the requests are made. To use a request hook you just need to pass your function in the config object, for example:

```js
const request = RestClient({
  baseURL: 'https://internal-api.mercadolibre.com/',
  timeout: 5000,
  requestHook: function(requestConfig) {
    console.log('This is your request hook being executed. The config object is:', requestConfig)
  }
});
```

A simple use case, is for example if we had to register a metric when some header is present:

```js
const request = RestClient({
  baseURL: 'https://internal-api.mercadolibre.com/',
  timeout: 5000,
  requestHook: function(requestConfig) {
    if (requestConfig.method === 'get') {
      yourMetricFunction({ url: requestConfig.url })
    }
  }
});
```

## Response hook (only for node)

The request hook is a function that will be executed right after the response is returned. To use a response hook you just need to pass your function in the config object, for example:

```js
const request = RestClient({
  baseURL: 'https://internal-api.mercadolibre.com/',
  timeout: 5000,
  responseHook: function(response) {
    console.log('This is your response hook being executed. The response object is:', response)
  }
});
```

## Context (only for Node)
The `context` will be use internally for the RestClient to set headers like `X-Request-Id` to trace a HTTP request across Meli infrastructure.

You must use `buildContext(req)` or `buildFlowStarterContext()` helpers to create a new `context` object for each request you made.

**Note: The `context` option will be mandatory to make a request in a future.**

The `buildContext(req)` should be use in Express applications to create a new `context` from `req` object.

```js
// controller.js
const { RestClient, buildContext } = require('frontend-restclient');

// Create an instance
const request = RestClient();

exports.fetchData = function fetchData(req, res, next) {
  request.get('/site_domains/50', {
    context: buildContext(req), // `req` is the request object avaliable in Express.
  })
    .then((response) => {
      res.locals.data = response.data;
      next();
    })
    .catch(err => next(err));
};
```

The `buildFlowStarterContext()` should be used in internal libraries/modules without Express.

```js
const { RestClient, buildFlowStarterContext } = require('frontend-restclient');

// Create an instance
const request = RestClient();

request.get('/site_domains/50', {
  context: buildFlowStarterContext();
});
```

## Retry Strategies (only for Node)

The RestClient provides retry strategies that allows you to define the time interval between each attempt.

**Note:** _By default, the simple retry strategy is used in association to the TransportRetryPolicy. If you want to turn it off just pass `{ retry: false }`_

You can use two basic strategies:

### Simple Retry

It will just retry for a fixed number of times and wait for a fixed interval between runs:

```js
const request = RestClient();

request.get('/site_domains/50', {
  retry: {
    maxRetries: 3, // The maximum amount of times to retry. Default: 1.
    delay: 500, // The number of milliseconds to wait before starting each retry. Default : 0.
  },
});
```
### Exponential Backoff Retry

It will increase wait time between retries between a delay and a max delay value, growing exponentially between runs:

```js
const request = RestClient();

request.get('/site_domains/50', {
  retry: {
    delay: 500, // The number of milliseconds before starting the first retry.
    maxDelay: 5000, // The maximum number of milliseconds between two retries.
    factor: 2, // The exponential factor to use.
  },
});
```

### Turning off retry

```js
const request = RestClient({
  retry: {
    maxRetries: 5,
  },
});

// It won't execute any retries:
request.get('/site_domains/50', { retry: false });
```

You can also disable retries using the instance config:
```js
const request = RestClient({
  retry: false,
});

// It won't execute any retries:
request.get('/site_domains/50');
```
**Note:** _If the request config specifies to use retry, the instance config will be ignored and the request config will prevail.`_

## Retry policies (only for Node)
The retry policies stablish indicates when a request should be retried. The RestClient provide a bunch of retry policies, by default the `TransportRetryPolicy` is used.
### Policies
#### ServerErrorPolicy
Only for GET, HEAD, and OPTIONS request methods. Makes a retry only if error status is >= 500.
#### IdempotentTimeoutPolicy
Only for GET, HEAD, and OPTIONS request methods. Makes a retry only if the connection or read timeouts are exceeded.
#### NonIdempotentPolicy
Only for POST, LOCK, PATCH and DELETE request methods. Makes a retry only if the connection or read timeouts are exceeded.
#### TransportRetryPolicy
Default retry policy. Combines IdempotentTimeoutPolicy and ServerErrorPolicy.
#### CustomRetryPolicy
This feature allows you to define your own retry policy, take a look at the [usage](#Implementing-a-custom-retry-policy) examples.
### <strong>Usage</strong>
To use any of the supported policies you need to import the `retryPolicies`.
```js
const { RestClient, retryPolicies } = require('frontend-restclient');

const request = RestClient({
  retry: {
    maxRetries: 5,
    delay: 500,
    policy: retryPolicies.ServerError, // Set the default policy as `ServerError`
  },
});

// If a server error occurs (status >= 500), the RestClient will retry up to 5 times
request.get('/site_domains/50');
```
You can also overwrite the policy stabilished on the instance config:

```js
const request = RestClient({
  retry: {
    maxRetries: 5,
    delay: 500,
    policy: retryPolicies.ServerError, // Set the default policy as `ServerError`
  },
});

// It will retry only on server errors since is using instance config
request.get('/site_domains/50');

// It will only retry on timeouts
request.get('/site_domains/50', {
  retry: {
    // Set the current request policy as `IdempotentTimeoutPolicy`
    policy: retryPolicies.IdempotentTimeoutPolicy,
  }
});

```
### Implementing a custom retry policy
To implement a custom retry policy you have to create a class that fulfill those requirements:
- Extends from `RetryPolicy`
- Implement the `hasToRetry` method (this method should return a truthy or falsy value that will specify wheter to retry or not)
```js
const { RestClient, retryPolicies } = require('frontend-restclient');

class MyCustomRetryPolicy extends retryPolicies.RetryPolicy {
  static hasToRetry(error) {
    // Here goes all your logic
    // Let's suppose we want a mix of ServerError and NonIdempotent:
    return retryPolicies.ServerError || retryPolicies.NonIdempotentPolicy
  }
}

// Now we just need to use it
const request = RestClient({
  retry: {
    maxRetries: 5,
    delay: 500,
    policy: MyCustomRetryPolicy, // Set the default policy as `ServerError`
  },
});

// It will retry on server errors or on non idempotent requests
request.get('/site_domains/50');

```

## Pool and Agents (only for Node)
In Node, an Agent is responsible for managing connection persistence and reuse for HTTP clients.

The HTTP Agent is used for pooling sockets used in HTTP client requests. You can configure this using the `httpAgent` and `httpsAgent` to define a custom agent to be used when performing http and https requests.

You can read more about how works pool in node in the [http.Agent documentation](https://nodejs.org/api/http.html#http_class_http_agent).

```js
/**
 * Module dependencies
 */
const { RestClient } = require('frontend-restclient');
const http = require('http');
const https = require('https');

/**
 * Create an instance with custom agents
 */
const request = RestClient({
  httpAgent: new http.Agent({
    keepAlive: true,
    keepAliveMsecs: 1000,
    maxSockets: 100,
    maxFreeSockets: 50,
  }),

  httpsAgent: new https.Agent({
    keepAlive: true,
    keepAliveMsecs: 2000,
    maxSockets: 100,
    maxFreeSockets: 60,
  }),
});
```

Also, you can use a different http agent for a particular request:

```js
request.get('/particular', {
  httpAgent: new http.Agent({
    keepAlive: true,
    keepAliveMsecs: 1000,
    maxSockets: 100,
    maxFreeSockets: 50,
  }),

  httpsAgent: new https.Agent({
    keepAlive: true,
    keepAliveMsecs: 2000,
    maxSockets: 100,
    maxFreeSockets: 60,
  }),
});
```

## Downloading data to stream (only for Node)

To download data to stream, just configure the header  `accept-encoding: ''` and the `responseType: 'stream'` to make your request.

```js
/**
 * Module dependencies
 */
const { RestClient } = require('frontend-restclient');

/**
 * Create an instance
 */
const request = RestClient();

request
  .get('https://mla-s1-p.mlstatic.com/700515-MLA25252109535_122016-M.jpg', {
    headers: {
      'accept-encoding': '', // disable gzip
    },
    responseType: 'stream',
  })
  .then((response) => {
    // In Express middleware
    res.append('content-type', response.headers['content-type']);
    res.append('content-disposition', response.headers['content-disposition']);
    response.data.pipe(res);
  });
```

## Uploading multipart data

To upload multipart data, you should use the [`form-data`](https://github.com/form-data/form-data) module and make your request.

```js
/**
 * Module dependencies
 */
const FormData = require('form-data');
const { RestClient } = require('frontend-restclient');

/**
 * Create an instance
 */
const request = RestClient();

/**
 * Create a FormData
 */
const form = new FormData();
form.append('my_field', 'my value');

// Create Content-Type header
const contentTypeHeader = 'multipart/form-data; boundary='+ form.getBoundary();

/**
 * Make request
 */
request.post('/multipart-form', {
  headers: { 'Content-Type': contentTypeHeader },
  data: form,
})
.then(response => {
  console.log('done');
});
```

## Interceptors (only for Node)

You can intercept requests or responses before they are handled by then or catch.

```js
/**
 * Module dependencies
 */
const { RestClient } = require('frontend-restclient');

/**
 * Create an instance
 */
const request = RestClient();

// Add a request interceptor
request.client.interceptors.request.use((config) => {
    // Do something before request is sent
    return config;
  }, (error) => {
    // Do something with request error
    return Promise.reject(error);
  });

// Add a response interceptor
request.client.interceptors.response.use((response) => {
    // Do something with response data
    return response;
  }, (error) => {
    // Do something with response error
    return Promise.reject(error);
  });
```

# Cache (only for Node)

By default the restclient won't use any cache. There are two different types of cache: `Control-Cache` which can use either stale-lru/kvs/memcached and `ETag`.

## Control-Cache
If you need to use Control-Cache then we count with three different types of cache's that are built-in to be used on `get` requests:
- [In memory: Stale LRU Cache](#In-Memory---Stale-LRU-Cache)
- [KVS Cache](#KVSCache)
- [Fury Cache (memcached)](#FuryCache-client)

### Shared Interface
Each cache has these defined methods:
- `get(key)`
- `set(key, value, maxAgeHeader)`
- `delete(key)`

**Note:** How each cache client is instantiated depends on which type of cache you're using, please refer to the specific cache information in this doc.

#### Keys
Keys are composed as follows:

``` ${HTTPMethod}-${url}-${stringifiedParams} ```

Since this information oftentimes exceeds the 250 chars restrain keys have, each key **is hashed with md5**.

### In Memory - Stale LRU Cache
This in-memory cache is based on [stale-lru-cache](https://github.com/cyberthom/stale-lru-cache) and integrated into the restclient. The cache only will be applied to `GET` methods using the value of the header `cache-control` or a custom `maxAge`. For more information about the cache-control header, refer to [cache-control](#cache-control-in-the-in-memory-cache).

To use it you can just enable it on the specific call you want to be cached:
```js
request
  .get('/site_domains/50', { cache: true })
```

**Note:** _The cache is disabled by default._

#### Cache-Control in the In Memory Cache
- `max-age=600`, `must-revalidate` - Will be cached for 10 minutes and removed afterwards.
- `max-age=600`, `stale-while-revalidate=86400` - Will be cached for 10 minutes and then refreshed in the background if the item is accessed again within a time window of 1 day.
- `max-age=0` - Will not be cached.
- `public` - Will be cached using default maxAge and staleWhileRevalidate options.
- `no-cache`, `no-store`, `must-revalidate` - Will not be cached.
- `private` - Will not be cached.

For more information about `cache-control` you can take a look [here](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9) and [here](https://tools.ietf.org/html/rfc5861), or the [MDN Docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control).

##### Override `cache-control` behaviour:
You can override the `cache-control` header behaviour using a custom `cache` configuration:

- `maxSize`: Maximum cache size (default: 500).
- `maxAge`:  Time in seconds after which items will expire (default: Infinity).
- `staleWhileRevalidate`: Time in seconds, after maxAge has expired, when items are marked as stale but still usable (default: 0).

```js
request
  .get('/site_domains/50', {
    cache: {
      maxAge: 600, // cache from 10 minutes
    }
  })
  .then((response) => {
    console.log(response.data);
  });
```

### FuryCache Client
You can use the Fury cache client built-in. First of all you have to create a [Cache Cluster](https://docs.furycloud.io/?lang=esp&section=cache) in Fury.
After that you should pass the FuryCache as cacheClient option.

```js
const env = require('frontend-env');
const { RestClient } = require('frontend-restclient');
const { FuryCache } = require('frontend-restclient/furycache');

const request = RestClient({
  cacheClient: () => new FuryCache({
    nodesEndpoint: env.CACHE_YOURCACHENAME_NODES_ENDPOINT, // Required. You should put the name of the env variable that fury set for your cache cluster
  }),
});
```

To use it you can just enable it on the specific call you want to be cached as follows:
```js
request
  .get('/site_domains/50', { cache: true })
```
Note that it will use the `max-age` defined in the request `cache-control` header


If you want to use an specific maxAge:
```js
request
  .get('/site_domains/50', {
    cache: {
      maxAge: 10000 // Time in seconds
    }
  })
```

#### FuryCache Default Config
None. You can pass memcached parameters to FuryCache. See [documentation](https://github.com/3rd-Eden/memcached) for more details.

### KVSCache
You can use the KVS cache client built-in. First of all you have to create a [Key-Value Store](https://docs.furycloud.io/?lang=esp&section=keyval) in Fury.
After that you should pass the KVSCache as cacheClient option.

```js
const env = require('frontend-env');
const { RestClient } = require('frontend-restclient');
const { KVSCache } = require('frontend-restclient/kvscache');

const request = RestClient({
  cacheClient: () => new KVSCache({
    container: 'your_container', // Required
  }),
});
```

To use it you can just enable it on the specific call you want to be cached as follows:
```js
request
  .get('/site_domains/50', { cache: true })
```
Note that it will use the `max-age` defined in the request `cache-control` header


If you want to use an specific maxAge:
```js
request
  .get('/site_domains/50', {
    cache: {
      maxAge: 10000 // Time in seconds
    }
  })
```

#### KVSCache Default Config
```js
  version: '',
  readTimeout: 150,
  writeTimeout: 3000,
```

You can override this default config by just instantiating the KVSCache with the desired values.

Example overriding default config:
```js
const request = RestClient({
  cacheClient: () => new KVSCache({
    container: 'your_container', // Required
    readTimeout: 50,
    writeTimeout: 2000,
  }),
});
```

## ETag Cache
The [`ETag` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) can be used to avoid unnecessary traffic over a network when requesting [unchanged resources](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag#Caching_of_unchanged_resources). It will always use an in-memory cache, otherwise it will generate traffic to other endpoint, loosing the advantages of this technique.

In order to use it you have to pass the `eTagCache` configuration with a truthy value:

```js
const { RestClient } = require('frontend-restclient');

const request = RestClient({
  eTagCache: true,
});
```

### Memory consumption
As it uses an in-memory cache, make you sure you use it with non-dynamic calls such as static assets. Using it with dynamic calls (eg: calls that depend on the user, item, etc) can lead the application to consume too much RAM because of unnecessary cached responses.

There's an option to pass a configuration object on the `eTagCache` configuration. If you want to use it with dynamically generated url make you sure to set a limit setting a `maxSize` property on the configuration object, that will be passed to our in-memory cache (Stale LRU Cache):

```js
const { RestClient } = require('frontend-restclient');

const request = RestClient({
  eTagCache: {
    maxSize: 100,
  },
});
```

## Cancellation

You can cancel a request using a *cancel token*.

You can create a cancel token using the `CancelToken.source` factory as shown below:

```js
const { RestClient } = require('frontend-restclient');
const { CancelToken, isCancel } = require('frontend-restclient/cancel');

/**
 * Create a new restclient
 */
const request = RestClient();

/**
 * Create a new CancelToken source
 */
const source = CancelToken.source();

request.get('/user/12345', {
  cancelToken: source.token
}).catch(function(thrown) {
  if (isCancel(thrown)) {
    console.log('Request canceled', thrown.message);
  } else {
    // handle error
  }
});

request.post('/user/12345', {
  cancelToken: source.token,
  data: { name: 'new name' },
});

// cancel the request (the message parameter is optional)
source.cancel('Operation canceled by the user.');
```

You can also create a cancel token by passing an executor function to the `CancelToken` constructor:

```js
const { RestClient } = require('frontend-restclient');
const { CancelToken } = require('frontend-restclient/cancel');

/**
 * Create a new restclient
 */
const request = RestClient();

let cancel;

request.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // An executor function receives a cancel function as a parameter
    cancel = c;
  })
});

// cancel the request
cancel();
```

> Note: you can cancel several requests with the same cancel token.

## Avoid sending CSRF Token Header

In some cases (for example a cross origin request) you might not want to send the header `x-csrf-token` inside an specific request or all of them (disabling the header for all requests may be considered as a bad practice from the security point of view).

In order to do this, you should use the config flag `sendCSRFToken` when you create your restclient instance or for an specific request. _Default value for this flag is `true`._

### Request level turn off

```js
const { RestClient } = require('frontend-restclient');

/**
 * Create a new restclient
 */
const request = RestClient();

request.post('/users', {
  sendCSRFToken: false,
});
```

### Instance level turn off

```js
const { RestClient } = require('frontend-restclient');

/**
 * Create a new restclient
 */
const request = RestClient({
  sendCSRFToken: false,
});

request.post('/users');
```

## License

Copyright © 2016.
