"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Module dependencies
 */
var axios = require('nordic-axios');

var defaults = require('../config/defaults.browser');
/**
 * RestClient class to create a new instance of axios with a custom config.
 * @param config Object
 * @see https://github.com/mzabriskie/axios#request-config
 */


var RestClient = /*#__PURE__*/function () {
  function RestClient() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, RestClient);

    this.config = _objectSpread(_objectSpread({}, defaults), config);
    this.client = axios.create(this.config);
    return this;
  }
  /**
   * Checks if metaTag with csrf token exists and add its content to x-csrf-token header.
   * @param config Object
   * @param config.headers Object
   */


  _createClass(RestClient, [{
    key: "addCSRFHeaderIfApplies",
    value: function addCSRFHeaderIfApplies() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (typeof window !== 'undefined') {
        var csrfEnabled = config.sendCSRFToken !== undefined ? config.sendCSRFToken : this.config.sendCSRFToken;
        var csrfTokenFromMetaTag = document.querySelector('meta[name=csrf-token]');
        var token = csrfTokenFromMetaTag && csrfTokenFromMetaTag.hasAttribute('content') ? csrfTokenFromMetaTag.getAttribute('content').trim() : ''; // avoid overwriting the header if it already exists

        if (config.headers && config.headers['x-csrf-token'] || this.config.headers && this.config.headers['x-csrf-token']) {
          return;
        } // do not add the header if disabled by config or token not found


        if (csrfEnabled && token.length) {
          config.headers = _objectSpread(_objectSpread({}, config.headers), {}, {
            'x-csrf-token': csrfTokenFromMetaTag.getAttribute('content')
          });
        }
      }
    }
    /**
     * Makes a request with a given method, url, and config and returns a promise.
     * @param config Object
     * @param config.method String
     * @param config.url String
     * @param config.config String
     * @param config.headers Object
     * @see https://github.com/mzabriskie/axios#request-config
     */

  }, {
    key: "doRequest",
    value: function doRequest() {
      var _this = this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.addCSRFHeaderIfApplies(config); // Prepare a new request

      var request = function request() {
        return _this.client.request(config) // Catch the error to log and throw an error, which triggers the next
        // reject handler in the chain to be called.
        ["catch"](function (error) {
          throw error;
        });
      }; // Make request


      return request();
    }
    /**
     * Alias to make a GET request and returns a promise.
     * @param url String
     * @param config Object
     * @see https://github.com/mzabriskie/axios#request-config
     */

  }, {
    key: "get",
    value: function get(url) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      config.method = 'get';
      config.url = url;
      return this.doRequest(config);
    }
    /**
     * Alias to make a POST request and returns a promise.
     * @param url String
     * @param config Object
     * @see https://github.com/mzabriskie/axios#request-config
     */

  }, {
    key: "post",
    value: function post(url) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      config.method = 'post';
      config.url = url;
      return this.doRequest(config);
    }
    /**
     * Alias to make a PUT request and returns a promise.
     * @param url String
     * @param config Object
     * @see https://github.com/mzabriskie/axios#request-config
     */

  }, {
    key: "put",
    value: function put(url) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      config.method = 'put';
      config.url = url;
      return this.doRequest(config);
    }
    /**
     * Alias to make a PATCH request and returns a promise.
     * @param url String
     * @param config Object
     * @see https://github.com/mzabriskie/axios#request-config
     */

  }, {
    key: "patch",
    value: function patch(url) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      config.method = 'patch';
      config.url = url;
      return this.doRequest(config);
    }
    /**
     * Alias to make a DELETE request and returns a promise.
     * @param url String
     * @param config Object
     * @see https://github.com/mzabriskie/axios#request-config
     */

  }, {
    key: "delete",
    value: function _delete(url) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      config.method = 'delete';
      config.url = url;
      return this.doRequest(config);
    }
    /**
     * Alias to make a HEAD request and returns a promise.
     * @param url String
     * @param config Object
     * @see https://github.com/mzabriskie/axios#request-config
     */

  }, {
    key: "head",
    value: function head(url) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      config.method = 'head';
      config.url = url;
      return this.doRequest(config);
    }
    /**
     * Alias to make an OPTIONS request and returns a promise.
     * @param url String
     * @param config Object
     * @see https://github.com/mzabriskie/axios#request-config
     */

  }, {
    key: "options",
    value: function options(url) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      config.method = 'options';
      config.url = url;
      return this.doRequest(config);
    }
    /**
     * Alias to make a PURGE request and returns a promise.
     * @param url String
     * @param config Object
     * @see https://github.com/mzabriskie/axios#request-config
     */

  }, {
    key: "purge",
    value: function purge(url) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      config.method = 'purge';
      config.url = url;
      return this.doRequest(config);
    }
    /**
     * It makes concurrent requests that combines multiple promises and returns
     * a collection of responses.
     * @param requests Object
     * @see https://github.com/mzabriskie/axios#concurrency
     */

  }, {
    key: "all",
    value: function all(requests) {
      return axios.all(requests).then(axios.spread(function () {
        for (var _len = arguments.length, response = new Array(_len), _key = 0; _key < _len; _key++) {
          response[_key] = arguments[_key];
        }

        return response;
      }))["catch"](function (error) {
        throw error;
      });
    }
  }]);

  return RestClient;
}();

function restclientFactory(config) {
  return new RestClient(config);
}
/**
 * Expose RestClient factory
 */


exports = module.exports = restclientFactory; // eslint-disable-line no-multi-assign

exports.RestClient = restclientFactory;
