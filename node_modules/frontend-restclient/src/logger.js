/**
 * RestClient logger instance
 */
const logger = require('frontend-logger')('restclient');
const env = require('frontend-env');

/**
 * Store previous logger.error method
 */
const logError = logger.error;

/**
 * Rewrite logger.error method
 */
logger.error = function loggerError(error) {
  const tags = {};

  if (error.config) {
    tags.method = error.config.method;
    tags.url = error.config.url;
    tags.timeout = error.config.timeout;

    if (error.config.retry) {
      // We'll only log this if there's actually a retry attempt (not the first op call)
      if (error.config.headers && error.config.headers['x-retry'] > 0) {
        tags.retryAttempt = error.config.headers['x-retry'];
      }

      tags.maxRetries = error.config.retry.maxRetries;
    }
  }

  // Errors with a response
  if (error.response) {
    if (error.response.status < 500 && !env.DEVELOPMENT) {
      return;
    }
    tags.statusCode = error.response.status;
    tags.statusText = error.response.statusText;

    if (error.response.data) {
      tags.responseData = error.response.data;
    }
  // Errors without a response.
  } else {
    tags.statusCode = error.code;
    // eslint-disable-next-line no-multi-assign
    tags.statusText = error.statusText = error.message;
  }

  logError.call(this, error.message, tags);
};

const logErrorIfApply = (error, requestConfig = {}, instanceConfig = {}) => {
  const config = { ...instanceConfig, ...requestConfig };
  const { logErrors } = config;

  const hasToLogErrors = typeof logErrors === 'undefined' ? true : logErrors;

  if (hasToLogErrors) {
    logger.error(error);
  }
};

/**
 * Expose logger
 */
module.exports = { logger, logErrorIfApply };
