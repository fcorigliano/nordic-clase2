const crypto = require('crypto');
const { logger } = require('./logger');
const defaults = require('../config/defaults');
const {
  ETAG,
  IF_NONE_MATCH,
} = require('./constants/headers');

/**
 * Cache header constants
 */
const CACHE_STATUS = {
  HIT: 'HIT',
  MISS: 'MISS',
};

/**
 * getMaxAge function to get the maxage depending on the received param
 * @param method String
 * @param url String
 * @param params Object
 */
function getMaxAge(options) {
  if (typeof options === 'object') {
    return options.maxAge || null;
  }
  if (typeof options === 'string') {
    const maxAge = options.match(/max-age=(\d+)/);
    return maxAge ? parseInt(maxAge[1], 10) : null;
  }

  return null;
}

/**
 * createCacheKey function to create a key to use in cache.
 * @param method String
 * @param url String
 * @param params Object
 */
function createCacheKey(method, url, params) {
  const key = [method, url, JSON.stringify(params)].join('-').replace(/\s+/g, '-');
  const md5Key = crypto.createHash('md5').update(key).digest('hex');

  return md5Key;
}

/**
 * Removes properties that causes circular references from a response
 * @param {object} res Request response
 * @returns {object} Request response
 */
const removeCircularReferences = (res) => {
  delete res.request;
  delete res.config;
  return res;
};

/**
 * Indicates if the eTagCache property of a configuration is an object
 * @param {object} config Client/Request configuration
 * @returns {boolean} True if the eTagCache property of the configuration is an object
 */
const hasETagConfiguration = (config) => typeof config.eTagCache === 'object';

/**
 * Calculates a configuration for etag cache, merging with default ETag configuration if necessary
 * @param {object} config Client/Request configuration
 * @returns {(boolean|object)} Either `false` or ETag cache configation
 */
const getETagCacheConfig = (config) => {
  if (config.eTagCache) {
    if (hasETagConfiguration(config)) {
      // Object configuration, so merging with default configuration

      const maxSize = !config.eTagCache.maxSize
        ? null
        : {
          maxSize: config.eTagCache.maxSize,
        };

      // Cache stores more than the current etag response
      // original getSize is wrapped into a new one to scope
      // each getSize evaluation to a single response
      const getSize = !config.eTagCache.getSize
        ? null
        : {
          getSize: (value, key) => {
            if (!value.currentETag) {
              return 0;
            }
            return config.eTagCache.getSize(value.responses[value.currentETag], key);
          },
        };

      return {
        ...defaults.eTagCache,
        ...maxSize,
        ...getSize,
      };
    }

    // Truthy value, so return the default config
    return defaults.eTagCache;
  }

  // Falsy value, so return false
  return false;
};

/**
 * Process response regarding ETag concerns.
 * If the response has no ETag header just return the response parameter.
 * If a successful response has an ETag header caches it.
 * If a 304 response has an ETag header tries to retrieve content from cache.
 * @param {object} config Client/Request configuration
 * @param {object} res Request response
 * @param {boolean} eTagHeaderAdded Indicates if a if-none-match header was added by the client
 * @param {object} eTagCache ETag cache instance
 * @param {string} key Request key
 * @returns {object} Response
 */
const processResponseETagCache = (config, res, eTagHeaderAdded, eTagCache, key) => {
  if (eTagHeaderAdded && res.status === 304) {
    // Tries to get content from cache

    const requestETag = config.headers[IF_NONE_MATCH];
    const cachedData = eTagCache.get(key);

    if (cachedData) {
      const cachedResponse = cachedData.responses[requestETag];
      if (cachedResponse) {
        cachedResponse.config = res.config;
        return cachedResponse;
      }

      // Ups! This shouldn't happen because we only remove responses when
      // there are no pending requests for the resource
      // Covering the case just for resilience: remove cache and throw an
      // error to retry request without if-none-match header
      eTagCache.delete(key);
      throw new Error('ETag not found on ETag cache');
    } else {
      // Ups! This shouldn't happen because we do not remove cache entries
      // Covering the case just for resilience: throw an
      // error to retry request without if-none-match header
      throw new Error('Request key not found on ETag cache');
    }
  }

  const responseETag = res.headers[ETAG];
  if (responseETag) {
    // Stores response on ETag cache
    const cachedData = eTagCache.get(key);

    eTagCache.set(key, {
      currentETag: responseETag,
      responses: {
        ...(cachedData || {}).responses,
        [responseETag]: removeCircularReferences(res),
      },
    });
  }

  return res;
};

/**
 * Increments pending request counter for provided key/ETag
 * @param {string} key Request key
 * @param {string} eTag Request if-none-match ETag
 * @param {object} restClientInstance Rest client instance
 * @returns {undefined}
 */
const increasePendingETag = (key, eTag, restClientInstance) => {
  if (!restClientInstance.eTagPendingRequests[key]) {
    restClientInstance.eTagPendingRequests[key] = {};
  }
  restClientInstance.eTagPendingRequests[key][eTag] = (restClientInstance.eTagPendingRequests[key][eTag] || 0) + 1;
};

/**
 * Decrements pending request counter for provided key/ETag
 * If a counter reaches zero count:
 *  - The ETag counter itself is removed
 *  - If there are no more ETags for the key, the key counter is removed
 *  - Removes key's cached responses with no pending requests
 * @param {string} key Request key
 * @param {string} eTag Request if-none-match ETag
 * @param {object} restClientInstance Rest client instance
 * @returns {undefined}
 */
const decreasePendingETag = (key, eTag, restClientInstance) => {
  const keyPendingRequests = restClientInstance.eTagPendingRequests[key];
  if (keyPendingRequests) {
    keyPendingRequests[eTag] = (keyPendingRequests[eTag] || 0) - 1;

    const cachedData = restClientInstance.eTagCache.get(key);
    const currentETag = (cachedData || {}).currentETag || null;
    const pendingETags = Object.keys(keyPendingRequests);
    const eTagsToRemove = pendingETags
      .filter((pendingETag) => !keyPendingRequests[pendingETag] && pendingETag !== currentETag);

    if (pendingETags.length === eTagsToRemove.length) {
      delete restClientInstance.eTagPendingRequests[key];
    } else {
      eTagsToRemove.forEach((eTagToRemove) => {
        delete restClientInstance.eTagPendingRequests[key][eTagToRemove];
      });
    }

    if (cachedData) {
      const eTagsToRemoveHash = eTagsToRemove.reduce((hash, eTagToRemove) => {
        hash[eTagToRemove] = true;
        return hash;
      }, {});
      const responses = Object
        .keys(cachedData.responses)
        .filter((cachedETag) => !eTagsToRemoveHash[cachedETag])
        .reduce((hash, cachedETag) => {
          hash[cachedETag] = cachedData.responses[cachedETag];
          return hash;
        }, {});

      restClientInstance.eTagCache.set(key, {
        currentETag: cachedData.currentETag,
        responses,
      });
    }
  }
};

/**
 * Process response regarding Cache-Control concerns.
 * Caches a response with Cache-Control header or configuration options.
 * @param {object} config Client/Request configuration
 * @param {object} res Request response
 * @param {object} cache Cache-Control cache
 * @param {string} key Request key
 * @returns {undefined}
 */
const processResponseCacheControl = (config, res, cache, key) => {
  // Cache the response using the given options or "cache-control" header.
  const options = (typeof config.cache === 'object')
    ? config.cache
    : res.headers['cache-control'];
  const toStore = removeCircularReferences(res);
  cache.set(key, toStore, getMaxAge(options))
    .catch((error) => {
      logger.info(error.message);
    });
};

/**
 * Returns a configuration with added cache headers and custom validateStatus on it.
 * @param {object} config Request configuration
 * @param {string} currentETag Request ETag
 * @param {object} eTagCacheConfiguration eTagCache configuration
 * @returns {undefined}
 */
const getConfigWithCacheData = (config, currentETag, eTagCacheConfiguration) => {
  const configWithCacheData = {
    ...config,
    eTagCache: eTagCacheConfiguration,
    headers: {
      ...config.headers,
    },
  };

  if (currentETag) {
    // Adds if-none-match header
    configWithCacheData.headers[IF_NONE_MATCH] = currentETag;

    // Axios takes a 304 status as an error so overriding
    // the status validation to include 304 statuses as success
    configWithCacheData.validateStatus = (status) => (status >= 200 && status < 300) || status === 304;
  }

  return configWithCacheData;
};

/**
 * Returns helpers and data to be used on requests
 * @param {object} config Request configuration
 * @param {object} restClientInstance Rest client instance
 * @returns {(null|object)} Either ETag cache headers, or null if there's no eTagCache configuration
 */
const getRequestCacheData = (config, restClientInstance) => {
  // Gets request key
  const key = createCacheKey(config.method, config.url, config.params);

  // Calculates eTagCacheConfiguration
  let eTagCacheConfiguration;
  if (config.eTagCache === false) {
    // If request eTagCache is false just skip ETag cache for this request
    eTagCacheConfiguration = false;
  } else if (hasETagConfiguration(config)) {
    // Merge client eTagCache config with request one
    eTagCacheConfiguration = { ...restClientInstance.config.eTagCache, ...config.eTagCache };
  } else {
    // Use client eTagCache config
    eTagCacheConfiguration = restClientInstance.config.eTagCache || getETagCacheConfig(config);
  }

  const currentETag = eTagCacheConfiguration && (restClientInstance.eTagCache.get(key) || {}).currentETag;

  /**
   * If using ETag caching increases and decreases counters used to avoid race conditions errors.
   * Eg of a race condition problem if we keep just the last etag cache:
   *  1 - Send request 1 without if-none-match header
   *  2 - Request 1 response returns with 200 status and etag '123', cached
   *  3 - Send request 2 with if-none-match '123' header
   *  4 - Send request 3 with if-none-match '123' header
   *  5 - Request 2 response returns with 200 status and etag '987'
   *  6 - Request 3 response returns with 304 status.
   * As we override the '123' cache in step 5 the '987' one we don't have a cached version to return.
   * To avoid these kind of scenarios the client keeps cached versions (many etags) until being sure
   * the tag is not used in any pending request (and is not the last cached etag)
   * @param {Promise<object>} requestPromise Response promise
   * @returns {(Promise<object>))} Response (probably cached) promise
   */
  let handleConcurrentRequests;
  if (currentETag) {
    // To avoid race condition errors there are key/etag pending requests counters
    // That allows us to remove a response cache only when there are no pending request
    // for that key with the response ETag on the if-none-match header
    increasePendingETag(key, currentETag, restClientInstance);
    handleConcurrentRequests = (requestPromise) => requestPromise
      .then((res) => {
        decreasePendingETag(key, currentETag, restClientInstance);
        return res;
      })
      .catch((error) => {
        decreasePendingETag(key, currentETag, restClientInstance);
        throw error;
      });
  } else {
    handleConcurrentRequests = (requestPromise) => requestPromise;
  }

  const configWithCacheData = getConfigWithCacheData(config, currentETag, eTagCacheConfiguration);

  /**
   * This function returns a transformed response with the x-cache-frontend-restclient header injected.
   * @param {object} res Request response
   * @returns {object} Transformed response
   */
  const injectXCacheHeader = (res) => {
    res.headers['x-cache-frontend-restclient'] = CACHE_STATUS.MISS;
    return res;
  };

  /**
   * Given a configuration returns a function that process a response.
   * This function adds the response to Cache-Control cache or gets the content from ETag cache if necessary.
   * @param {object} res Request response
   * @returns {(Promise<object>|object))} Promise of a response or a response itself
   */
  const processResponse = (res) => {
    if (configWithCacheData.method === 'get') {
      if (configWithCacheData.cache) {
        processResponseCacheControl(configWithCacheData, res, restClientInstance.cache, key);
      }
      if (configWithCacheData.eTagCache) {
        return processResponseETagCache(configWithCacheData, res, !!currentETag, restClientInstance.eTagCache, key);
      }
    }

    return res;
  };

  return {
    configWithCacheData,
    handleConcurrentRequests,
    processResponse,
    injectXCacheHeader,
  };
};

/**
 * Tries to return a cached response.
 * If there's no cache configuration or the response was not cached returns null.
 * @param {object} config Client/Request configuration
 * @param {object} cache Cache-Control cache
 * @returns {Promise<(null|object)>} Cached response
 */
const getFromCache = (config, cache) => {
  /**
   * We should use cache only when:
   * - the current request is a GET.
   * - the current request has defined config.cache.
   */
  if (config.method === 'get' && config.cache) {
    return cache.get(createCacheKey(config.method, config.url, config.params))
      .then((cachedData) => {
        if (cachedData) {
          cachedData.config = config;
          cachedData.headers['x-cache-frontend-restclient'] = CACHE_STATUS.HIT;
          return cachedData;
        }

        return null;
      });
  }

  return Promise.resolve(null);
};
module.exports = {
  getETagCacheConfig,
  getFromCache,
  getRequestCacheData,
  createCacheKey,
};
