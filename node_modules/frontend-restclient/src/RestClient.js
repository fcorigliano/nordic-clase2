/**
 * Module dependencies
 */
const { PRODUCTION, FURY } = require('frontend-env');
/**
 * We only want to use newrelic in env=production and fury, since in other envs it will throw errors.
 * Sadly newrelic can only be disabled via configfile or env variables, which is inconvenient for testing
 * since every project that uses nordic would have to add one of these options just to test their projects
 * Hence we'll only require it for production environment.
 */
const metricsEnabled = (PRODUCTION && FURY);
const newrelic = metricsEnabled ? require('newrelic') : {};
const axios = require('nordic-axios');
const retry = require('retry');
const LRUCache = require('stale-lru-cache');

const defaults = require('../config/defaults');
const { logger, logErrorIfApply } = require('./logger');
const getAppMetrics = require('./tracking/get/appMetrics');
const getEndpointMetrics = require('./tracking/get/endpointMetrics');
const getRequestHeaders = require('./tracking/get/requestHeaders');
const {
  getETagCacheConfig,
  getRequestCacheData,
  getFromCache,
} = require('./cache-utils');
const { injectRetryCountHeader, setRetryCountHeaderValueOrDefault } = require('./retry-utils');
const mergeContextHeaders = require('./merge-context-headers');
const { GENERIC_BAD_RETRY_POLICY_IMPLEMENTATION, BAD_HOOK_TYPE } = require('./constants/errorMessages');
const retryConfigBuilder = require('./helpers/retryConfigBuilder');
const isRetryPolicyValid = require('./helpers/isRetryPolicyValid');


/**
 * RestClient class to create a new instance of axios with a custom config.
 * @param config Object
 * @see https://github.com/mzabriskie/axios#request-config
 */
class RestClient {
  constructor(config = {}) {
    this.config = { ...defaults, ...config };
    this.config.eTagCache = getETagCacheConfig(config);
    this.client = axios.create(this.config);
    this.cache = this.config.cacheClient(this.config.cache);
    this.eTagCache = new LRUCache(this.config.eTagCache || defaults.eTagCache);
    this.eTagPendingRequests = {};

    if (metricsEnabled) {
      newrelic.recordCustomEvent('RestClientApplicationConfigs', {
        ...getAppMetrics(),
        ...getAppMetrics.getPoolName(),
        ...getEndpointMetrics(this.config),
      });
    }

    this.poolNameIdentifier = getAppMetrics.getPoolName();

    this._injectHooks(this.client);
  }

  /**
   * Makes a new request with a same config from doRequest and returns a promise.
   * @param config Object
   * @see https://github.com/mzabriskie/axios#request-config
   */
  makeClientRequest(config) {
    // Prepare a new request
    const request = (reqConfig) => {
      const {
        handleConcurrentRequests,
        processResponse,
        configWithCacheData,
        injectXCacheHeader,
      } = getRequestCacheData(reqConfig, this);

      const requestPromise = this.client.request(configWithCacheData)
        .then(injectXCacheHeader)
        .then(setRetryCountHeaderValueOrDefault)
        .then(processResponse)
        // Catch the error to log and throw an error, which triggers the next
        // reject handler in the chain to be called.
        .catch((error) => {
          if (!error.response) error.response = {};
          setRetryCountHeaderValueOrDefault(error.response);
          logErrorIfApply(error, reqConfig, this.config);
          throw error;
        });

      return handleConcurrentRequests(requestPromise);
    };

    // Make request with retries
    if (config.retry) {
      if (isRetryPolicyValid(config.retry.policy)) {
        return this.retry(request, config);
      }

      return Promise.reject(GENERIC_BAD_RETRY_POLICY_IMPLEMENTATION);
    }
    // Make request
    return request(config);
  }

  /**
   * Makes a request with a given method, url, and config and returns a promise.
   * @param config Object
   * @param config.method String
   * @param config.url String
   * @param config.config String
   * @see https://github.com/mzabriskie/axios#request-config
   */
  doRequest(config) {
    config.retry = retryConfigBuilder(config, this.config);

    /**
     * Set more headers
     */
    config.headers = {
      ...config.headers,
      ...this.poolNameIdentifier,
      'x-socket-timeout': getEndpointMetrics(this.config)['x-socket-timeout'],
      ...getRequestHeaders({ retryCount: 0 }),
    };

    /**
     * Adds context headers into request headers when available.
     */
    if (config.context) {
      config.headers = mergeContextHeaders(config.context, config.headers);
    }

    return new Promise((resolve) => {
      let isCached = false;
      getFromCache(config, this.cache)
        .then((cachedResponse) => {
          // Return cached response
          if (cachedResponse) {
            isCached = true;
            resolve(cachedResponse);
          }

          return undefined;
        })
        .catch((error) => logErrorIfApply(error, config, this.config))
        .finally(() => {
          if (!isCached) resolve(this.makeClientRequest(config));
        });
    });
  }

  /**
   * Alias to make a GET request and returns a promise.
   * @param url String
   * @param config Object
   * @see https://github.com/mzabriskie/axios#request-config
   */
  get(url, config = {}) {
    config.method = 'get';
    config.url = url;
    return this.doRequest(config);
  }

  /**
   * Alias to make a POST request and returns a promise.
   * @param url String
   * @param config Object
   * @see https://github.com/mzabriskie/axios#request-config
   */
  post(url, config = {}) {
    config.method = 'post';
    config.url = url;
    return this.doRequest(config);
  }

  /**
   * Alias to make a PUT request and returns a promise.
   * @param url String
   * @param config Object
   * @see https://github.com/mzabriskie/axios#request-config
   */
  put(url, config = {}) {
    config.method = 'put';
    config.url = url;
    return this.doRequest(config);
  }

  /**
   * Alias to make a PATCH request and returns a promise.
   * @param url String
   * @param config Object
   * @see https://github.com/mzabriskie/axios#request-config
   */
  patch(url, config = {}) {
    config.method = 'patch';
    config.url = url;
    return this.doRequest(config);
  }

  /**
   * Alias to make a DELETE request and returns a promise.
   * @param url String
   * @param config Object
   * @see https://github.com/mzabriskie/axios#request-config
   */
  delete(url, config = {}) {
    config.method = 'delete';
    config.url = url;
    return this.doRequest(config);
  }

  /**
   * Alias to make a HEAD request and returns a promise.
   * @param url String
   * @param config Object
   * @see https://github.com/mzabriskie/axios#request-config
   */
  head(url, config = {}) {
    config.method = 'head';
    config.url = url;
    return this.doRequest(config);
  }

  /**
   * Alias to make an OPTIONS request and returns a promise.
   * @param url String
   * @param config Object
   * @see https://github.com/mzabriskie/axios#request-config
   */
  options(url, config = {}) {
    config.method = 'options';
    config.url = url;
    return this.doRequest(config);
  }

  /**
   * Alias to make a PURGE request and returns a promise.
   * @param url String
   * @param config Object
   * @see https://github.com/mzabriskie/axios#request-config
   */
  purge(url, config = {}) {
    config.method = 'purge';
    config.url = url;
    return this.doRequest(config);
  }

  /**
   * It makes concurrent requests that combines multiple promises and returns
   * a collection of responses.
   * @param requests Object
   * @see https://github.com/mzabriskie/axios#concurrency
   */
  all(requests) {
    return axios.all(requests)
      .then(axios.spread((...response) => response))
      .catch((error) => {
        logErrorIfApply(error, {}, this.config);
        throw error;
      });
  }

  /**
   * Retry Strategy.
   * It supports both strategies: simple and backoff (using factor option).
   * @See: https://github.com/tim-kos/node-retry
   */
  retry(request, config) {
    // Return a new promise
    return new Promise((resolve, reject) => {
      // Configure the operation to retry
      const operation = retry.operation({
        retries: config.retry.maxRetries,
        minTimeout: config.retry.delay,
        maxTimeout: config.retry.maxDelay,
        factor: config.retry.factor,
      });

      // For each attempt make a new request.
      operation.attempt((currentAttempt) => {
        Promise.resolve(currentAttempt)
          .then(() => {
            const retryCount = (currentAttempt - 1); // Since first attempt isn't a retry, its just the first op call

            const updatedHeaders = {
              ...config.headers,
              ...getRequestHeaders({ retryCount }),
            };
            return request({ ...config, headers: updatedHeaders });
          })
          // If the request has not an error, resolve the promise with the response.
          .then((response) => resolve(injectRetryCountHeader(response, (currentAttempt - 1))))
          /**
           * The operation will be retried when:
           * - the request's method is allowed;
           * - the error code is allowed;
           * - the maximum amount of retries has not been reached.
           */
          .catch((error) => {
            // Retry only if error contain a config object and matches the retry policy
            if (
              !(error.config
                && config.retry.policy.hasToRetry(error)
                && operation.retry(error)) // note this will execute a new retry when necessary: https://www.npmjs.com/package/retry#retryoperationretryerror
            ) {
              if (!error.response) error.response = {};
              logger.info(`Retrying: attempt NÂº ${currentAttempt}.`);
              // Save the quantity of attempts done
              injectRetryCountHeader(error.response, (currentAttempt - 1));
              // Reject the promise with the given error.
              reject(error);
            }
          });
      });
    });
  }

  /**
  * Inject hooks if they were passed through the instace config
  * @return {undefined} Does not return anything usefull
  */
  _injectHooks(client) {
    const { requestHook, responseHook } = this.config;

    // If the requestHook or the responseHook are defined they need to be functions
    if ((requestHook && typeof requestHook !== 'function') || (responseHook && typeof responseHook !== 'function')) throw new Error(BAD_HOOK_TYPE);

    // The user should not be able to modify the request configs and response data
    // If we directly set the interceptor with the user hook the return value will overwrite the response / request config.
    // Due to this reason, we need to wrap the user hook
    const userHookWrapper = (hook) => (data) => {
      hook(data);
      return data;
    };

    if (requestHook) {
      client.interceptors.request.use(userHookWrapper(requestHook));
    }

    if (responseHook) {
      client.interceptors.response.use(userHookWrapper(responseHook));
    }
  }
}

/**
 * Expose RestClient
 */
module.exports = RestClient;
