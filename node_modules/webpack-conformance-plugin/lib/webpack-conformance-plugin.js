/* eslint-disable no-restricted-syntax */
const { visit } = require('recast');
const { SyncHook } = require('tapable');
const {
  CONFORMANCE_RULE_SUCCESS,
  CONFORMANCE_RULE_FAILED,
} = require('./constants');
const WebpackConformanceRuleMinification = require('./rules/minification');
const WebpackConformanceRuleGranularChunk = require('./rules/granular-chunk');

const pluginName = 'WebpackConformancePlugin';
const compilationHooksMap = new WeakMap();

class WebpackConformancePlugin {
  constructor(options = {}) {
    this.options = options;
    if (!options.webpackConfig) {
      options.webpackConfig = `${process.cwd()}/webpack.config.js`;
    }
    this.rules = options.rules || [
      new WebpackConformanceRuleMinification(options.webpackConfig),
      new WebpackConformanceRuleGranularChunk(options.webpackConfig),
    ];
    this.errors = [];
    this.warnings = [];
    this.buildStartedHandler = this.buildStartedHandler.bind(this);
    this.buildCompletedHandler = this.buildCompletedHandler.bind(this);
    this.parserHandler = this.parserHandler.bind(this);
    this.collect = this.collect.bind(this);
  }

  static getCompilationHooks(compilation) {
    let hooks = compilationHooksMap.get(compilation);
    if (hooks === undefined) {
      hooks = {
        conformance: new SyncHook(['errors', 'warnings']),
      };
      compilationHooksMap.set(compilation, hooks);
    }

    return hooks;
  }

  collect(results) {
    results.forEach((result) => {
      if (result.result === CONFORMANCE_RULE_FAILED) {
        if (result.errors) {
          this.errors.push(...result.errors);
        }
        if (result.warnings) {
          this.warnings.push(...result.warnings);
        }
      }
    });
  }

  buildStartedHandler(_compilation, compiler, cb) {
    const buildStartedResults = this.rules.map(
      (test) => {
        if (test.buildStared && compiler) {
          return test.buildStared(compiler.options);
        }
        return {
          result: CONFORMANCE_RULE_SUCCESS,
        };
      },
    );

    this.collect(buildStartedResults);
    cb();
  }

  buildCompletedHandler(compilation, cb) {
    const buildCompletedResults = this.rules.map(
      (test) => {
        if (test.buildCompleted) {
          return test.buildCompleted(compilation.assets);
        }
        return {
          result: CONFORMANCE_RULE_SUCCESS,
        };
      },
    );

    this.collect(buildCompletedResults);

    WebpackConformancePlugin.getCompilationHooks(compilation).conformance.call(this.errors, this.warnings);
    compilation.errors.push(...this.errors);
    compilation.warnings.push(...this.warnings);

    cb();
  }

  parserHandler(factory) {
    const JS_TYPES = ['auto', 'esm', 'dynamic'];
    const collectedVisitors = new Map();
    this.rules.forEach((rule) => {
      if (rule.getAstNode) {
        const getAstCallbacks = rule.getAstNode();
        getAstCallbacks.forEach((result) => {
          if (!collectedVisitors.has(result.visitor)) {
            collectedVisitors.set(result.visitor, []);
          }
          collectedVisitors.get(result.visitor).push(result.inspectNode);
        });
      }
    });

    JS_TYPES.forEach((type) => {
      factory.hooks.parser
        .for(`javascript/${type}`)
        .tap(this.constructor.name, (parser) => {
          parser.hooks.program.tap(this.constructor.name, (ast) => {
            const visitors = {};
            const that = this;
            for (const visitorKey of collectedVisitors.keys()) {
              visitors[visitorKey] = function visitor(path) {
                const callbacks = collectedVisitors.get(visitorKey) || [];
                callbacks.forEach((cb) => {
                  if (!cb) {
                    return;
                  }
                  const { request, _source: { _sourceMap: sourceMap } } = parser.state.module;

                  const outcome = cb(path, { request, sourceMap });
                  that.collect([outcome]);
                });
                this.traverse(path);
                return false;
              };
            }
            visit(ast, visitors);
          });
        });
    });
  }

  apply(compiler) {
    compiler.hooks.make.tapAsync(pluginName, (compilation, callback) => {
      this.buildStartedHandler(compilation, compiler, callback);
    });

    compiler.hooks.emit.tapAsync(pluginName, (compilation, callback) => {
      this.buildCompletedHandler(compilation, callback);
    });

    compiler.hooks.normalModuleFactory.tap(pluginName, (factory) => {
      this.parserHandler(factory);
    });
  }
}

module.exports = WebpackConformancePlugin;
