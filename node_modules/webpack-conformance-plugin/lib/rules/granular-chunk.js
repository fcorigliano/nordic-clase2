/* eslint-disable class-methods-use-this,security/detect-non-literal-fs-filename,no-console */
const fs = require('fs');
const isEqual = require('lodash/isEqual');
const recast = require('recast');
const babelParser = require('@babel/parser');
const granularStrategy = require('frontend-lazy/config/webpack/granular');

const {
  CONFORMANCE_PREFIX,
  CONFORMANCE_RULE_FAILED,
  EARLY_EXIT_SUCCESS_RESULT,
} = require('../constants');

const { getLocalFileName } = require('../utils');

function deepEqual(userCacheGroup, originalCacheGroup) {
  if (!originalCacheGroup || !userCacheGroup) {
    return true;
  }
  const { test: testUserCacheGroup, name: nameUserCacheGroup, ...restUserCacheGroup } = userCacheGroup;
  const { test: testOriginalCacheGroup, name: nameOriginalCacheGroup, ...restOriginalCacheGroup } = originalCacheGroup;
  if (testOriginalCacheGroup && (testOriginalCacheGroup.toString() !== testUserCacheGroup.toString())) {
    return false;
  }
  if (nameOriginalCacheGroup && (nameOriginalCacheGroup.toString() !== nameUserCacheGroup.toString())) {
    return false;
  }
  return isEqual(restUserCacheGroup, restOriginalCacheGroup);
}

function getWarningMessage(modifiedProp) {
  return (
    `${CONFORMANCE_PREFIX} granular chunk: The splitChunks config has been carefully `
    + `crafted to optimize build size and build times. Modifying - ${modifiedProp} `
    + 'could result in slower builds and increased code duplication'
  );
}

const getNormalizedEntry = entry => {
  const result = {};
  Object.keys(entry).forEach(key => {
    result[key] = [...entry[key].import];
  });
  return result;
};

class WebpackConformanceRuleGranularChunk {
  constructor(webpackConfig, fileSystem) {
    this.webpackConfig = webpackConfig;
    this.fs = fileSystem || fs;
  }

  _hasGranularChunk() {
    let hasGranularChunk = false;
    try {
      if (!this.fs.existsSync(this.webpackConfig)) {
        return hasGranularChunk;
      }
      const source = this.fs.readFileSync(this.webpackConfig);
      const ast = recast.parse(source, { parser: babelParser });
      recast.visit(ast, {
        visitIdentifier(path) {
          const { node } = path;
          if (node.type === 'Identifier' && node.name === 'lazy') {
            const granularChunk = path.parent.value.value.properties
              .find(p => p.key.name === 'splitChunks' && p.value.value === 'granular');
            if (granularChunk) {
              hasGranularChunk = true;
              return false;
            }
          }
          this.traverse(path);
          return true;
        },
      });
    } catch (e) {
      // @TODO improve error reporting
      console.error(e);
    }
    return hasGranularChunk;
  }

  buildStared(options) {
    if (!this._hasGranularChunk()) {
      return EARLY_EXIT_SUCCESS_RESULT;
    }
    const { splitChunks: userSplitChunks } = options.optimization;
    const { optimization: { splitChunks } } = granularStrategy({
      entry: getNormalizedEntry(options.entry),
    });

    const warnings = [];

    if (
      userSplitChunks.maxInitialRequests !== splitChunks.maxInitialRequests
    ) {
      warnings.push('splitChunks.maxInitialRequests');
    }

    if (userSplitChunks.minSize !== splitChunks.minSize) {
      warnings.push('splitChunks.minSize');
    }

    const userCacheGroup = userSplitChunks.cacheGroups;
    const originalCacheGroup = splitChunks.cacheGroups;
    const cacheGroupConfigKeys = ['default', 'framework', 'lib', 'commons', 'defaultVendors'];

    if (userCacheGroup.default !== false) {
      warnings.push('splitChunks.cacheGroups.default');
    }

    if (!deepEqual(userCacheGroup.framework, originalCacheGroup.framework)) {
      warnings.push('splitChunks.cacheGroups.framework');
    }

    if (!deepEqual(userCacheGroup.lib, originalCacheGroup.lib)) {
      warnings.push('splitChunks.cacheGroups.lib');
    }

    if (!deepEqual(userCacheGroup.commons, originalCacheGroup.commons)) {
      warnings.push('splitChunks.cacheGroups.commons');
    }

    const keysAreTheOriginalDefined = cacheGroupConfigKeys.every((key) => Object.keys(userCacheGroup).includes(key)
    && cacheGroupConfigKeys.length === Object.keys(userCacheGroup).length);

    if (!keysAreTheOriginalDefined) {
      warnings.push('splitChunks.cacheGroups');
    }

    if (warnings.length === 0) {
      return EARLY_EXIT_SUCCESS_RESULT;
    }

    const failedResult = {
      result: CONFORMANCE_RULE_FAILED,
    };

    failedResult.warnings = warnings.map((warning) => {
      const message = getWarningMessage(warning);
      return {
        message,
        metadata: {
          column: 0,
          file: getLocalFileName(this.webpackConfig),
          line: 1,
          message,
          ruleId: 'webpack-conformance-rule-granular-chunk',
        },
      };
    });

    return failedResult;
  }
}

module.exports = WebpackConformanceRuleGranularChunk;
