const fs = require('fs');
const os = require('os');
const path = require('path');
const frontendConfig = require('frontend-config');
const restclient = require('frontend-restclient');
const buildFlowStarterContext = require('frontend-restclient/src/build-flow-context');
const {
  RETRY_TIME_WINDOW,
  REST_CLIENT_TIMEOUT,
  MAX_CONCURRENT_REQUESTS,
  REMOVE_FILE_TIME_WINDOW,
} = require('../../constants/first-request-inline-styles');
const {
  getHref,
  getPlatformName,
} = require('../../services/ui-navigation');
const loggerFactory = require('../../logger/factory');

const logger = loggerFactory.create('frontend-navigations/commons');

/* eslint-disable security/detect-object-injection */
/* eslint-disable security/detect-non-literal-fs-filename */

let updateEnvironmentCache;

const updatedFilesFolderPath = path.join(os.tmpdir(), 'frontend-navigations-files', 'files-cache');
if (!fs.existsSync(updatedFilesFolderPath)) {
  try {
    fs.mkdirSync(updatedFilesFolderPath, { recursive: true });
  } catch (err) {
    logger.error({
      err,
      errorType: 'creating-cache-folder-error',
      message: `Error creating css cache folder on ${updatedFilesFolderPath}`,
      tags: {
        updatedFilesFolderPath,
      },
    });
  }
}

const getAPIFilePath = (fileName, platformName, uiNavigationVersion) =>
  path.join(updatedFilesFolderPath, uiNavigationVersion, platformName, fileName);

const readFile = ({
  fileName,
  platformName,
  uiNavigationVersion,
  callback,
}) => {
  const filePath = getAPIFilePath(fileName, platformName, uiNavigationVersion);

  fs.readFile(filePath, (err, data) => callback(err, data && data.toString(), filePath));
};

const stylesClient = restclient({
  timeout: REST_CLIENT_TIMEOUT,
});

const ensureFilePathExistence = (filePath) => {
  const dirname = path.dirname(filePath);
  if (fs.existsSync(dirname)) {
    return;
  }
  ensureFilePathExistence(dirname);
  fs.mkdirSync(dirname);
};

const writeFile = (filePath, content) => {
  try {
    ensureFilePathExistence(filePath);
    const options = {
      flag: 'wx',
    };
    fs.writeFile(filePath, content, options, () => {});
  } catch (err) {
    logger.error({
      err,
      errorType: 'files-cache-writing-error',
      message: `Navigation CSS file cache - Error writing file ${filePath}. Error message: ${(err || {}).message}`,
      tags: {
        filePath,
      },
    });
  }
};


let queueRequest;
const executeApiRequest = (requestData) => {
  const {
    key,
    fileName,
    uiNavigationVersion,
    platformName,
    contentCache,
  } = requestData;

  if (!contentCache.hasSuscriptors(key)) {
    return Promise.resolve();
  }

  const url = getHref(null, fileName, uiNavigationVersion, platformName);
  return stylesClient
    .get(url, {
      context: buildFlowStarterContext(),
    })
    .then(({ data: content }) => {
      const filePath = getAPIFilePath(fileName, platformName, uiNavigationVersion);
      contentCache.setContent(key, content, filePath);
      writeFile(filePath, content);
    })
    .catch((err) => {
      logger.error({
        err,
        errorType: 'files-cache-request-error',
        message: `Navigation CSS file cache - Error getting ${url}. Error message: ${(err || {}).message}`,
        tags: {
          url,
        },
      });

      if (contentCache.hasSuscriptors(key)) {
        setTimeout(() => contentCache.hasSuscriptors(key) && queueRequest(requestData), RETRY_TIME_WINDOW);
      }
    });
};

const apiRequestQueue = [];
const ongoingApiRequests = [];
queueRequest = (requestDataToQueue) => {
  if (requestDataToQueue) {
    apiRequestQueue.push(requestDataToQueue);
  }
  if (ongoingApiRequests.length < MAX_CONCURRENT_REQUESTS && apiRequestQueue.length) {
    const nextRequest = apiRequestQueue.shift();
    ongoingApiRequests.push(nextRequest);

    executeApiRequest(nextRequest)
      .then(() => {
        ongoingApiRequests.splice(ongoingApiRequests.indexOf(nextRequest), 1);
        queueRequest();
      });
  }
};

const scheduleGetFileContent = ({
  key,
  fileName,
  platformName,
  uiNavigationVersion,
  contentCache,
}) => {
  setTimeout(() => {
    if (contentCache.hasSuscriptors(key)) {
      const callback = (error, content, fileToRemove) => {
        if (!error) {
          contentCache.setContent(key, content, fileToRemove);
          return;
        }

        if (contentCache.hasSuscriptors(key)) {
          queueRequest({
            key,
            fileName,
            platformName,
            uiNavigationVersion,
            contentCache,
          });
        }
      };
      readFile({
        fileName,
        platformName,
        uiNavigationVersion,
        callback,
      });
    }
  });
};

// stores files content and suscriptors count
// if a cache key has no suscriptors removes it avoiding memory leaks
const contentCache = (() => {
  const cache = {};

  const getContent = key => (cache[key] || {}).content;

  const setContent = (key, content, fileToRemove) => {
    const cacheValue = cache[key];
    if (cacheValue && content) {
      cacheValue.content = content;
      cacheValue.fileToRemove = fileToRemove;
    }
  };

  const hasSuscriptors = key => !!(cache[key] && cache[key].suscriptors);

  const suscribe = ({
    key,
    fileName,
    platformName,
    uiNavigationVersion,
  }) => {
    if (!cache[key]) {
      cache[key] = {
        content: null,
        suscriptors: 0,
        uiNavigationVersion,
      };
      scheduleGetFileContent({
        key,
        fileName,
        platformName,
        uiNavigationVersion,
        contentCache,
      });
    }
    cache[key].suscriptors += 1;
  };

  const unsuscribe = (key) => {
    if (cache[key]) {
      cache[key].suscriptors -= 1;

      // defers cache removal just in case someone suscribes to it in the same event loop
      setTimeout(() => {
        const cacheValue = cache[key];
        if (cacheValue && cacheValue.suscriptors <= 0) {
          delete cache[key];

          if (cacheValue.fileToRemove) {
            // Wait 20 minutes and remove it if there's no navigation depending on this file
            setTimeout(() => {
              if (!cache[key]) {
                fs.unlink(cacheValue.fileToRemove, () => {});
              }
            }, REMOVE_FILE_TIME_WINDOW);
          }
        }
      });
    }
  };

  return {
    getContent,
    setContent,
    suscribe,
    unsuscribe,
    hasSuscriptors,
  };
})();

// stores current ui-navigation version and file are used for each site file
const siteFilesCache = (() => {
  const cache = {};

  const get = (environment, platformId, siteId, fileName) =>
    ((((cache[environment] || {})[platformId] || {})[siteId] || {})[fileName]);

  const set = ({
    environment,
    platformId,
    siteId,
    fileName,
    platformName,
    uiNavigationVersion,
    configGetter,
    addConfigUpdateHandler,
  }) => {
    if (!cache[environment]) {
      cache[environment] = {};

      const handler = updateEnvironmentCache({
        environment,
        configGetter,
        addConfigUpdateHandler,
      });

      if (addConfigUpdateHandler) {
        addConfigUpdateHandler(handler, environment);
      } else {
        frontendConfig.addUpdateHandler(handler, environment);
      }
    }
    const environmentCache = cache[environment];

    if (!environmentCache[platformId]) {
      environmentCache[platformId] = {};
    }
    const platformCache = environmentCache[platformId];

    if (!platformCache[siteId]) {
      platformCache[siteId] = {};
    }
    const siteCache = platformCache[siteId];

    const oldFileContentKey = siteCache[fileName];
    const newFileContentKey = [fileName, platformName, uiNavigationVersion].join('/');
    if (oldFileContentKey !== newFileContentKey) {
      if (oldFileContentKey) {
        contentCache.unsuscribe(oldFileContentKey);
      }
      if (newFileContentKey) {
        contentCache.suscribe({
          key: newFileContentKey,
          fileName,
          platformName,
          uiNavigationVersion,
        });
      }
    }

    siteCache[fileName] = newFileContentKey;
  };

  const getEnvironmentCache = environment => cache[environment];

  return {
    get,
    set,
    getEnvironmentCache,
  };
})();

updateEnvironmentCache = ({
  environment,
  configGetter,
  addConfigUpdateHandler,
}) => () => {
  const environmentCache = siteFilesCache.getEnvironmentCache(environment);

  // iterate platforms
  Object
    .keys(environmentCache)
    .forEach((platformId) => {
      const platformCache = environmentCache[platformId];
      const platformName = getPlatformName(platformId);

      if (!platformName) {
        logger.error({
          errorType: 'files-cache-unknown-platform',
          message: `Navigation CSS file cache - Unknown platform ${platformId}`,
          tags: {
            platformId,
          },
        });
        return;
      }

      // iterate platform sites
      Object
        .keys(platformCache)
        .forEach((siteId) => {
          const siteCache = platformCache[siteId];

          const uiNavigationVersion = configGetter
            ? configGetter({
              key: 'uiNavigationVersion',
              platform: {
                id: platformId,
                siteId,
              },
            })
            : frontendConfig.get(
              'uiNavigationVersion',
              platformId,
              siteId,
              environment,
            );

          // iterate site file name
          Object
            .keys(siteCache)
            .forEach((fileName) => {
              siteFilesCache.set({
                environment,
                platformId,
                siteId,
                fileName,
                platformName,
                uiNavigationVersion,
                addConfigUpdateHandler,
              });
            });
        });
    });
};

const getOrCreateCacheValue = ({
  fileName,
  platformId,
  siteId,
  environment,
  uiNavigationVersion,
  platformName,
  configGetter,
  addConfigUpdateHandler,
}) => {
  const cachedValue = siteFilesCache.get(environment, platformId, siteId, fileName);

  if (cachedValue) {
    return cachedValue;
  }

  return siteFilesCache.set({
    environment,
    platformId,
    siteId,
    fileName,
    platformName,
    uiNavigationVersion,
    configGetter,
    addConfigUpdateHandler,
  });
};

const getFileContent = ({
  fileName,
  platformId,
  siteId,
  environment,
  uiNavigationVersion,
  platformName,
  configGetter,
  addConfigUpdateHandler,
}) => {
  const cacheValue = getOrCreateCacheValue({
    fileName,
    platformId,
    siteId,
    environment,
    uiNavigationVersion,
    platformName,
    configGetter,
    addConfigUpdateHandler,
  });

  // return content if exists, otherwise return null
  return contentCache.getContent(cacheValue) || null;
};

module.exports = {
  getFileContent,
};
