const restClient = require('frontend-restclient');
const buildRestClientContext = require('frontend-restclient/src/build-context');
const { PRODUCTION, SCOPE } = require('frontend-env');
const { isPlus } = require('../../../layout-type-detection');
const { restClientTimeout } = require('./config');
const logger = require('../logger');

const endpoint = site => `/frontend/sites/${site}/menu/exhibitors`;
const shouldExhibitorBeDisplayed = (isDesktop, type) => isDesktop && isPlus(type);
const request = restClient({
  timeout: restClientTimeout(PRODUCTION),
  retry: {
    maxRetries: 0,
  },
  logErrors: false,
});

const execute = ({ siteId, isDesktop, user, type, req }) => {
  const data = {
    exhibitorInfo: {},
  };

  if (!shouldExhibitorBeDisplayed(isDesktop, type)) {
    return Promise.resolve(data);
  }

  const url = endpoint(siteId);
  const payload = user ? { params: { user_id: user.id } } : { params: {} };
  let supportWebp = false;
  if (req.browser && req.browser.support) {
    supportWebp = req.browser.support.webp;
  }
  if (PRODUCTION && req.cookies.meliLab) {
    payload.params.env = SCOPE;
  }
  const config = {
    ...payload,
    context: buildRestClientContext(req),
    headers: {
      'x-client-capabilities': `webp=${supportWebp}`,
    },
  };

  return request.get(url, config)
    .then(response => response.data)
    .catch((err) => {
      logger.error({
        req,
        err,
        errorType: 'exhibitor',
        message: err.stack,
      });
      return data;
    });
};

const generateServiceContext = (req, res, params) => {
  const { platform, device, user } = req;
  const { type } = params;

  return {
    platformId: platform.id,
    siteId: platform.siteId,
    isDesktop: device.desktop,
    req,
    user,
    type,
  };
};

module.exports = (req, res, params) => execute(generateServiceContext(req, res, params));

