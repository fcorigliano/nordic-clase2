const restClient = require('frontend-restclient');
const buildRestClientContext = require('frontend-restclient/src/build-context');
const env = require('frontend-env');
const { restClientTimeout, getParams, endpoint } = require('./config');
const logger = require('../logger');
const typeMapper = require('../../../navigation/utils/type-mapper');

const { APPLICATION, PRODUCTION } = env;

const request = restClient({
  timeout: restClientTimeout(PRODUCTION),
  retry: {
    maxRetries: 0,
  },
  logErrors: false,
});

const defaultData = {};

const headersToProxy = [
  'cookie',
  'user-agent',
];

const execute = (req, res, params) => {
  const testingThisRepository = env.TEST && env.APPLICATION === 'ml-web-navigation';

  if (req.device.webView || params.hideDownloadApp || (!env.PRODUCTION && !testingThisRepository)) {
    return Promise.resolve(defaultData);
  }

  const requestParams = getParams({
    req,
    type: typeMapper(params.type),
    appId: APPLICATION,
    downloadAppi: params.downloadAppi,
  });

  const headers = headersToProxy.reduce((temporalHeaders, headerKey) => {
    const headerValue = req.headers[headerKey];
    if (headerValue) {
      temporalHeaders[headerKey] = headerValue;
    }
    return temporalHeaders;
  }, {});

  return request.get(endpoint(env), {
    params: requestParams,
    headers,
    context: buildRestClientContext(req),
  }).then(response => response.data || defaultData)
    .catch((err) => {
      logger.error({
        req,
        err,
        errorType: 'download-app',
        message: (err || {}).stack,
      });

      return defaultData;
    });
};

module.exports = execute;
