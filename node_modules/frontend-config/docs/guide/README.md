# frontend-config

> Flexible configuration for your Node.js application with zero configuration

`frontend-config` brings the default configurations for typical  Mercado Libre
 application, just drop it into your project. 

Also it lets you define a set of default parameters and extend them for different
 deployment environments (development, test, production, etc.).

## Installation

```bash
npm install frontend-config --registry https://npm.artifacts.furycloud.io/
```


# Table of Contents
- [Quick Start](#quick-start)
- [Usage](#usage)
  - [Config files examples](#Config-files-examples)
    - json
    - json5
    - js
- [Public API](#Public-API)
  - config.get
  - config.set
  - config.toJSON
  - config.use
- [Files structure](#Files-structure)
- [Usage in a build-time script such as webpack](#Usage-in-a-build-time-script-such-as-webpack)
- [Release new version](#release-new-version)
## Quick start

After installment include it in your app and only with this we have access to default configurations 

```js
const config = require('frontend-config');
const companyName = config.get('companyName', 'ML', 'MLA'); // MercadoLibre S.R.L. 
```

To configure your application create `config` folder and put some data in
 the default config file

```bash
$ mkdir config
$ vim config/default.json
```

In the example is used `json` format but configurations can be in othe formats.
 Currently supported formats:
 - `.json` - JavaScript Object Notation
 - `.json5` - JavaScript Object Notation v5 for the lazy ones and comments, 
  that is very important to explain some weird keys in configuration for the next generation of developers
 - `.js` - JavaScript in format of Node.js modules (CommonJS), brings some logic to your configuration
 

## Usage

### Config files examples

#### `.json`
```json
{
  "server": {
    "host": "localhost",
    "port": 8080
  }
}
```

#### `.json5`
```js
{
  server: {
    host: 'localhost', // Default server host
    port: 8080, // Default server port
  }
}
```

#### `.js`
```js
let config = {
  server: {
    host: 'localhost', // Default server host
    host: 8080, // Default server port
  }
};

if (something) {
  config.server.host = 3000;
}

module.exports = config;
```

### Public API

#### `config.get(key [, platform] [, site])`

Returns data associated with the key `key`. When `platform` and `site` are
 provided config will look for the data associated with corresponding site, see below for details. 

Every key may be accessed directly without using the getter, the next two
 methods are equivalent:
```js
cons host1 = config.get('server.host');
cons host2 = config.server.host;
```


#### `config.set(key, value)`

Update the value associated with the key `key`.

Again, the value may be set by using getter and directly:
```js
config.set('server.host', 'https://www.mercadolibre.com/');
config.server.host = 'https://www.mercadolibre.com/';
```


#### `config.toJSON([platform, site])`

Get an entire config object. Returns config for the site when its ID is
  provided o generic config object instead.
  
Example:
```js
const conf = config.toJSON(); // Generic config object
const siteConf = config.toJSON('ML', 'MLA'); // Config for Mercado Libre Argentina
```


#### `config.use(data)`

Update the config with a bunch of data
```js
config.get('a'); // undefined
config.use({a: 1, b: 2, c: 3});
config.get('a'); // 1
```

Can be useful when the app configuration goes from API or other remote source. Example:

```js
function updateConfig() {
  request
    .get('/api/config')
    .then(res = {
      config.use(res);
    })
}

// Look for an application updates every 5 minutes
setInterval(updateConfig, 5 * 60 * 1000);
```

## Files structure

frontend-config reads configuration files from the `config` by default,
 that can be changed by setting the `NODE_CONFIG_DIR` environment variable
 or by passing the `--NODE_CONFIG_DIR` parameter.
 
Configuration files are loading in the next order:

```
default.{EXT}
default-{environment}.{EXT}
{environment}.{EXT}
{platform}.{EXT}
{platform}-{environment}.{EXT}
{scope}.{EXT}
{scope}-{environment}.{EXT}
```

Where:
 - `EXT` - file extension, can be one or combination of `js`, `json`, `json5`
 - `environment` - Node environment (process.env.NODE_ENV)
 - `platform` - Name of the platform where the app is running. `local` in development, `fury` while running in Fury
 - `scope` - Only for apps running in Fury, it takes the name of created scope.
  In most cases an app runs on a different scopes, for example 'mla' for Argentine, 'mlb' for Brazil and so on.

## Usage in a build-time script such as webpack
If you're going to require this module in the webpack config file (or any other build-time script) then you'll need to add this env variable **only** to your `dist` script:
`NODE_CONFIG_UPDATES=false` \
What this does is disable the download of the config from our servers, since in Fury the build wont have access to the internet.

Note that this is quite an edge case since config is mostly used in server only files, due to it requiring the filesystem. Hence the special env flag.


## Release new version

Frontend-config module is maintained by the frontend-core team, please coordinate with the team in order to planning a new productive release specifying info about the change, reason and criticity of the change. It will be needed to complete the checklist inside the pull request template specifying:

- Changes are following the guidelines of this document
- Suggested release date (please give us as early as possible)
- A member of your team that will join to the release meeting\*

We mostly make production releases on low traffic times (usually at night) creating a release meeting and adding a release event on [SRE Calendar Central.](https://sre-calendar-central.adminml.com/Calendar)

>A business unit team developer should be available at the release/deploy time when deploying a productive version of `frontend-config`. The business unit team member should join a call in which the Frontend Core team will execute the deploy, once released the business unit team member should monitor and check the changes and provide feedback to the Frontend Core team.
If something fails, the Frontend Core team will rollback any change included in the `frontend-config` version. These changes should be fixed by the team that made it and once fixed they should ask for a new `frontend-config` release.

Every productive release must be backed by a rollback branch that would be useful in order to merging into master a new version without the new changes in case these fails.

Please take aware about rollbacking changes that includes new properties on configuration file. If a running up consumer fetch a config with new properties, when a new config that erase these configurations is fetched the old configurations will remain as new configuration is merged against the previous one (it does not replace the previous configuration entirely). Because of that the proper way to erase configurations is to set a `null` value to them.
Also could be useful ensure that consumers have a safe way to access non-existent configurations in order to make it easy to remove them when they are not needed anymore. Eg: `getValue('someLinksArray') || []`


The release process for `frontend-config` follows the [LibFlow](https://furydocs.io/release-process/4.16.0/guide/#/lang-es/workflows/04_libflow). And the biggest difference between how we release apps and libs using Fury CLI  is that when create a lib version, **we don't need to pass the version number as an argument on command line because Fury gets it from the package.json file**.

For example, for a package.json like this:
```jsonc
//package.json
{
  //...
  "name": "frontend-config",
  "version": "2.0.65-beta.0",
  //...

```
Running `fury create-version` will create a pre-release version called `2.0.65-beta.0`. On the other hand, for a package.json like this:
```jsonc
//package.json
{
  //...
  "name": "frontend-config",
  "version": "2.0.65",
  //...

```
Running `fury create-version` **will create a production release that will overwrite the actual config file fetched on config consumer modules**.


>The environment is determined on release process by the version number. Productive version numbers with the form {major}.{minor}.{patch} ends up in the production environment while pre-release version numbers with the form {major}.{minor}.{patch}-{pre-release} ends up in the {major}.{minor}.{patch}-{pre-release} test environment.







## License

Â© 2016 Mercado Libre
