const path = require('path');
const _ = require('lodash');
const env = require('frontend-env');
const restclient = require('frontend-restclient');
const buildFlowStarterContext = require('frontend-restclient/src/build-flow-context');
const utils = require('./utils');
const platformsProvider = require('../config/platforms');
const { environmentConstants } = require('./constants/environments');
const { UPDATE_INTERVAL } = require('./constants/intervals');
const { version: localVersion } = require('../package.json');
const { error, info } = require('./logger');
const { CONFIG_UPDATED } = require('./constants/stats');

const DEFAULT_CONFIG_DIR = 'config';

const request = restclient({
  timeout: env.DEVELOPMENT ? 30000 : 5000,
  eTagCache: true,
  logErrors: false,
});

/**
 * Configuration class
 */
class Config {
  constructor(environmentId) {
    this.environmentId = environmentId;
    this.genericStore = {};
    this.platformsStore = {};
    this.commonStore = null;
    this.currentVersion = localVersion;
    this.updateHandlers = [];

    this.opts = {
      CONFIG_DIR: path.resolve(utils.resolveParam('NODE_CONFIG_DIR', DEFAULT_CONFIG_DIR)),
    };
    this.use({ version: localVersion });

    // Set up the updates checker. Can be disabled by setting the NODE_CONFIG_UPDATES to false
    const useUpdates = env.NODE_CONFIG_UPDATES === 'true'
      || (env.PRODUCTION && !env.IS_CI && env.FURY && env.NODE_CONFIG_UPDATES !== 'false');

    if (useUpdates) {
      this.checkUpdates(UPDATE_INTERVAL);
    }
    // this binding
    this.use = this.use.bind(this);
    this.toJSON = this.toJSON.bind(this);
    this.checkUpdates = this.checkUpdates.bind(this);
    this._get = this._get.bind(this);
    this._set = this._set.bind(this);
  }

  use(extraData = {}, checkVersion = false) {
    const invalidData = extraData === null || typeof extraData !== 'object';
    if (invalidData) {
      error({
        message: 'Invalid config data',
        statName: 'invalid_config_data',
        environmentId: this.environmentId,
      });
      return;
    }

    if (checkVersion && extraData.version) {
      if (this.currentVersion === extraData.version) {
        return;
      }
      info({
        message: `Frontend-config ${this.environmentId} environment updated from v${this.currentVersion} to v${extraData.version}`,
        statName: CONFIG_UPDATED,
        tags: { configVersion: extraData.version },
      });
    }

    this.currentVersion = extraData.version;

    // First load
    if (!this.commonStore) {
      this.commonStore = {
        version: localVersion,
      };

      // Load local platforms defaults
      const fileNameSuffix = environmentConstants[this.environmentId].suffix;
      const localConfiguration = require(path.resolve( // eslint-disable-line
        __dirname,
        '../config',
        `defaults${fileNameSuffix ? `-${fileNameSuffix}` : ''}.js`,
      ));

      _.extend(this.commonStore, localConfiguration);

      // Load config data from the app
      const loadedFilesStore = utils.loadConfigFiles(this.opts.CONFIG_DIR);

      // Merge all data in a single place
      loadedFilesStore.forEach((cfg) => {
        this.commonStore = utils.deepMerge(this.commonStore, cfg.data);
      });

      // Merge the config data form command line or environment
      const envConfigData = utils.resolveParam('NODE_CONFIG', null);
      if (envConfigData) {
        try {
          this.commonStore = utils.deepMerge(this.commonStore, JSON.parse(envConfigData));
        } catch (e) {
          throw new Error('NODE_CONFIG param has a wrong format, should be JSON.stringified object');
        }
      }
    }

    // A local copy of common store merged with extra data
    const tempStore = utils.deepMerge({}, this.commonStore, extraData);

    // The separation of data into genericStore and platformsStore is intentionally and to improve the performance.
    // platformsStore has all the possible data for every platform that generates the memory overhead, for current
    // platforms is about 600K that is relatively cheap. Searching for the platform/site values dynamically resulting
    // ~50000 ops while searching in preconfigured data is more than 10X better.
    this.genericStore = _.omit(tempStore, platformsProvider.platforms);
    const temporaryPlatformsStore = _.pick(tempStore, platformsProvider.platforms);

    // Empty the platform dependent store
    this.platformsStore = {};

    // Use data from default platform as common data for every site
    const platformsCommons = _.omit(tempStore[platformsProvider.defaultPlatform],
      platformsProvider.sites[platformsProvider.defaultPlatform]);

    // Fill an every site with a common platform dependent data and the data configured for those site
    platformsProvider.platforms.forEach((platform) => {
      if (platformsProvider.sites[platform]) {
        platformsProvider.sites[platform].forEach((site) => {
          if (!this.platformsStore[platform]) {
            this.platformsStore[platform] = {};
          }

          // Merge data from common platform and the current one
          const platformCommons = platformsProvider.defaultPlatform === platform
            ? platformsCommons
            : utils.deepMerge({}, platformsCommons, _.omit(tempStore[platform] || {}, platformsProvider.sites[platform]));

          this.platformsStore[platform][site] = utils.deepMerge(
            {},
            platformCommons,
            temporaryPlatformsStore[platform] && temporaryPlatformsStore[platform][site]
              ? temporaryPlatformsStore[platform][site]
              : {},
          );
        });
      }
    });

    this.notifyHandlers();
  }

  notifyHandlers() {
    this.updateHandlers.forEach(updateHandler => updateHandler());
  }

  /**
   * Registers a handler that will be called each time the config is updated
   * @param {function} handler Handler to register
   */
  addUpdateHandler(handler) {
    this.updateHandlers.push(handler);
  }

  /**
   * Removes a previously registered handler
   * @param {function} handler Handler to remove
   */
  removeUpdateHandler(handler) {
    this.updateHandlers = this.updateHandlers.filter(updateHandler => updateHandler !== handler);
  }

  /**
   * Get an entire config object
   *
   * Returns config for platform/site when it provided o generic config object instead
   *
   * @param {String} platform Mercado Libre Platform ID. Optional
   * @param {String} site Mercado Libre Site ID. Optional
   */
  toJSON(platform, site) {
    let platformConfig = {};

    if (platform) {
      if (platformsProvider.platforms.indexOf(platform) === -1) {
        throw new Error(`Unsupported platform ${platform}`);
      }
      platformConfig = this.platformsStore[platform][site];
    }

    return utils.deepMerge({}, this.genericStore, platformConfig);
  }

  /**
   * Check for the config updates from the internal API
   *
   * @param {number} interval Time in ms to check for the periodic updates
   * @returns {Promise} A request object
   */
  checkUpdates(interval = 0) {
    return request
      .get(`/${environmentConstants[this.environmentId].endpoint}`, {
        retry: {
          maxRetries: 3,
          delay: 500,
          // Do not try to do many retries
          // Better cancel the current request and make a new one after UPDATE_INTERVAL ms
          maxDelay: UPDATE_INTERVAL,
          factor: 2,
        },
        context: buildFlowStarterContext(),
      })
      .then((response) => {
        this.use(response.data, true);
        if (interval > 0) {
          // eslint-disable-next-line no-unused-vars
          const updateTimer = setTimeout(() => { this.checkUpdates(interval); }, interval);
        }

        return response;
      })
      .catch((err) => {
        if (interval > 0) {
          // eslint-disable-next-line no-unused-vars
          const updateTimer = setTimeout(() => { this.checkUpdates(interval); }, interval);
        }

        let errorString;
        try {
          errorString = JSON.stringify(err);
        } catch (stringifyError) {
          errorString = `Cannot stringify error. Stringify error message: "${stringifyError && stringifyError.message ? stringifyError.message : ''}"`;
        }
        error({
          message: 'Error getting configuration from API',
          statName: 'update_error',
          tags: {
            errorMessage: err && err.message,
            errorStack: err && err.stack,
            errorString,
          },
          environmentId: this.environmentId,
        });
      });
  }

  /**
   * Generic config setter
   *
   * @param {String} key
   * @param {*} value
   * @return {*}
   * @private
   */
  _set(key, value) {
    if (typeof key !== 'string') {
      throw new Error('Config key must be a string. Use config.use() instead if you want to set an object');
    }

    let store;
    const parts = key.split('.');
    if (parts.length > 2 && platformsProvider.platforms.indexOf(parts[0]) !== -1) {
      store = this.platformsStore;
    } else {
      store = this.genericStore;
    }

    utils.objectSetDeep(store, key, value);

    this.notifyHandlers();
  }

  /**
   * Generic config getter
   *
   * @param {String} key
   * @param {String} platform
   * @param {String} site
   * @return {*}
   * @private
   */
  _get(key, platform, site) {
    // `env` should always has the right value of NODE_ENV, so it resolved dynamically here instead of setting it
    // directly to the config object or storing it to the config store
    if (key === 'env') {
      return utils.resolveParam('NODE_ENV', 'development');
    }

    if (platform && platformsProvider.platforms.indexOf(platform) !== -1 && site) {
      return _.cloneDeep(utils.objectGetDeep(this.platformsStore, `${platform}.${site}.${key}`));
    }
    return _.cloneDeep(utils.objectGetDeep(this.genericStore, key));
  }
}

module.exports = Config;
