const fs = require('fs');
const path = require('path');
const JSON5 = require('json5');
const argv = require('minimist')(process.argv.slice(2));

/**
 * Initialize a parameter from the command line or process environment
 *
 * This method looks for the parameter in the command line in the format
 * --PARAMETER=VALUE, then from the process environment, then from the
 * default specified as an argument.
 *
 * @method resolveParam
 * @param paramName {String} Name of the parameter
 * @param [defaultValue] {*} Default value of the parameter
 * @return {*} Resolved value or the default one instead
 */
exports.resolveParam = function resolveParam(paramName, defaultValue) {
  return argv[paramName] || process.env[paramName] || defaultValue;
};


/**
 * Parse the string with the specified format and return an object.
 *
 * Available parsers:
 *   json - File is parsed using the native JSON.parse()
 *   json5 - Parsed with a JSON5 parser
 *
 * @private
 * @function parseString
 * @param {string} content The string to be parsed
 * @param {string} format The format to be parsed as
 * @return {Object} Parsed configuration object
 */
function parseString(content, format) {
  // Initialize
  let configObject = null;

  // Parse the file based on the provided format (extension)
  if (format === 'json') {
    try {
      configObject = JSON.parse(content);
    } catch (e) {
      // When JSON file has errors try to parse it as JSON5
      format = 'json5'; // eslint-disable-line no-param-reassign
    }
  }

  if (format === 'json5') {
    configObject = JSON5.parse(content);
  }

  return configObject;
}

/**
 * Parse and return the specified configuration file.
 *
 * The file extension determines the parser to use.
 *   .js = File to run that has a module.exports containing the config object
 *   Other supported file types (json, json5) are parsed with util.parseString.
 *
 * This method performs synchronous file operations, and should not be called
 * after synchronous module loading.
 *
 * @private
 * @function
 * @param {string} fullFilename The full file path and name
 * @return {Object} The configuration object parsed from the file
 */
function parseFile(fullFilename) {
  let extension = path.extname(fullFilename).toLowerCase();
  let configObject = null;
  let fileContent = null;

  // Note that all methods of the parseFile method are synchronous. This is appropriate during
  // module loading which is a synchronous operation by self.

  // path.extname returns the extension prefixed by a dot.
  // Remove the dot but only in case when the real extension is present.
  if (extension.indexOf('.') !== -1) {
    extension = extension.replace('.', '');
  }

  // Return null if the file doesn't exist.
  try {
    const stats = fs.statSync(fullFilename);
    if (!stats || !stats.isFile() || stats.size < 1) {
      return null;
    }
  } catch (ex) {
    return null;
  }

  // Parse the file based on extension
  try {
    if (extension === 'js') {
      // Use native parser for .js files
      configObject = require(fullFilename); // eslint-disable-line
    } else {
      // Try loading the file.
      // Read the file's content as an UTF8 string
      fileContent = fs.readFileSync(fullFilename, 'UTF-8');
      // Remove BOM marker in any
      fileContent = fileContent.replace(/^\uFEFF/, '');

      configObject = parseString(fileContent, extension);
    }
  } catch (ex) {
    throw new Error(`Cannot parse config file: '${fullFilename}': ${ex}`);
  }

  return configObject;
}

/**
 * Load and parse all config files with data
 *
 * Loading order:
 *   default.EXT
 *   default-{environment}.EXT
 *   {environment}.EXT
 *   {platform}.EXT
 *   {platform}-{environment}.EXT
 *   {scope}.EXT
 *   {scope}-{environment}.EXT
 *     Finally, custom environment variables can override all files. Still TODO :(
 *
 * @param {String} baseDir Full path to the config files directory
 * @return {Array} List of all loaded files with data
 */
exports.loadConfigFiles = function loadConfigFiles(baseDir) {
  const env = this.resolveParam('NODE_ENV', 'development');
  const platform = this.resolveParam('PLATFORM', 'local');
  const scope = this.resolveParam('SCOPE', null);
  const baseNames = ['default', `default-${env}`, env];
  const extensions = ['js', 'json', 'json5'];
  const loadedFiles = [];

  // Platform dependent config, in Fury it is always 'fury' and 'local' otherwise
  if (platform) {
    baseNames.push(platform, `${platform}-${env}`);
  }

  // Scope dependent config, in Fury it takes the name of created scope
  // In most cases the app runs on a different scopes, for example 'mla' for Argentine, 'mlb' for Brazil and so on.
  // Using the scope dependent config we can inject data that overrides defaults or that has sense only for specific
  // scope (country, group of countries, test server, etc.)
  if (scope) {
    baseNames.push(scope, `${scope}-${env}`);
  }

  baseNames.forEach((baseName) => {
    extensions.forEach((ext) => {
      const configFile = path.join(baseDir, `${baseName}.${ext}`);
      const configObj = parseFile(configFile);

      // Keep track of this configuration sources but excluding empty ones
      // Be careful since `typeof null === 'object'`
      if (typeof configObj === 'object' && configObj !== null) {
        loadedFiles.push({
          name: configFile,
          data: configObj,
        });
      }
    });
  });

  return loadedFiles;
};


/**
 * Returns the value from an object by its path expression.
 *
 * @param {Object} obj An object to look for value in
 * @param {String} expression The property path expression.
 * @return {*}
 * @example
 * objectGetDeep({ x: { y: 'z' } }, 'x')
 * // { y: 'z' }
 *
 * objectGetDeep({ x: { y: 'z' } }, 'x.y')
 * // 'z'
 *
 * objectGetDeep({ x: { y: 'z' } }, 'x.a')
 * // undefined
 */
exports.objectGetDeep = function objectGetDeep(obj, expression) {
  if (!(obj && expression && typeof expression === 'string')) {
    throw new Error('both object and expression args are required');
  }

  return expression
    .trim()
    .split('.')
    .reduce((prev, curr) => {
      const arrayMatch = curr.match(/(.*?)\[(.*?)\]/);

      if (arrayMatch) {
        return prev && prev[arrayMatch[1]][arrayMatch[2]];
      }
      return prev && prev[curr];
    }, obj);
};

/**
 * Set the value to an object by its path expression.
 *
 * @param {Object} obj An object to set the value into
 * @param {String} expression The property path expression.
 * @param {*} value
 * @example
 * objectSetDeep({ x: 1 }, 'x.y', 'z')
 * // { x: { y: 'z' } }
 *
 * objectSetDeep({ x: { y: 'z' } }, 'x.y.z', 1)
 * // { x: { y: { z:  1 } }
 */
exports.objectSetDeep = function objectSetDeep(obj, expression, value) {
  const ancestorsPath = expression.split('.');

  let i = 0;
  for (; i < ancestorsPath.length - 1; i += 1) {
    if (!obj[ancestorsPath[i]]) {
      obj[ancestorsPath[i]] = {};
    }
    obj = obj[ancestorsPath[i]]; // eslint-disable-line no-param-reassign
  }

  obj[ancestorsPath[i]] = value;
};

/**
 * Deep-merges source parameters. If a source parameter is an array skips deep merge on it
 *
 * @param {Object} obj An object to set the value into
 * @param {...*} sources Sources to merge
 * @example
 * deepMerge({ w: 1 }, { x: { y: 2, z: 3 } }, { x: { z: 4 } })
 * // { w: 1, x: { y: 2, z: 4 } }
 */
const deepMerge = (...sources) => sources.reduce((result, source) => {
  // If the source is an array the result should be that array no matter previous sources result (no deep merge)
  if (Array.isArray(source)) {
    return source;
  }

  const sourceType = typeof source;

  // If the source is an object iterate over its keys and merge them with previous sources result keys
  if (sourceType === 'object' && source !== null) {
    // If previous sources result is a non-array-object just take it as the initial base object, otherwise discard it
    const initialObject = typeof result === 'object' && !Array.isArray(result)
      ? { ...result }
      : {};


    // Deep-merges source object with previous sources result
    return Object
      .keys(source)
      .reduce((temporalToReturn, sourceKey) => {
        temporalToReturn[sourceKey] = deepMerge(temporalToReturn[sourceKey], source[sourceKey]);
        return temporalToReturn;
      }, initialObject);
  }

  // If the source is not an array, a not-null-object or undefined (eg: string, number, null)
  if (sourceType !== 'undefined') {
    return source;
  }

  // source type is undefined, keep previous sources result
  return result;
}, undefined);

exports.deepMerge = deepMerge;
