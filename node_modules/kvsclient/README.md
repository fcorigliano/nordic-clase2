# Node.js KVS client

`node-kvsclient` is the Node.js client module to interact with KVS service

## Install

```
npm install --save kvsclient
```

## Current Version

kvsclient@1.0.7

## Usage

### Import client:

```javascript
const kvsmodule = require('kvsclient');
```

### Classes available:

```javascript
const Item = kvsmodule.Item,
      Items = kvsmodule.Items,
      KvsClient = kvsmodule.KvsClient,
      ContainerKvsClient = kvsmodule.ContainerKvsClient,
	  KvsApiConfiguration = kvsModule.KvsApiConfiguration;
```


### Create an instance

Two implementations available:

    KvsClient: Useful when your app interacts with several containers of the same cluster.

    ContainerKvsClient: (Wrapper for KvsClient). Lets you specify container name on client instantiation. Useful when your app 
    interacts with just one container or you want to have a different client for each container.

```javascript

let client = new KvsClient()

let client = new ContainerKvsClient({
	container: 'container'
});
```

or specifying delegate to set Kvs Config. Read and write timeouts are set to 100ms if kvsconfig is not set.

Keys can be encoded for GET, BATCHGET, BULKGET, DELETE, BATCHDELETE, BULKDELETE operations. The encoding is turned off unless it is specified.

The URL encoding type allows keys with special characters.

```javascript

let kvsclient = new KvsClient({
	kvsApiConfiguration: new KvsApiConfiguration ({
		readTimeout: 2000,
		writeTimeout: 2000,
		encodingType: "URL" // NONE, URL
	})
})

let client = new ContainerKvsClient({
	container: 'container',
	delegate:kvsclient
});
```

### Set Log Level
 ```javascript
 KvsClient.setLogLevel('level'); // error, info, warn, debug
 ContainerKvsClient.setLogLevel('level');// error, info, warn, debug
 ```

### Basics default methods

##### Get (Null returned if not found):

```javascript
client
    .get('container','key')
	.then(item => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .get('key')
	.then(item => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

##### Save: 

```javascript
client
    .save('container',item)
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .save(item)
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```
    
##### Update:

```javascript
client
    .update('container',item)
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .update(item)
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

##### Delete:

```javascript
client
    .delete('container','key')
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .delete('key')
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

### Basics batch methods (atomic)

Batch read operations can be done with 100 elements as maximum at a time while batch write operations have a limit of 25 elements.

##### BatchGet:

```javascript
client
    .batchGet('container',['key1','key2'])
	.then(items => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .batchGet(['key1','key2'])
	.then(items => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

##### BatchSave: 

```javascript
client
    .batchSave('container',items)
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .batchSave(items)
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```
    
##### BatchUpdate:

```javascript
client
    .batchUpdate('container',items)
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .batchUpdate(items)
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

##### BatchDelete:

```javascript
client
    .batchDelete('container',['key1','key2']])
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .batchDelete(['key1','key2']])
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

### Basics bulk methods (not atomic)

If an error is detected while bulkOperating with an item, an error will be set
for that item in the Items collection response. 

Bulk read operations can be done with 100 elements as maximum at a time while bulk write operations have a limit of 25 elements.
##### BulkGet (items does not contain not found keys):

```javascript
client
    .bulkGet('container',['key1','key2'])
	.then(items => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .bulkGet(['key1','key2'])
	.then(items => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

##### BulkSave: 

```javascript
client
    .bulkSave('container',items)
	.then(items => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .bulkSave(items)
	.then(items => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```
    
##### BulkUpdate:

```javascript
client
    .bulkUpdate('container',items)
	.then(items => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .bulkUpdate(items)
	.then(items => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

##### BulkDelete:

```javascript
client
    .bulkDelete('container',['key1','key2']])
	.then(items => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .bulkDelete(['key1','key2']])
	.then(items => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```
### Counters

##### GetCounter:

```javascript
client
    .getCounter('container','key')
	.then(numericValue => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .getCounter('key')
	.then(numericValue => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

##### IncrementCounter:

```javascript
client
    .incrementCounter('container','key',numericValue)
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .incrementCounter('key',numericValue)
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

##### DecrementCounter:

```javascript
client
    .decrementCounter('container','key',numericValue)
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .decrementCounter('key',numericValue)
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

##### ResetCounter:

```javascript
client
    .resetCounter('container','key')
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

or (wrapper version)

```javascript
client
    .resetCounter('key')
	.then(emptyResponse => {
		// Do something
	})
	.catch(error => {
		// Handle error	
	});
```

#### Item: basic storage unit


```javascript
class Item {
    let key,value,version,ttl,error;

    constructor(mapProperties){
    }

    hasError();
    getValueAsString();
}
```

Expiration on keys (TTL) is mesured in seconds.
If you want keys not to expire, then you should not set a value for that property in the Item.

#### Items: Collection of item
```javascript
class Items {
    constructor(){
    }

    add(item);
    get(index);
    addAll(items);
    size();
    isEmpty();
    haveErrors();
    getOks();
    getErrors();
    getConflictErrors();
    getKeys();
    [Symbol.iterator]();

}
```

##### Setting encoder for complex keys
```javascript
    let kvsclient = new KvsClient({
		kvsApiConfiguration: new KvsApiConfiguration ({
			encodingType: "URL" // NONE, URL
		})
	})

	let client = new ContainerKvsClient({
		container: 'container',
		delegate:kvsclient
	});
```

In cases when your keys contain unsafe ASCII characters, you need to set on client configuration the encoder so the key
can be sent safely as URL params in all operations that require it.

## Errors

Errors thrown by the client are instance of KvsError and have status,code and message properties so you can check the result of the operation. 

## Handling Throttling

When traffic over a container exceeds the one defined for it, KVS API will throttle the request. This is reflected in the client by throwing a RejectedExecutionError, you should catch it to handle this particular event.

## Usage from Melicloud

Although usage from Melicloud is discouraged, in certain cases you can reference your container from there.

- Define an skeleton app in Fury, and create a KVS as usual.
- Assuming your app is _your-app_ and your container is _your-container_, you should define these environment variables
  - KEY_VALUE_STORE_YOUR_CONTAINER_END_POINT_READ=http://read._cluster_.kvs.furycloud.io
  - KEY_VALUE_STORE_YOUR_CONTAINER_END_POINT_WRITE=http://write._cluster_.kvs.furycloud.io
  - KEY_VALUE_STORE_YOUR_CONTAINER_CONTAINER_NAME=your_container__your_app

Please ask KVS team in advance for which _cluster_ should be applied. Also notice dash to underscore conversion in container and variable names.

## Run tests

```
npm test
```

With coverage

```
npm run-script coverage
```

## Mocking for test or development 

This client has already integrated a mock plugin that lets you intercept any desired url 
and specify mock response for it: https://github.com/mercadolibre/frontend-mocks/tree/develop  

For test or desa mocking you need to intercept kvstest.mock.com base url and then specify mocks for
the different http methods / uris you want.

Examples: 

	https://github.com/mercadolibre/node-meli-toolkit/tree/master/kvsclient/mocks

	https://github.com/mercadolibre/node-meli-toolkit/blob/master/kvsclient/test/KvsApiClientTest.js

## Development Server

WIP

## Questions?

[services@mercadolibre.com](mailto:services@mercadolibre.com)

[horacio.casatti@mercadolibre.com](mailto:horacio.casatti@mercadolibre.com)


