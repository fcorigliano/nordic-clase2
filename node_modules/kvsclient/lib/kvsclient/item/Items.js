const _ = require('lodash');
const Constants = require('../constants/Constants');

class Items {
  constructor() {
    this._array = [];
  }

  add(item) {
    if (typeof item !== 'object' || (typeof item === 'object' && item.constructor.name !== 'Item')) {
      throw new TypeError('Allowed to add item objects only');
    }
    this._array.push(item);
    return this;
  }

  get(index) {
    return this._array[index];
  }

  addAll(items) {
    if (typeof items !== 'object' || (typeof items === 'object' && items.constructor.name !== 'Items')) {
      throw new TypeError('Allowed to add item objects only');
    }
    this._array.push(...items._array);
    return this;
  }

  size() {
    return this._array.length;
  }

  isEmpty() {
    return this.size() === 0;
  }

  haveErrors() {
    return Boolean(this._array.find(item => !_.isNil(item.error)));
  }

  getOks() {
    const items = new Items();
    this._array.forEach((item) => {
      if (_.isNil(item.error)) {
        items.add(item);
      }
    });

    return items;
  }

  getErrors() {
    const items = new Items();
    this._array.forEach((item) => {
      if (!_.isNil(item.error) && Constants.ERROR_TYPES.UNEXPECTED === item.error) {
        items.add(item);
      }
    });

    return items;
  }

  getConflictErrors() {
    const items = new Items();
    this._array.forEach((item) => {
      if (!_.isNil(item.error) && Constants.ERROR_TYPES.CONFLICT === item.error) {
        items.add(item);
      }
    });

    return items;
  }

  getKeys() {
    return this._array.map(item => item.key);
  }

  [Symbol.iterator]() {
    let index = -1;
    const array = this._array;

    return {
      next: () => ({ value: array[++index], done: !(index in array) }),
    };
  }
}


module.exports = Items;
