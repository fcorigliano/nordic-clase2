const _ = require('lodash');
const RestClient = require('frontend-restclient');
const HttpStatus = require('http-status-codes');
const pkg = require('../package.json');
const dog = require('./kvsclient/utils/dog');
const KvsApiConfiguration = require('./config/KvsApiConfiguration');
const Item = require('./kvsclient/item/Item');
const Items = require('./kvsclient/item/Items');
const KvsUtils = require('./kvsclient/utils/KvsUtils');
const KvsErrorHandler = require('./kvsclient/KvsErrorHandler');
const Constants = require('./kvsclient/constants/Constants');
const RequestUtils = require('./kvsclient/utils/RequestUtils');
const log = require('./logger');
const KeysUtils = require('./kvsclient/utils/KeysUtils');

const restclient = RestClient();

function getHeaders(items) {
  const headers = {};

  const versions = [];
  const ttls = [];
  for (const item of items) {
    versions.push(item.version);
    ttls.push(item.ttl);
  }
  headers['X-Kvs-Versions'] = versions.join();
  headers['X-Kvs-Ttls'] = ttls.join();
  return headers;
}

function setHeaders(headers, items) {
  let versions;
  let ttls;
  const lowerHeaders = RequestUtils.lowerHeaders(headers);

  if (!_.isNil(lowerHeaders['x-kvs-versions'])) {
    versions = lowerHeaders['x-kvs-versions'].split(',');
    for (let i = 0; i < versions.length; i++) {
      items.get(i).version = parseInt(versions[i], 10);
    }
  }

  if (!_.isNil(lowerHeaders['x-kvs-ttls'])) {
    ttls = lowerHeaders['x-kvs-ttls'].split(',');
    for (let i = 0; i < ttls.length; i++) {
      items.get(i).ttl = parseInt(ttls[i], 10);
    }
  }
}

function checkKeysType(key) {
  return typeof key === 'string';
}

/**
 * Calculates the difference between some timestamp in the past and now
 * @param {number} start Starting timestamp in millis
 * @returns {number} THe difference in millis
 */
function getTimeDiff(start) {
  return Date.now() - start;
}


function ensureErrorResponseDuration(error, start) {
  if (error && error.response) {
    error.response.duration = getTimeDiff(start);
  }
}

class KvsClient {
  constructor(properties = {}) {
    const { kvsApiConfiguration } = properties;

    if (kvsApiConfiguration && kvsApiConfiguration instanceof KvsApiConfiguration) {
      this._kvsApiConfiguration = kvsApiConfiguration;
    } else {
      this._kvsApiConfiguration = new KvsApiConfiguration();
    }

    this._restclient = new Map();
  }

  get kvsApiConfiguration() {
    return this._kvsApiConfiguration;
  }

  set kvsApiConfiguration(kvsApiConfiguration) {
    this._kvsApiConfiguration = kvsApiConfiguration;
  }

  get version() {
    return pkg.version;
  }

  static setLogLevel(level) {
    log.setLogLevel(level);
  }

  get(container, key) {
    container = KvsUtils.normalizeContainer(container);
    const queryString = KvsApiConfiguration.getQueryString('DEFAULT', null);

    if (_.isNil(key)) {
      throw new TypeError('key should not be null');
    }
    key = key.toString();

    const config = {
      baseURL: KvsApiConfiguration.getBaseUrl(Constants.METHODS.READ, container),
      timeout: this._kvsApiConfiguration.getTimeout(Constants.METHODS.READ),
      cache: false,
    };

    const encodedKey = this.encodeKey(key);

    const start = Date.now();
    return restclient
      .get(KvsApiConfiguration.getUri(container, encodedKey, queryString), config)
      .then((response) => {
        response.duration = getTimeDiff(start);
        let item = null;
        const items = new Items();
        if (response.status === HttpStatus.OK) {
          dog.recordCompoundMetric('kvsclient.get', response.duration, { container });
          dog.recordSimpleMetric('kvsclient.get.status', 1, { container, status: response.status });
          item = new Item({ key, value: response.data });
          setHeaders(response.headers, items.add(item));
          return items.get(0);
        }
        return KvsErrorHandler.handleKvsGetError(container, key, { response });
      })
      .catch((error) => {
        ensureErrorResponseDuration(error, start);
        KvsErrorHandler.handleKvsGetError(container, key, error);

        // All errors except HttpStatus.NOT_FOUND throws an error in KvsErrorHandler.handleKvsGetError so additional
        // check for this error code is not necessary here
        return null;
      });
  }

  save(container, item) {
    container = KvsUtils.normalizeContainer(container);
    const queryString = KvsApiConfiguration.getQueryString('DEFAULT', null);

    if (_.isNil(item) || _.isNil(item.key) || _.isNil(item.value)) {
      throw new TypeError('item,key,value should not be null');
    } else if (typeof item !== 'object' || (typeof item === 'object' && item.constructor.name !== 'Item')) {
      throw new TypeError('not allowed to save something different to item');
    }

    const json = {
      key: item.key,
      value: item.getValueAsString(),
    };

    const config = {
      baseURL: KvsApiConfiguration.getBaseUrl(Constants.METHODS.WRITE, container),
      timeout: this._kvsApiConfiguration.getTimeout(Constants.METHODS.WRITE),
      data: json,
      headers: getHeaders(new Items().add(item)),
    };

    const start = Date.now();
    return restclient
      .post(KvsApiConfiguration.getUri(container, null, queryString), config)
      .then((response) => {
        response.duration = getTimeDiff(start);
        if (response.status !== HttpStatus.CREATED) {
          KvsErrorHandler.handleKvsSaveError(container, item, { response });
        } else {
          dog.recordCompoundMetric('kvsclient.save', response.duration, { container });
          dog.recordSimpleMetric('kvsclient.save.status', 1, { container, status: response.status });
        }
      })
      .catch((error) => {
        ensureErrorResponseDuration(error, start);
        KvsErrorHandler.handleKvsSaveError(container, item, error);
      });
  }

  update(container, item) {
    container = KvsUtils.normalizeContainer(container);
    const queryString = KvsApiConfiguration.getQueryString('DEFAULT', null);

    if (_.isNil(item) || _.isNil(item.value) || _.isNil(item.key)) {
      throw new TypeError('item,key,value should not be null');
    } else if (typeof item !== 'object' || (typeof item === 'object' && item.constructor.name !== 'Item')) {
      throw new TypeError('not allowed to update something different to item');
    }

    const json = {
      key: item.key,
      value: item.getValueAsString(),
    };

    const config = {
      baseURL: KvsApiConfiguration.getBaseUrl(Constants.METHODS.WRITE, container),
      timeout: this._kvsApiConfiguration.getTimeout(Constants.METHODS.WRITE),
      data: json,
      headers: getHeaders(new Items().add(item)),
    };

    const encodedKey = this.encodeKey(item.key);

    const start = Date.now();
    return restclient
      .put(KvsApiConfiguration.getUri(container, encodedKey, queryString), config)
      .then((response) => {
        response.duration = getTimeDiff(start);

        if (response.status === HttpStatus.OK || response.status === HttpStatus.NO_CONTENT) {
          dog.recordCompoundMetric('kvsclient.update', response.duration, { container });
          dog.recordSimpleMetric('kvsclient.update.status', 1, { container, status: response.status });
          return;
        }
        KvsErrorHandler.handleKvsUpdateError(container, item, { response });
      })
      .catch((error) => {
        ensureErrorResponseDuration(error, start);
        KvsErrorHandler.handleKvsUpdateError(container, item, error);
      });
  }

  delete(container, key) {
    container = KvsUtils.normalizeContainer(container);
    const queryString = KvsApiConfiguration.getQueryString('DEFAULT', null);

    if (_.isNil(key)) {
      throw new TypeError('Key should not be null');
    }
    key = key.toString();
    const start = Date.now();

    const encodedKey = this.encodeKey(key);

    const config = {
      baseURL: KvsApiConfiguration.getBaseUrl(Constants.METHODS.WRITE, container),
      timeout: this._kvsApiConfiguration.getTimeout(Constants.METHODS.WRITE),
    };

    return restclient
      .delete(KvsApiConfiguration.getUri(container, encodedKey, queryString), config)
      .then((response) => {
        response.duration = getTimeDiff(start);

        if (response.status === HttpStatus.NO_CONTENT) {
          dog.recordCompoundMetric('kvsclient.delete', response.duration, { container });
          dog.recordSimpleMetric('kvsclient.delete.status', 1, { container, status: response.status });
          return;
        }

        KvsErrorHandler.handleKvsDeleteError(container, key, { response });
      })
      .catch((error) => {
        if (error.response && error.response.status === HttpStatus.NOT_FOUND) {
          return;
        }

        ensureErrorResponseDuration(error, start);
        KvsErrorHandler.handleKvsDeleteError(container, key, error);
      });
  }

  batchGet(container, keys) {
    if (!_.isArray(keys)) {
      throw new TypeError('keys should be an array');
    } else if (keys.length === 0) {
      throw new TypeError('keys should not be null or empty');
    } else if (!keys.every(checkKeysType)) {
      throw new TypeError('keys should be string');
    }

    container = KvsUtils.normalizeContainer(container);
    const encodedKeys = this.encodeKeys(keys);
    const queryString = KvsApiConfiguration.getQueryString('BATCH', encodedKeys);

    const config = {
      baseURL: KvsApiConfiguration.getBaseUrl(Constants.METHODS.READ, container),
      timeout: this._kvsApiConfiguration.getTimeout(Constants.METHODS.READ),
      cache: false,
    };

    const start = Date.now();
    return restclient
      .get(KvsApiConfiguration.getUri(container, null, queryString), config)
      .then((response) => { // eslint-disable-line consistent-return
        response.duration = getTimeDiff(start);

        const items = new Items();
        if (response.status === HttpStatus.OK) {
          _.forEach(response.data, (item) => {
            items.add(new Item({ key: item.key, value: item.value }));
          });
          setHeaders(response.headers, items);

          dog.recordCompoundMetric('kvsclient.batchGet', response.duration, { container });
          dog.recordSimpleMetric('kvsclient.batchGet.status', 1, { container, status: response.status });
          return items;
        }

        KvsErrorHandler.handleKvsBatchGetError(container, keys, { response });
      })
      .catch((error) => {
        ensureErrorResponseDuration(error, start);
        KvsErrorHandler.handleKvsBatchGetError(container, keys, error);
      });
  }

  batchSave(container, items) {
    if (_.isNil(items)) {
      throw new TypeError('items should not be null');
    } else if (typeof items !== 'object' || (typeof items === 'object' && items.constructor.name !== 'Items')) {
      throw new TypeError('not allowed to batch save something different to items');
    } else if (items.size() === 0) {
      throw new TypeError('items should not be empty');
    }
    const body = [];
    for (const item of items) {
      body.push({ key: item.key, value: item.getValueAsString() });
    }

    container = KvsUtils.normalizeContainer(container);

    const config = {
      baseURL: KvsApiConfiguration.getBaseUrl(Constants.METHODS.WRITE, container),
      timeout: this._kvsApiConfiguration.getTimeout(Constants.METHODS.WRITE),
      data: body,
      headers: getHeaders(items),
    };

    const queryString = KvsApiConfiguration.getQueryString('BATCH', null);

    const start = Date.now();
    return restclient
      .post(KvsApiConfiguration.getUri(container, null, queryString), config)
      .then((response) => {
        response.duration = getTimeDiff(start);

        if (response.status !== HttpStatus.CREATED) {
          KvsErrorHandler.handleKvsBatchSaveError(container, items, { response });
        } else {
          dog.recordCompoundMetric('kvsclient.batchSave', response.duration, { container });
          dog.recordSimpleMetric('kvsclient.batchSave.status', 1, { container, status: response.status });
        }
      })
      .catch((error) => {
        ensureErrorResponseDuration(error, start);
        KvsErrorHandler.handleKvsBatchSaveError(container, items, error);
      });
  }

  batchUpdate(container, items) {
    if (_.isNil(items)) {
      throw new TypeError('items should not be null');
    } else if (typeof items !== 'object' || (typeof items === 'object' && items.constructor.name !== 'Items')) {
      throw new TypeError('not allowed to batch update something different to items');
    } else if (items.size() === 0) {
      throw new TypeError('items should not be empty');
    }

    const body = [];
    for (const item of items) {
      body.push({ key: item.key, value: item.getValueAsString() });
    }

    container = KvsUtils.normalizeContainer(container);

    const config = {
      baseURL: KvsApiConfiguration.getBaseUrl(Constants.METHODS.WRITE, container),
      timeout: this._kvsApiConfiguration.getTimeout(Constants.METHODS.WRITE),
      data: body,
      headers: getHeaders(items),
    };

    const queryString = KvsApiConfiguration.getQueryString('BATCH', null);

    const start = Date.now();
    return restclient
      .put(KvsApiConfiguration.getUri(container, null, queryString), config)
      .then((response) => {
        response.duration = getTimeDiff(start);

        if (response.status !== HttpStatus.OK) {
          KvsErrorHandler.handleKvsBatchUpdateError(container, items, { response });
        } else {
          dog.recordCompoundMetric('kvsclient.batchUpdate', response.duration, { container });
          dog.recordSimpleMetric('kvsclient.batchUpdate.status', 1, { container, status: response.status });
        }
      })
      .catch((error) => {
        ensureErrorResponseDuration(error, start);
        KvsErrorHandler.handleKvsBatchUpdateError(container, items, error);
      });
  }

  batchDelete(container, keys) {
    if (!_.isArray(keys)) {
      throw new TypeError('keys should be an array');
    } else if (keys.length === 0) {
      throw new TypeError('keys should not be null or empty');
    } else if (!keys.every(checkKeysType)) {
      throw new TypeError('keys should be string');
    }

    container = KvsUtils.normalizeContainer(container);

    const config = {
      baseURL: KvsApiConfiguration.getBaseUrl(Constants.METHODS.WRITE, container),
      timeout: this._kvsApiConfiguration.getTimeout(Constants.METHODS.WRITE),
    };
    const encodedKeys = this.encodeKeys(keys);
    const queryString = KvsApiConfiguration.getQueryString('BATCH', encodedKeys);

    const start = Date.now();
    return restclient
      .delete(KvsApiConfiguration.getUri(container, null, queryString), config)
      .then((response) => {
        response.duration = getTimeDiff(start);

        if (response.status !== HttpStatus.NO_CONTENT) {
          KvsErrorHandler.handleKvsBatchDeleteError(container, keys, { response });
        } else {
          dog.recordCompoundMetric('kvsclient.batchDelete', response.duration, { container });
          dog.recordSimpleMetric('kvsclient.batchDelete.status', 1, { container, status: response.status });
        }
      })
      .catch((error) => {
        ensureErrorResponseDuration(error, start);
        KvsErrorHandler.handleKvsBatchDeleteError(container, keys, error);
      });
  }

  bulkGet(container, keys) {
    if (!_.isArray(keys)) {
      throw new TypeError('keys should be an array');
    } else if (keys.length === 0) {
      throw new TypeError('keys should not be null or empty');
    } else if (!keys.every(checkKeysType)) {
      throw new TypeError('keys should be string');
    }

    container = KvsUtils.normalizeContainer(container);

    const encodedKeys = this.encodeKeys(keys);
    const queryString = KvsApiConfiguration.getQueryString('BULK', encodedKeys);
    const config = {
      baseURL: KvsApiConfiguration.getBaseUrl(Constants.METHODS.READ, container),
      timeout: this._kvsApiConfiguration.getTimeout(Constants.METHODS.READ),
      cache: false,
    };

    const start = Date.now();
    return restclient
      .get(KvsApiConfiguration.getUri(container, null, queryString), config)
      .then((response) => { // eslint-disable-line consistent-return
        response.duration = getTimeDiff(start);

        const items = new Items();
        const versions = [];
        const ttls = [];
        const versionsHeader = [];
        const ttlsHeader = [];
        const lowerHeaders = RequestUtils.lowerHeaders(response.headers);

        if (response.status === HttpStatus.OK) {
          if (!_.isNil(lowerHeaders['x-kvs-versions'])) {
            versionsHeader.push(...lowerHeaders['x-kvs-versions'].split(','));
          }

          if (!_.isNil(lowerHeaders['x-kvs-ttls'])) {
            ttlsHeader.push(...lowerHeaders['x-kvs-ttls'].split(','));
          }

          for (let i = 0; i < response.data.length; i++) {
            const result = response.data[i];
            if (result.status !== HttpStatus.NOT_FOUND) {
              const item = new Item({ key: result.key });
              if (result.status === HttpStatus.OK) {
                item.value = result.value;
              } else {
                item.error = Constants.ERROR_TYPES.UNEXPECTED;
              }

              if (versionsHeader.length > 0) {
                versions.push(versionsHeader[i]);
              }

              if (ttlsHeader.length > 0) {
                ttls.push(ttlsHeader[i]);
              }

              items.add(item);
            }
          }

          const headers = {};
          if (versions.length > 0) {
            headers['X-Kvs-Versions'] = versions.join();
          }

          if (ttls.length > 0) {
            headers['X-Kvs-Ttls'] = ttls.join();
          }
          setHeaders(headers, items);

          dog.recordCompoundMetric('kvsclient.bulkGet', response.duration, { container });
          dog.recordSimpleMetric('kvsclient.bulkGet.status', 1, { container, status: response.status });
          return items;
        }

        KvsErrorHandler.handleKvsBulkGetError(container, keys, { response });
      })
      .catch((error) => {
        ensureErrorResponseDuration(error, start);
        KvsErrorHandler.handleKvsBulkGetError(container, keys, error);
      });
  }

  bulkSave(container, items) {
    if (_.isNil(items)) {
      throw new TypeError('items should not be null');
    } else if (typeof items !== 'object' || (typeof items === 'object' && items.constructor.name !== 'Items')) {
      throw new TypeError('not allowed to bulk save something different to items');
    } else if (items.size() === 0) {
      throw new TypeError('items should not be empty');
    }

    container = KvsUtils.normalizeContainer(container);

    const queryString = KvsApiConfiguration.getQueryString('BULK', null);

    const body = [];
    for (const item of items) {
      body.push({ key: item.key, value: item.getValueAsString() });
    }

    const config = {
      baseURL: KvsApiConfiguration.getBaseUrl(Constants.METHODS.WRITE, container),
      timeout: this._kvsApiConfiguration.getTimeout(Constants.METHODS.WRITE),
      data: body,
      headers: getHeaders(items),
    };

    const start = Date.now();
    return restclient
      .post(KvsApiConfiguration.getUri(container, null, queryString), config)
      .then((response) => { // eslint-disable-line consistent-return
        response.duration = getTimeDiff(start);

        if (response.status === HttpStatus.OK) {
          const results = {};
          _.forEach(response.data, (item) => {
            results[item.key] = item;
          });
          for (const item of items) {
            const result = results[item.key];
            if (result.status !== HttpStatus.CREATED) {
              if (result.status === HttpStatus.CONFLICT) {
                item.error = Constants.ERROR_TYPES.CONFLICT;
              } else {
                item.error = Constants.ERROR_TYPES.UNEXPECTED;
              }
            }
          }

          dog.recordCompoundMetric('kvsclient.bulkSave', response.duration, { container });
          dog.recordSimpleMetric('kvsclient.bulkSave.status', 1, { container, status: response.status });
          return items;
        }

        KvsErrorHandler.handleKvsBulkSaveError(container, items, { response });
      })
      .catch((error) => {
        ensureErrorResponseDuration(error, start);
        KvsErrorHandler.handleKvsBulkSaveError(container, items, error);
      });
  }

  bulkUpdate(container, items) {
    if (_.isNil(items)) {
      throw new TypeError('items should not be null');
    } else if (typeof items !== 'object' || (typeof items === 'object' && items.constructor.name !== 'Items')) {
      throw new TypeError('not allowed to bulk save something different to items');
    } else if (items.size() === 0) {
      throw new TypeError('items should not be empty');
    }

    container = KvsUtils.normalizeContainer(container);

    const queryString = KvsApiConfiguration.getQueryString('BULK', null);

    const body = [];
    for (const item of items) {
      body.push({ key: item.key, value: item.getValueAsString() });
    }

    const config = {
      baseURL: KvsApiConfiguration.getBaseUrl(Constants.METHODS.WRITE, container),
      timeout: this._kvsApiConfiguration.getTimeout(Constants.METHODS.WRITE),
      data: body,
      headers: getHeaders(items),
    };

    const start = Date.now();
    return restclient
      .put(KvsApiConfiguration.getUri(container, null, queryString), config)
      .then((response) => { // eslint-disable-line consistent-return
        response.duration = getTimeDiff(start);

        if (response.status === HttpStatus.OK) {
          const results = {};
          _.forEach(response.data, (item) => {
            results[item.key] = item;
          });
          for (const item of items) {
            const result = results[item.key];
            if (result.status !== HttpStatus.CREATED) {
              if (result.status === HttpStatus.CONFLICT) {
                item.error = Constants.ERROR_TYPES.CONFLICT;
              } else {
                item.error = Constants.ERROR_TYPES.UNEXPECTED;
              }
            }
          }

          dog.recordCompoundMetric('kvsclient.bulkUpdate', response.duration, { container });
          dog.recordSimpleMetric('kvsclient.bulkUpdate.status', 1, { container, status: response.status });
          return items;
        }

        KvsErrorHandler.handleKvsBulkUpdateError(container, items, { response });
      })
      .catch((error) => {
        ensureErrorResponseDuration(error, start);
        KvsErrorHandler.handleKvsBulkUpdateError(container, items, error);
      });
  }

  bulkDelete(container, keys) {
    container = KvsUtils.normalizeContainer(container);

    if (!_.isArray(keys)) {
      throw new TypeError('keys should be an array');
    } else if (keys.length === 0) {
      throw new TypeError('keys should not be null or empty');
    } else if (!keys.every(checkKeysType)) {
      throw new TypeError('keys should be string');
    }

    const encodedKeys = this.encodeKeys(keys);
    const queryString = KvsApiConfiguration.getQueryString('BULK', encodedKeys);
    const config = {
      baseURL: KvsApiConfiguration.getBaseUrl(Constants.METHODS.WRITE, container),
      timeout: this._kvsApiConfiguration.getTimeout(Constants.METHODS.WRITE),
    };

    const start = Date.now();
    return restclient
      .delete(KvsApiConfiguration.getUri(container, null, queryString), config)
      .then((response) => { // eslint-disable-line consistent-return
        response.duration = getTimeDiff(start);

        if (response.status === HttpStatus.OK) {
          const items = new Items();
          _.forEach(response.data, (result) => {
            const item = new Item({ key: result.key });
            if (result.status !== HttpStatus.NO_CONTENT) {
              item.error = Constants.ERROR_TYPES.UNEXPECTED;
            }
            items.add(item);
          });

          dog.recordCompoundMetric('kvsclient.bulkDelete', response.duration, { container });
          dog.recordSimpleMetric('kvsclient.bulkDelete.status', 1, { container, status: response.status });
          return items;
        }
        KvsErrorHandler.handleKvsBulkDeleteError(container, keys, { response });
      })
      .catch((error) => {
        ensureErrorResponseDuration(error, start);
        KvsErrorHandler.handleKvsBulkDeleteError(container, keys, error);
      });
  }

  getCounter(container, key) {
    return this
      .get(container, key)
      .then((item) => {
        if (!_.isNil(item)) {
          return parseInt(item.value.number, 10);
        }
        return null;
      })
      .catch((error) => {
        throw error;
      });
  }

  incrementCounter(container, key, value) {
    if (_.isNil(value)) {
      throw new TypeError('value should not be null');
    }
    return this.update(container, new Item({ key, value: `{"number":${Number(value)}}` }));
  }

  decrementCounter(container, key, value) {
    if (_.isNil(value)) {
      throw new TypeError('value should not be null');
    }
    return this.update(container, new Item({ key, value: `{"number":${-Number(value)}}` }));
  }

  resetCounter(container, key) {
    return this.delete(container, key);
  }

  encodeKey(key) {
    switch (this._kvsApiConfiguration.encodingType) {
      case Constants.ENCODING_TYPES.NONE:
        return key;
      case Constants.ENCODING_TYPES.URL:
        return KeysUtils.escape(key);
      default:
        return undefined;
    }
  }

  encodeKeys(keys) {
    switch (this._kvsApiConfiguration.encodingType) {
      case Constants.ENCODING_TYPES.NONE:
        return keys;
      case Constants.ENCODING_TYPES.URL:
        return _.map(keys, KeysUtils.escape);
      default:
        return undefined;
    }
  }
}

module.exports = KvsClient;
