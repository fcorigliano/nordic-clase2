const restclient = require('frontend-restclient');
const log = require('frontend-logger')('melidata');
const buildFlowStarterContext = require('frontend-restclient/src/build-flow-context');
const catalogCheckLevel = require('./catalog-check-level');

class CatalogValidator {
  constructor() {
    // TODO: Maybe define the level in config?
    this.checkLevel = catalogCheckLevel.fromString(process.env.MELIDATA_LEVEL);
  }

  validate(track) {
    return this.apiValidate(track);
  }

  apiValidate(track) {
    const request = restclient({
      timeout: 2000,
      retry: {
        maxRetries: 3,
        delay: 0,
        maxDelay: 500,
        factor: 1,
      },
    });

    return request
      .post('/melidata/catalog/validate', {
        context: buildFlowStarterContext(),
        data: track,
        headers: { 'Content-Type': 'application/json' },
      })
      .then((response) => response.data)
      .catch((err) => {
        if (err.response && err.response.status === 400) {
          return err.response.data;
        } throw err;
      });
  }

  checkCatalog(t) {
    return new Promise((resolve) => {
      if (this.checkLevel === catalogCheckLevel.OFF) {
        return resolve({});
      }

      return this.validate(t.dump())
        .then((validation) => {
          if ('passed' in validation === true && !validation.passed) {
            const msg = `Invalid track!! -> track ${t.path} (${t.device.platform}) `
              + `was not valid against Melidata catalog (version: ${validation.version || 'unknown'})`;
            this.levelAction(msg, validation.messages);
          } else {
            log.info(`Track ${t.path} in ${t.device.platform} is valid according to Melidata catalog`);
          }
          return resolve(validation);
        }).catch((err) => {
          log.warn(`Error validating against Melidata Catalog: ${err.message}`);
          return resolve(err);
        });
    });
  }

  levelAction(msg, reasons = []) {
    switch (this.checkLevel) {
      case catalogCheckLevel.WARN:
      default:
        log.warn(msg);
        reasons.forEach((reason) => log.warn(reason));
        break;
      case catalogCheckLevel.ERROR:
        throw new Error(`${msg} Reasons: ${reasons.join(', ')}`);
    }
  }
}

module.exports = CatalogValidator;
