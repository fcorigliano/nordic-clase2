const config = require('frontend-config');
const restclient = require('frontend-restclient');
const querystring = require('querystring');
const log = require('frontend-logger')('melidata');
const buildFlowStarterContext = require('frontend-restclient/src/build-flow-context');

const {
  MELIDATA_SDK_PRODUCTION,
  MELIDATA_ON_PRODUCTION,
} = require('../../config/melidata');

const Entry = require('./entry');

const SEARCH_URL = 'experiments/search';
const UNKNOWN = 'unknown';
const LIMIT = 10000;

function parseCacheControl(s) {
  const output = {};

  if (!s) {
    return output;
  }

  const raw = querystring.parse(s, ',', '=');
  Object.keys(raw).forEach((key) => {
    output[key.toLowerCase().trim()] = parseInt(raw[key], 10);
  });

  return output;
}

class ExperimentApiCalls {
  constructor(experiments) {
    this.experiments = experiments;
    this.mockDepartment = null;
  }

  getOffsetDate(date, seconds) {
    const updated = new Date(date);
    updated.setSeconds(date.getSeconds() + seconds);

    return updated;
  }

  doMockedSearch() {
    const now = new Date();
    const maxAge = 3600 * 24;
    const data = config.get('melidata.experiments') || {};
    const entries = new Entry(
      now,
      this.getOffsetDate(now, maxAge),
      this.getOffsetDate(now, parseInt(maxAge / 2, 10)),
      Array.isArray(data) ? this.toMap(data) : data,
    );

    return Promise.resolve(entries);
  }

  doProductiveSearch() {
    return this.paginate()
      .then((result) => {
        if (result && result.status === 200) {
          const now = new Date();
          const maxAge = result.cacheControl['max-age'];
          const staleInterval = result.cacheControl['stale-while-revalidate']
            ? result.cacheControl['stale-while-revalidate'] : maxAge / 2;

          return new Entry(
            now,
            this.getOffsetDate(now, maxAge),
            this.getOffsetDate(now, staleInterval),
            result.data,
          );
        }

        return null;
      });
  }

  doSearch() {
    return MELIDATA_SDK_PRODUCTION || MELIDATA_ON_PRODUCTION ? this.doProductiveSearch() : this.doMockedSearch();
  }

  toMap(experiments) {
    return experiments.reduce((exps, exp) => {
      exps[exp.name] = exp;

      return exps;
    }, {});
  }

  paginate() {
    const offset = 0;
    return this.search(offset)
      .then((results) => {
        if (!results || !results.data) {
          return null;
        }

        const output = this.toMap(results.data.results);
        const { data = {}, cacheControl, status } = results;
        const { paging } = data;

        const q = [];

        for (let i = paging.limit; i < paging.total; i += paging.limit) {
          q.push(this.search(i));
        }

        return Promise.all(q)
          .then((rest) => {
            if (rest.some(p => p == null)) return null;
            rest.forEach((r) => Object.assign(output, this.toMap(r.data.results)));

            return {
              status,
              cacheControl,
              data: output,
            };
          });
      });
  }

  search(offset) {
    const url = this.getUrlWithParams(offset);
    return this.apiCall(url);
  }

  get(experiment) {
    const url = `${SEARCH_URL}?name=${experiment}`;

    return this.apiCall(url).then((res) => res.data);
  }

  apiCall(url) {
    const request = restclient({
      timeout: 500,
    });

    return request
      .get(url, {
        context: buildFlowStarterContext(),
        headers: {
          'Content-Type': 'application/json',
        },
        retry: {
          maxRetries: 2,
          delay: 10000,
          maxDelay: 20000,
          factor: 2,
        },
      })
      .then((response) => {
        const cacheControl = parseCacheControl(response.headers['cache-control']);

        return {
          status: response.status,
          data: response.data,
          cacheControl,
        };
      })
      .catch((err) => {
        log.error(`Cannot do the API call to experiments: ${err}`);

        return null;
      });
  }

  call() {
    this.doSearch()
      .then((entry) => {
        if (entry) {
          this.experiments.refresh(entry);
          return entry;
        }

        return null;
      })
      .catch((err) => {
        log.error(`Cannot find the experiments due to an error: ${err}`);

        return null;
      });
  }

  getUrlWithParams(offset) {
    let url = `${SEARCH_URL}?status=active&offset=${offset}&limit=${LIMIT}`;

    // Supporting both allPlatforms and all_platforms to maintain the backward compatibility with the configuration
    // of Grails plugin and to be consistent with the frontend-config where camel case is preferred
    const allPlatforms = config.get('melidata.client.allPlatforms') || config.get('melidata.client.all_platforms');

    if (!allPlatforms) {
      url += `&platform=${config.get('melidata.client.platform') || 'web'}`;
    }

    if (this.hasDepartment()) {
      const department = this.getDepartment();
      url += `&department=${department}`;
    }

    if (this.hasApplicationName()) {
      const appName = this.getApplicationName();
      url += `&fury_app_name=${appName}&include_attached=true&include_legacy=true`;
    }

    return url;
  }

  hasApplicationName() {
    const appName = this.getApplicationName();
    return appName !== UNKNOWN;
  }

  getApplicationName() {
    const { APPLICATION } = process.env;
    return APPLICATION || UNKNOWN;
  }

  getDepartment() {
    if (this.mockDepartment !== null) return this.mockDepartment;
    const department = config.get('melidata.client.department');
    return department || UNKNOWN;
  }

  hasDepartment() {
    return this.getDepartment() !== UNKNOWN;
  }

  setMockDepartment(department) {
    this.mockDepartment = department;
  }
}

module.exports = ExperimentApiCalls;
