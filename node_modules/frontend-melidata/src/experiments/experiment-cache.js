const EventEmitter = require('events');
const Entry = require('./entry');
const ExperimentApiCalls = require('./experiment-api-calls');
const statsdInternal = require('frontend-statsd/internal');
const MelidataTrackService = require('../services/melidata-track');

const melidataTrackService = new MelidataTrackService();
const sdk = 'node';

class ExperimentCache extends EventEmitter {
  constructor() {
    super();
    this.allExperiments = new Entry();
    this.apiService = new ExperimentApiCalls(this.allExperiments);
    this.isUpdateRunning = false;
    this.refresh();
  }

  getExperiments() {
    const now = (new Date()).getTime();
    const stalesIn = this.allExperiments.getStalesIn();
    const expiresIn = this.allExperiments.getExpiresIn();
    const data = this.allExperiments.getData();

    // If the data is really fresh return it immediately
    if (stalesIn && now < stalesIn.getTime()) {
      return data;
    }

    // If the data is expired or very close to this run the refresh process
    this.refresh();

    // Return null when data is expired, no confidence anymore
    return expiresIn && now > expiresIn.getTime() ? null : data;
  }

  /**
   * Returns the variants for the given experiment name
   * @param name
   * @returns {Promise}
   *
   * TODO: The name of this method is getExperiment while it returns only variants of experiment. This logic is from Groovy version and it's really strange, make sense to change the method name to getExperimentVariants?
   */
  getExperiment(name) {
    // First look to the experiments cache
    const experiments = this.getExperiments();
    const experiment = experiments && experiments[name];

    if (experiment) {
      // Return only the variants, convert variants Array to an Object
      return experiment.variants.reduce((acc, v) => {
        acc[v.id] = v;

        return acc;
      }, {});
    }

    return null;
  }

  refresh() {
    if (this.isUpdateRunning) {
      return;
    }

    this.isUpdateRunning = true;
    this.apiService.doSearch()
      .then((entry) => {
        if (entry) {
          this.allExperiments.refresh(entry);
          statsdInternal.increment('application.melidata.sdk.experiments.cache.update', 1, {
            successful: 'true',
            sdk,
            sdk_version: melidataTrackService.getPluginVersion(),
          });
        }
        this.emit('refresh', entry);
        this.isUpdateRunning = false;
      })
      .catch(() => {
        statsdInternal.increment('application.melidata.sdk.experiments.cache.update', 1, {
          successful: 'false',
          sdk,
          sdk_version: melidataTrackService.getPluginVersion(),
        });
        this.isUpdateRunning = false;
      });
  }

  getLastDumpDate() {
    return this.allExperiments.getFetchDate();
  }

  clear() {
    this.allExperiments.clear();
  }

  dump() {
    return this.allExperiments.getData();
  }
}

module.exports = ExperimentCache;
