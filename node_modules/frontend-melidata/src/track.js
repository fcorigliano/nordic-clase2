const { v4: uuidv4 } = require('uuid');
const { formatDate } = require('./utils/track-utils');

const TrackType = {
  View: 'view',
  Event: 'event',
};

const DEFAULT_VARIANT = 'DEFAULT';

const getDefaults = () => {
  return {
    id: null,
    path: '',
    userTime: null,
    userLocalTimeStamp: null,
    event_data: {},
    application: {},
    device: {},
    user: {},
    platform: { http: {} },
    type: null,
    isDeferred: false,
    isJavascript: true,
    experiments: {},
    lastExperimentsTimeStamp: null,
    stream_name: "melidata",
  };
};

class Track {
  constructor(path = '', type = TrackType.View) {
    const defaults = getDefaults();
    let data = {};

    if (typeof path === 'string') {
      data = { path, type };
    } else if (typeof path === 'object') {
      data = path;
    } else {
      throw(new Error('Track: Wrong parameter format given'));
    }

    // Merge options with defaults, avoid the use of direct extend since the keys are assigned directly to `this`
    Object.keys(defaults).forEach((key) => {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        this[key] = data[key];
      } else {
        this[key] = defaults[key];
      }
    });

    if (!this.id) {
      this.id = uuidv4();
    }
  }

  addData(target, source) {
    Object.keys(source).forEach((key) => {
      target[key] = typeof target[key] === 'object' && !Array.isArray(target[key]) ?
        Object.assign({}, target[key], source[key]) : source[key];
    });
  }

  /**
   *
   * @param {number} time
   * @returns {Track}
   */
  withUserTime(time) {
    this.userTime = time;

    return this
  }

  /**
   * Format: 'yyyy-mm-dd\'T\'HH:MM:ss.LZ' -> i.e. 2016-05-30T17:21:17.390-0300
   *
   * @param {string} userLocalTimeStamp
   * @returns {Track}
   */
  withUserLocalTimeStamp(userLocalTimeStamp) {
    this.userLocalTimeStamp = userLocalTimeStamp;

    return this
  }

  /**
   *
   * @param {string} type One of TrackType keys
   * @returns {Track}
   */
  withType(type) {
    if (TrackType[type]) {
      this.type = type;
    }

    return this;
  }

  /**
   *
   * @param {string} path
   * @returns {Track}
   */
  withPath(path) {
    this.path = typeof path === 'string' ? path.toLowerCase() : null;

    return this;
  }

  /**
   * Warning: it overrides site_id if set
   *
   * @param {string} sitedId
   * @returns {Track}
   */
  withSiteId(sitedId) {
    this.application.site_id = sitedId;

    return this;
  }

  /**
   *
   * @param {string} key
   * @param {object} value
   * @returns {Track}
   */
  withEventData(key, value) {
    if (typeof value !== 'undefined' && typeof key === 'string') {
      this.event_data[key] = value;
    } else if (typeof key === 'object') {
      this.addData(this.event_data, key);
    }

    return this;
  }

  /**
   *
   * @param {object} data
   * @returns {Track}
   */
  withApplicationData(data) {
    this.addData(this.application, data);

    return this;
  }

  /**
   *
   * @param {object} data
   * @returns {Track}
   */
  withUserData(data){
    this.addData(this.user, data);

    return this;
  }

  /**
   *
   * @param {object} data
   * @returns {Track}
   */
  withDeviceData(data) {
    this.addData(this.device, data);

    return this
  }

  /**
   *
   * @param {object} data
   * @returns {Track}
   */
  withHttpData(data) {
    this.addData(this.platform.http, data);

    return this;
  }

  withVariantData(experimentName, variant, lastDump) {
    this.experiments[experimentName] = variant;
    this.lastExperimentsTimeStamp = formatDate(lastDump);

    return this;
  }


  /**
   *
   * @param {string} experimentName
   * @param {Date} lastDump
   * @returns {Track}
   */
  withDefaultVariantData(experimentName, lastDump) {
    this.experiments[experimentName] = { id: DEFAULT_VARIANT };
    this.lastExperimentsTimeStamp = formatDate(lastDump);

    return this
  }

  /**
   *
   * @returns {object}
   */
  getPlainExperiments() {
    const plainExperiments = {};
    for (const exp in this.experiments) {
      if (Object.prototype.hasOwnProperty.call(this.experiments, exp)) {
        const variant = this.experiments[exp];
        plainExperiments[exp] = typeof variant === 'object' ? variant.id : variant;
      }
    }

    return plainExperiments;
  }

  /**
   *
   * @returns {boolean}
   */
  hasExperiments() {
    return Object.keys(this.experiments).length > 0;
  }

  /**
   *
   * @param {boolean} isJavascript
   */
  setIsJavascript(isJavascript) {
    this.isJavascript = !!isJavascript;

    if (!isJavascript && this.device.platform && !this.device.platform.endsWith('static')) {
      this.device['platform'] = this.device.platform + '/static';
    }
  }

  /**
   *
   * @returns {object}
   */
  toMap() {
    const map = {
      id: this.id,
      path: this.path,
      event_data: this.event_data,
      user: this.user,
      application: this.application,
      device: this.device,
      platform: this.platform,
      type: this.type,
      experiments: this.getPlainExperiments(),
      experiments_timestamp: this.lastExperimentsTimeStamp
    };

    if (this.userTime) {
      map.user_time = userTime;
    }

    if (this.userLocalTimeStamp) {
      map.user_local_timestamp = this.userLocalTimeStamp;
    }

    return map;
  }

  /**
   *
   * @returns {object}
   */
  dump() {
    return Object.assign({}, this.toMap(), {
      isDeferred: this.isDeferred,
      isJavascript: this.isJavascript,
      hasExperiments: this.hasExperiments()
    });
  }
}

module.exports = Track;
