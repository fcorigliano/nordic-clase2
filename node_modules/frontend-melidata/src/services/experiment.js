const log = require('frontend-logger')('melidata');
const buildRestClientContext = require('frontend-restclient/src/build-context');
const statsdInternal = require('frontend-statsd/internal');
const hashingService = require('../experiments/hashing-base-service');
const MelidataTrackService = require('./melidata-track');
const ExperimentCache = require('../experiments/experiment-cache');
const AudiencesService = require('./audiences');
const ExperimentConfiguration = require('../experiments/experiment-configuration');

const melidataTrackService = new MelidataTrackService();
const experimentCache = new ExperimentCache();

const audiencesService = new AudiencesService();
let {
  MELIDATA_USE_AUDIENCES_INTEGRATION,
} = require('../../config/melidata');

const MELIDATA_HEADER = 'x-melidata-track';
const SeedSource = {
  UID: 'UID',
  USER_ID: 'USER_ID',
};
const sdk = 'node';


class ExperimentService {
  getVariant(seed, experimentName, site = '', platform = '', track = null, userId = '') {
    let variant = this._handleVariantFromTrack(null, track, experimentName);

    const experiments = experimentCache.getExperiments();
    if (!experiments) {
      return this._handleEmptyExperiments(track, experimentName);
    }

    const exp = experiments[experimentName] || null;
    if (exp) {
      variant = hashingService.getApplicableVariant(seed, exp, site, platform, userId);

      // Warn about incorrect method being used
      if (typeof exp.audiences !== 'undefined' && exp.audiences !== null) {
        log.warn(
          `You are attempting to get a variant from experiment with audiences (${experimentName}).
          Use 'getConfigAsync' instead and see the SDK's README for more details`,
        );
        variant = null;
      }

      if (variant) {
        if (track) {
          track.withVariantData(exp.name, variant, experimentCache.getLastDumpDate());
        }
        return variant;
      }

      return this._handleEmptySeed(track, experimentName);
    }

    return this._handleExperimentNotInCache(track, experimentName);
  }

  getUid(request) {
    this.ensureMelidataTrack(request);

    const { melidataTrack } = request;

    if (melidataTrack.user) {
      return melidataTrack.user.uid;
    }
    const userData = melidataTrackService.getUserData(request);

    return userData ? userData.uid : null;
  }

  getUserId(request) {
    this.ensureMelidataTrack(request);

    const { melidataTrack } = request;

    if (melidataTrack.user) {
      return melidataTrack.user.user_id;
    }
    const userData = melidataTrackService.getUserData(request);

    return userData ? userData.user_id : null;
  }

  getSeedSource(experimentName, defaultSeedSource) {
    if (defaultSeedSource) {
      return defaultSeedSource;
    }

    if (experimentCache && experimentCache.getExperiments()) {
      const experiments = experimentCache.getExperiments();
      const experiment = experiments[experimentName] || null;

      if (experiment) {
        const seed = (experiment.seed) ? experiment.seed.toLowerCase() : '';
        const seedLowerCase = (seed) || '';

        if (seedLowerCase === SeedSource.UID.toLowerCase()) {
          return SeedSource.UID;
        }
        if (seedLowerCase === SeedSource.USER_ID.toLowerCase()) {
          return SeedSource.USER_ID;
        }
      }
    }

    return SeedSource.UID;
  }

  getSeedFromRequest(request, experimentName, defaultSeedSource) {
    const userId = this.getUserId(request);
    const uid = this.getUid(request);

    const seedSource = this.getSeedSource(experimentName, defaultSeedSource);
    if (seedSource === SeedSource.USER_ID) {
      return userId;
    }
    return uid;
  }

  getConfigByVariant(configurationKey, variant, defaultValue) {
    const config = variant ? variant.configuration : null;

    if (config) {
      if (configurationKey) {
        // eslint-disable-next-line no-prototype-builtins
        return config.hasOwnProperty(configurationKey) ? config[configurationKey] : defaultValue;
      }

      // If no specific key is provided use the first key from config object
      const configKeys = Object.keys(config);
      return configKeys.length ? config[configKeys[0]] : defaultValue;
    }

    return defaultValue;
  }

  /**
   * Get configuration of the experiment depending on the seed parameter
   *
   * @param configurationKey
   * @param request
   * @param seed
   * @param experimentName
   * @param defaultValue
   * @param addExperimentToTrack
   * @return Promise
   *
   * TODO: Review the order of parameters
   */
  getConfigBySeed(configurationKey, request, seed, experimentName, defaultValue, addExperimentToTrack = true) {
    // Ensure that melidataTrack is defined in request
    this.ensureMelidataTrack(request);
    const { melidataTrack } = request;

    let variant = this._handleGetConfigBySeed(
      melidataTrack,
      configurationKey,
      request,
      experimentName,
      defaultValue,
      addExperimentToTrack,
    );

    const { hostname } = request;
    const site = melidataTrackService.getSiteId(hostname, request);
    const platform = melidataTrackService.getPlatform(request);
    const userId = this.getUserId(request);

    variant = this.getVariant(seed, experimentName, site, platform, melidataTrack, userId);
    return this.getConfigByVariant(configurationKey, variant, defaultValue);
  }

  /**
   * Get configuration of the experiment depending on USER_ID or UID cookies
   *
   * @param request
   * @param experimentName
   * @param defaultValue
   * @param configurationKey
   * @param source
   * @param addExperimentToTrack
   * @return
   */
  getConfig(
    request,
    experimentName,
    defaultValue,
    configurationKey = null,
    source = null,
    addExperimentToTrack = true,
  ) {
    this.ensureMelidataTrack(request);

    const seed = this.getSeedFromRequest(request, experimentName, source);
    if (!seed) {
      log.error(
        `Using an empty ${this.getSeedSource(experimentName, source)} for experiment ${experimentName}, it could cause problems in your experiment`,
      );
    }

    return this.getConfigBySeed(configurationKey, request, seed, experimentName, defaultValue, addExperimentToTrack);
  }

  getExperimentConfiguration(experimentName, seed, site = '', platform = '', userId = '') {
    if (!seed) {
      log.error(
        `Using an empty seed for experiment ${experimentName}, it could cause problems in your experiment`,
      );
      statsdInternal.increment('application.melidata.sdk.variant.default', 1, {
        reason: 'empty_seed',
        sdk,
        sdk_version: melidataTrackService.getPluginVersion(),
      });
      return new ExperimentConfiguration(experimentName, 'DEFAULT');
    }

    const variant = this.getVariant(seed, experimentName, site, platform, null, userId);
    if (variant) {
      return new ExperimentConfiguration(experimentName, variant.id, variant.configuration);
    }
    return new ExperimentConfiguration(experimentName, 'DEFAULT');
  }

  getExperimentConfigurationByRequest(experimentName, request, source = null, site = '', platform = '') {
    const userId = this.getUserId(request);
    const seed = this.getSeedFromRequest(request, experimentName, source);
    const { hostname } = request;

    let selectedSite = site;
    let selectedPlatform = platform;

    if (selectedSite === '') {
      selectedSite = melidataTrackService.getSiteId(hostname, request);
    }

    if (selectedPlatform === '') {
      selectedPlatform = melidataTrackService.getPlatform(request);
    }

    return this.getExperimentConfiguration(experimentName, seed, selectedSite, selectedPlatform, userId);
  }

  getDefaultExperimentConfiguration(experimentName) {
    return new ExperimentConfiguration(experimentName, 'DEFAULT');
  }

  setHeader(data, res) {
    const json = JSON.stringify(data);
    res.set(MELIDATA_HEADER, encodeURIComponent(json));
  }

  getHeader(req) {
    const data = req.get(MELIDATA_HEADER);

    return data ? decodeURIComponent(data) : null;
  }

  getExperiments() {
    return experimentCache.getExperiments();
  }

  // TODO: Find the better solution to centralize the definition of melidataTrack
  ensureMelidataTrack(req) {
    if (!req.melidataTrack) {
      req.melidataTrack = melidataTrackService.fillTrack(req, melidataTrackService.createNewTrack());
    }
  }

  setMelidataUseAudiencesIntegration(toggle) {
    MELIDATA_USE_AUDIENCES_INTEGRATION = toggle;
  }

  // Async implementations
  /**
   * Asynchronous version of 'getVariant', called by 'getConfigBySeedAsync'.
   */
  async getVariantAsync(
    seed,
    experimentName,
    site = '',
    platform = '',
    track = null,
    userId = '',
    meliContext = null,
  ) {
    let variant = this._handleVariantFromTrack(null, track, experimentName);

    const experiments = experimentCache.getExperiments();
    if (!experiments) {
      return this._handleEmptyExperiments(track, experimentName);
    }

    const exp = experiments[experimentName] || null;
    if (exp) {
      variant = hashingService.getApplicableVariant(seed, exp, site, platform, userId);

      // Handle audiences integration if applicable
      if (variant !== null && typeof exp.audiences !== 'undefined' && exp.audiences !== null) {
        if (!MELIDATA_USE_AUDIENCES_INTEGRATION) {
          log.warn(
            `Environment variable 'MELIDATA_USE_AUDIENCES_INTEGRATION' was not set for experiment with audiences:
               ${experimentName}`,
          );
          variant = null;
        } else if (meliContext == null) {
          log.warn(
            'You are requesting an experiment with environment variable \'MELIDATA_USE_AUDIENCES_INTEGRATION\' set,'
                + 'but \'MeliContext\' is null, which causes traceability problems. '
                + 'A default experiment is being returned instead.',
          );
          variant = null;
        } else {
          variant = await audiencesService.getApplicableVariant(variant, exp, userId, meliContext);
        }
      }

      if (variant) {
        if (track) {
          track.withVariantData(exp.name, variant, experimentCache.getLastDumpDate());
        }
        return variant;
      }

      return this._handleEmptySeed(track, experimentName);
    }

    return this._handleExperimentNotInCache(track, experimentName);
  }

  /**
   * Async version of 'getConfigBySeed', called by 'getConfigAsync'.
   * @param configurationKey
   * @param request
   * @param seed
   * @param experimentName
   * @param defaultValue
   * @param addExperimentToTrack
   * @return Promise
   *
   * TODO: Review the order of parameters
   */
  async getConfigBySeedAsync(
    configurationKey,
    request,
    seed,
    experimentName,
    defaultValue,
    addExperimentToTrack = true,
  ) {
    // Ensure that melidataTrack is defined in request
    this.ensureMelidataTrack(request);
    const { melidataTrack } = request;

    let variant = this._handleGetConfigBySeed(
      melidataTrack,
      configurationKey,
      request,
      experimentName,
      defaultValue,
      addExperimentToTrack,
    );

    const { hostname } = request;
    const site = melidataTrackService.getSiteId(hostname, request);
    const platform = melidataTrackService.getPlatform(request);
    const userId = this.getUserId(request);
    const meliContext = buildRestClientContext(request);

    variant = await this.getVariantAsync(seed, experimentName, site, platform, melidataTrack, userId, meliContext);
    return this.getConfigByVariant(configurationKey, variant, defaultValue);
  }

  /**
   * Asynchronous version of 'getConfig' to make use of Audiences for determining the applicable variant.
   * Take note of the implications and how to activate its use by having a look at the README.
   *
   * @param request
   * @param experimentName
   * @param defaultValue
   * @param configurationKey
   * @param source
   * @param addExperimentToTrack
   * @return
   */
  async getConfigAsync(
    request,
    experimentName,
    defaultValue,
    configurationKey = null,
    source = null,
    addExperimentToTrack = true,
  ) {
    this.ensureMelidataTrack(request);

    const seed = this.getSeedFromRequest(request, experimentName, source);
    if (!seed) {
      log.error(
        `Using an empty ${this.getSeedSource(experimentName, source)} for experiment ${experimentName},
          it could cause problems in your experiment`,
      );
    }

    return this.getConfigBySeedAsync(
      configurationKey,
      request,
      seed,
      experimentName,
      defaultValue,
      addExperimentToTrack,
    );
  }

  async getExperimentConfigurationAsync(
    experimentName,
    seed,
    site = '',
    platform = '',
    userId = '',
    meliContext = null,
  ) {
    if (!seed) {
      log.error(
        `Using an empty seed for experiment ${experimentName}, it could cause problems in your experiment`,
      );
      statsdInternal.increment('application.melidata.sdk.variant.default', 1, {
        reason: 'empty_seed',
        sdk,
        sdk_version: melidataTrackService.getPluginVersion(),
      });
      return new ExperimentConfiguration(experimentName, 'DEFAULT');
    }

    const variant = await this.getVariantAsync(seed, experimentName, site, platform, null, userId, meliContext);
    if (variant) {
      return new ExperimentConfiguration(experimentName, variant.id, variant.configuration);
    }
    return new ExperimentConfiguration(experimentName, 'DEFAULT');
  }

  async getExperimentConfigurationByRequestAsync(experimentName, request, source = null, site = '', platform = '') {
    const userId = this.getUserId(request);
    const seed = this.getSeedFromRequest(request, experimentName, source);
    const { hostname } = request;
    const meliContext = buildRestClientContext(request);

    let selectedSite = site;
    let selectedPlatform = platform;

    if (selectedSite === '') {
      selectedSite = melidataTrackService.getSiteId(hostname, request);
    }

    if (selectedPlatform === '') {
      selectedPlatform = melidataTrackService.getPlatform(request);
    }

    return this.getExperimentConfigurationAsync(
      experimentName,
      seed,
      selectedSite,
      selectedPlatform,
      userId,
      meliContext,
    );
  }

  // The following helper methods wrap logic in common between sync and async implementations.
  _handleGetConfigBySeed(
    melidataTrack,
    configurationKey,
    request,
    experimentName,
    defaultValue,
    addExperimentToTrack = true,
  ) {
    // Allow the overrides of experiment variant by using the query string parameter
    const paramName = `variant_${experimentName}`;
    let paramValue = request.query[paramName];

    if (Array.isArray(paramValue)) {
      // eslint-disable-next-line prefer-destructuring
      paramValue = paramValue[0];
    }

    // Allow the overrides of experiment variant by using the custom cookie
    if (!paramValue) {
      paramValue = request.cookies && request.cookies[paramName];
    }

    // Get the variant data by using the custom parameter
    if (paramValue) {
      const variants = experimentCache.getExperiment(experimentName);
      if (variants) {
        const variant = variants[paramValue];

        if (variant) {
          if (addExperimentToTrack) {
            melidataTrack.withVariantData(experimentName, variant, experimentCache.getLastDumpDate());
          }

          return this.getConfigByVariant(configurationKey, variant, defaultValue);
        }

        if (addExperimentToTrack) {
          melidataTrack.withDefaultVariantData(experimentName, experimentCache.getLastDumpDate());
        }

        return defaultValue;
      }

      statsdInternal.increment('application.melidata.sdk.variant.default', 1, {
        reason: 'could_not_find_experiment',
        sdk,
        sdk_version: melidataTrackService.getPluginVersion(),
      });
      return defaultValue;
    }

    const { hostname } = request;
    const site = melidataTrackService.getSiteId(hostname, request);
    const platform = melidataTrackService.getPlatform(request);
    const userId = this.getUserId(request);
    const meliContext = buildRestClientContext(request);

    return [site, platform, userId, meliContext];
  }

  _handleEmptySeed(track, experimentName) {
    if (track) {
      track.withDefaultVariantData(experimentName, experimentCache.getLastDumpDate());
    }

    statsdInternal.increment('application.melidata.sdk.variant.default', 1, {
      reason: 'empty_seed',
      sdk,
      sdk_version: melidataTrackService.getPluginVersion(),
    });
    return null;
  }

  _handleVariantFromTrack(variant, track, experimentName) {
    if (track) {
      const expVariant = track.experiments[experimentName];
      if (expVariant) {
        return expVariant;
      }
    }
    return variant;
  }

  _handleEmptyExperiments(track, experimentName) {
    log.warn(
      `Experiments cache is empty, returning default variant for the experiment ${experimentName}`,
    );
    if (track) {
      track.withDefaultVariantData(experimentName, experimentCache.getLastDumpDate());
    }
    statsdInternal.increment('application.melidata.sdk.variant.default', 1, {
      reason: 'empty_cache',
      sdk,
      sdk_version: melidataTrackService.getPluginVersion(),
    });
    return null;
  }

  _handleExperimentNotInCache(track, experimentName) {
    if (track) {
      track.withDefaultVariantData(experimentName, experimentCache.getLastDumpDate());
    }

    statsdInternal.increment('application.melidata.sdk.variant.default', 1, {
      reason: 'experiment_not_in_cache',
      sdk,
      sdk_version: melidataTrackService.getPluginVersion(),
    });
    return null;
  }
}

module.exports = ExperimentService;
