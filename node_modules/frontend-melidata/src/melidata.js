const log = require('frontend-logger')('melidata');
const MelidataTrackService = require('./services/melidata-track');
const { secureTrack } = require('./utils/track-utils');
// const ExperimentService = require('./services/experiment');
const render = require('./utils/render-track');
const SignatureCacheService = require('./signature/signature-cache');

const signatureCacheService = new SignatureCacheService();

const IS_SSL_HEADER = 'ml_ssl';

class Melidata {
  constructor(request) {
    this.request = request;
    this.melidataTrackService = new MelidataTrackService();
    // this.experimentService = new ExperimentService();

    if (!request.melidataTrack) {
      request.melidataTrack = this.melidataTrackService.fillTrack(request,
        this.melidataTrackService.createNewTrack());
    }
    this.melidataTrack = request.melidataTrack;
  }

  getUid() {
    if (this.melidataTrack.user) {
      return this.melidataTrack.user.uid;
    }

    const userData = this.melidataTrackService.getUserData(this.request);
    return userData ? userData.uid : null;
  }

  trackException(attrs) {
    try {
      const track = this.melidataTrack;

      track.path = '/melidata/null_track';
      track.event_data.context = attrs.context;

      const exception = attrs.exception;
      if (exception) {
        track.event_data.exception = exception.message;
      }

      this.renderTrack(track, null);
    } catch (e) {
      log.error('Error in trackException', e);
    }
  }

  track (attrs, nonceCSP) {
    const track = this.melidataTrack;

    this.add(attrs);

    if(Object.prototype.hasOwnProperty.call(attrs, 'id')) {
      track.id = String(attrs.id);
    }

    if(Object.prototype.hasOwnProperty.call(attrs, 'isDeferred')) {
      track.isDeferred = JSON.parse(attrs.isDeferred);
    }

    if(Object.prototype.hasOwnProperty.call(attrs, 'path')) {
      track.path = String(attrs.path);
    }

    if(Object.prototype.hasOwnProperty.call(attrs, 'type')) {
      track.type = String(attrs.type);
    }

    secureTrack(track, signatureCacheService.getSignatureKey());
    return this.renderTrack(track, attrs.completeTrackFunction, nonceCSP);
  }

  isSSL() {
    const SSLHeader = this.request.headers[IS_SSL_HEADER];
    return (this.request.connection && this.request.connection.encrypted) || SSLHeader === '1';
  }

  renderTrack(requestTrack, completeTrackFunction, nonceCSP) {
    const model = {
      track: requestTrack,
      scriptURL: this.melidataTrackService.getScriptUrl(this.isSSL()),
      pixelUrl: this.melidataTrackService.getPixelUrl(),
      nonceCSP,
    };

    if (completeTrackFunction) {
      model.completeTrackFunction = completeTrackFunction
    }

    // track, scriptURL, pixelUrl, completeTrackFunction
    return render(model);
  }


  /*sendTrack(attrs) {
    const track = this.melidataTrack;

    const model = {
      track: track,
      pixelUrl: melidataTrackService.pixelUrl,
    };

    if (trackRendererMock) {
      return trackRendererMock.render({template: "/test/melidataTrackSendTest", model: model});
    }

    return render({template: "/layouts/melidataTrackSend", model:model});
  }*/


  add(attrs = {}) {
    const track = this.melidataTrack;
    const attrMap = {
      application: 'application',
      user: 'user',
      device:'device',
      data: 'event_data', //for backward compatibility we remain mapping data->event_data while event_data should be used
      event_data: 'event_data',
      experiments:'experiments',
      stream_name:'stream_name',
    };

    Object.keys(attrMap).forEach((key) => {
      const val = attrs[key];
      if (val == null) {
        return;
      }
      if (key === 'application') {
        track.withApplicationData(val);
      } else if (key === 'user') {
        track.withUserData(val);
      } else {
        track.addData(track, { [attrMap[key]]: val });
      }
    });
  }

  // TODO: review is it needed in the near future, currently disabled. Do not remove!
  /*experiment(attrs) {
    const value = this.experimentService.getConfigBySid(attrs.key, uid, attrs.name, attrs.default);
    attrs.model.experiments = attrs.model.experiments || {};
    attrs.model.experiments[attrs.name] = attrs.model.experiments[attrs.name] || {};
    attrs.model.experiments[attrs.name][attrs.key] = value;
    attrs.model.track = this.melidataTrack;

    return render({ template: attrs.template, model: attrs.model });
  }*/
}


module.exports = Melidata;
