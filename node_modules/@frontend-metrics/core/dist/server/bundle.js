function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const logger = require('frontend-logger');

const {
  DEVELOPMENT
} = require('frontend-env');

const feConfig = require('frontend-config');

const TrafficSlots = require('./traffic-slots');

const {
  supportedPlugins
} = require('./supported-plugins');

const log = logger('@frontend-metrics/core');
const plugins = supportedPlugins.map(sp => {
  // eslint-disable-next-line import/no-dynamic-require, global-require, security/detect-non-literal-require
  const plugin = require(`${sp.module}/internal`);

  plugin.module = sp.module;
  return plugin;
});

const rewind = () => {
  plugins.forEach(plugin => {
    const {
      PluginComponent
    } = plugin;
    PluginComponent.rewind();
  });
};

const bundle = async (req, customConfigFn) => {
  const pluginsTrack = await Promise.all(plugins.map(async p => {
    const {
      PluginComponent,
      Tracker,
      module,
      propsName
    } = p;
    const tracker = new Tracker(req);

    if (PluginComponent.peek()) {
      const feConfigMetrics = (customConfigFn // In case Odin needs to use another config they can provide a custom function to resolve their config
      ? customConfigFn(propsName, req.platform.id, req.platform.siteId) : feConfig.get(propsName, req.platform.id, req.platform.siteId)) || {};
      const componentProps = feConfigMetrics || {};
      const rewindResult = PluginComponent.rewind() || {};

      const props = _objectSpread(_objectSpread({}, componentProps), rewindResult); // Component usage takes precedence over fe-config


      if (tracker.debugMode) {
        props.traffic = {
          from: 0,
          to: 99
        };
      }

      const {
        from = 0,
        to = 99
      } = props.traffic ? props.traffic : {};
      const trackerSnippet = await tracker.track(props);
      return {
        track: `function(){${trackerSnippet}}`,
        from,
        to,
        module,
        props,
        debugMode: tracker.debugMode
      };
    }

    return null;
  }));
  const pluginsInUse = pluginsTrack.filter(Boolean); // Enable metric plugins by traffic slots

  const trafficSlotsManager = new TrafficSlots(req);
  const pluginsEnabled = trafficSlotsManager.buildCustomSlots(pluginsInUse).filter(slot => slot.enabled);

  if (DEVELOPMENT) {
    const slotIdentifier = trafficSlotsManager.getSlotIdentifier();
    pluginsInUse.forEach(p => {
      log.info('Metrics Plugin', {
        module: p.module,
        enabled: !!pluginsEnabled.find(pe => pe.module === p.module),
        debugMode: p.debugMode,
        props: JSON.stringify(p.props),
        traffic: JSON.stringify({
          from: p.from,
          to: p.to
        }),
        slotIdentifier
      });
    });
  }

  return pluginsEnabled.map(p => ({
    src: p.track,
    on: 'load',
    type: 'function'
  }));
};

module.exports = {
  bundle,
  rewind
};