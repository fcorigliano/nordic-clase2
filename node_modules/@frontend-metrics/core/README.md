# @frontend-metrics/core

> ⚠️ WARNING: This package and its documentation is intended to be used internally in nordic by frontend-layout or any other custom layout. If you want to learn how to use an specific plugin then stop reading here and read the plugin specific documentation within [the nordic website](http://nordic.ml.com/docs/api/Nordic%20Modules/frontend-analytics)

---

**@frontend-metrics/core** is intended to manage different metric scripts like Hotjar and others that can be supported in the future. 
It's main purpose is to split the traffic between the scripts that are supported and also enabled, bundling them and returning the final code.


## Creating a new plugin

### 1. Add the new plugin to supported-plugins.js
Add the new plugin you're creating to `supported-plugins.js`.

Each plugin must be configured with the following:
* `module`: the npm package name of the new plugin you're about to create

Example:
```js
const supportedPlugins = [
  {
    module: '@frontend-metrics/specificPlugin', // Make sure it matches the package.json name of the new plugin
  }
];
```

### 2. Create the interface for the new plugin

Each plugin must export an `internal` directory with an `index.js` file with the following interface:

```js
// @frontend-metrics/hotjar/internal/index.js

module.exports = {
  Tracker, 
  bundle,
  propsName,
};
```

More information about each in:
- [PluginComponent](#PluginComponent),
- [Tracker](#tracker)
- [propsName](#propsName)

#### PluginComponent
A React component that will be used by the projects when they `require` it. At the moment you must export it using `react-side-effect` as a wrapper. 
**We use this component as an interface to retrieve options** for the plugin; since all logic of rendering the actual "tracking code" is solved by [`tracker`](#tracker) you'll probably end up returning just `null` in this component.

Design detail: This interface although "weird" by React, allows devs to configure the plugin dinamically. They can use conditions to render it, switch options based on the user that made the request, etc.

#### Tracker
A class that will be executed by `@frontend-metrics/core`. 

You must implement the following methods:
 - `constructor()`: Receives a `req` object in case you need to get data from frontend-config or read headers, etc.
 - `tracker(options)`: Returns the tracking code as a string; don't worry about the `<script>` tags, they'll be later rendered by Layout. The options you'll receive is explained in [options](#3-options).

 #### propsName
 A name with which `@frontend-metrics/core` will retrieve the props from `frontend-config` of the module.  More on this in [Options](#3-options) 

### 3. Options
**In your [Tracker](#Tracker)** you'll probably need data such as `ids`, `userId`, `tags`, etc; we call these, options. This section explains how a developer can specify their options and how it works:

#### 3.1. How to pass options to your plugin
There are 2 ways for developers to set the options of your plugin. 

1. Through `frontend-config`
  **@frontend-metrics/core** will read all config of your previously defined [`propsName`](#propsName), located under `platform` or `siteId` keys. E.g: Supposing you defined `propsName` as `wonderfulPlugin`:

  ```js
    // project config/default.js (or any other frontend-config file)
    {
        /* wonderfulPlugin won't be read from the root of config, only on platform or siteId keys */
        ML: {
            wonderfulPlugin: { /* you'll receive this config if no siteId has this key */ }
            MLA: {
                wonderfulPlugin: { /* you'll receive this if the request was on MLA */ }
            }
        }
    }
  ``` 
2. Through your `PluginComponent`:
  When a project renders your component and passes props to it; **@frontend-metrics/core** will then obtain them, merge them with the `frontend-config` ones and pass them to you. These options has **precedence over frontend-config data**. Following the previous example:
  ```js
    // project view.js
    const React = require('react');
    const WonderfulPlugin = require('@frontend-metrics/wonderfulPlugin');

    const Page = () => (
        <>
            <WonderfulPlugin
                {/* you'll receive every prop used by the project as options */}
            />
        </>
    )
  ```

#### 3.2. What options are required for all plugins
**@frontend-metrics/core** only requires the following options:
```js
traffic: { // If not provided it'll default to 100% of users. More on this in the TrafficSlots section
  from: Number,
  to: Number
}
```

#### Traffic Slots
**Traffic Slots** allows to enable plugins for a custom percentage of users so we don't impact them all with unnecessary performance overhead. 

These slots can overlap or not depending on how we configure them.

Users will be assigned a **Slot Identifier** to be used later to identify which plugins must be enabled. This identifier is obtained from the _`_d2id`_ cookie value. See _`TrafficSlot.getSlotIdentifier()`_ in `src/server/traffic-slots.js` for further reference.

#### Traffic Slots Detailed Example
Let's say we want to enable 3 supported plugins, following these rules:
* pluginA: 50%
* pluginB: 50%
* pluginC: 30%
* pluginA and pluginB should not overlap
* pluginC can overlap only with pluginA

We can achieve this setup with the following 
```js
{
    ML: {
        pluginA: {
            traffic: {
                from: 0,
                to: 49,
            },
        },
        pluginB: {
            traffic: {
                from: 50,
                to: 99,
            },
        },
        pluginC: {
            traffic: {
                from: 0,
                to: 29,
            },
        },
    }
}
```

> If no `traffic` option is provided, it will be enabled at 100% by default: `{from: 0, to: 99}`.

> Each plugin will then be responsible on how to split the traffic (if needed) by its different implementations.
