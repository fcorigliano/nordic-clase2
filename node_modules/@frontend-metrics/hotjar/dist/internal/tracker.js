function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const env = require('frontend-env');

const assert = require('assert');

class Tracker {
  /**
   * @param {object} req
   */
  constructor(req) {
    assert(req, 'Request is required');
    this.req = req;
    this.debugMode = this.req.headers && typeof this.req.headers['x-hotjar-debug'] !== 'undefined' || this.req.query && typeof this.req.query.hotjar_debug !== 'undefined';
  }
  /**
   * If given options are valid and Hotjar must be enabled, returns the Hotjar JS code.
   * @param {object} options
   */


  async track(options = {}) {
    const hasUserConsent = this.req.meliCookies ? await this.req.meliCookies.userConsentCookieCategory('traceability') : false;

    if (options.id && (!options.disabled && hasUserConsent !== false || this.debugMode)) {
      const hotjarId = Array.isArray(options.id) ? options.id[0] : options.id;
      return this.getHotjarCode(_objectSpread(_objectSpread({}, options), {}, {
        id: hotjarId
      }));
    }

    return null;
  }
  /**
   * Returns the Hotjar JS code.
   * @param {object} options
   */


  getHotjarCode(options) {
    const triggers = this.parseTriggers(options.triggers);
    return `
    (function(h,o,t,j,a,r){
      h.hj= h.hj || function(){(h.hj.q=h.hj.q||[]).push(arguments)};
      h._hjSettings={hjid:${options.id},hjdebug:${this.debugMode},hjsv:5};
      a=o.getElementsByTagName('head')[0];
      r=o.createElement('script');r.async=1;
      r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
      a.appendChild(r);
    })(window,document,'//static.hotjar.com/c/hotjar-','.js?sv=');
    hj('tagRecording', ${this.parseTags(options.tags, options.tagPrefix)});
    ${triggers.length ? triggers.map(trigger => `hj('trigger', '${trigger}');`).join('\n\t') : ''}
    `;
  }
  /**
   * Parse recording tags.
   * Adds some default tags and prefix them if tagPrefix is present.
   * @param {array} customTags
   * @param {string} tagPrefix
   */


  parseTags(customTags = [], tagPrefix = '') {
    const tags = Array.isArray(customTags) ? [...customTags] : [];
    const userType = this.req.user && this.req.user.raw && this.req.user.raw.tags && this.req.user.raw.tags.includes('test_user') ? 'test' : 'normal';
    tags.push(`user_type: ${userType}`);

    if (env.app) {
      tags.push(`app: ${env.app}`);
    }

    return JSON.stringify( // make sure we do not have duplicated tags
    [...new Set(tags)] // prepend tag prefix
    .map(tag => tagPrefix + tag));
  }

  parseTriggers(customTriggers = []) {
    const triggers = Array.isArray(customTriggers) ? customTriggers : [];
    return [...new Set(triggers)]; // make sure we do not have duplicated triggers
  }

}

exports = module.exports = Tracker; // eslint-disable-line no-multi-assign