const client = {
  name: 'http-cookies',
  version: '1.0.0-test.0',
};
const tags = {
  application: 'app-demo',
  device: 'desktop',
  platform: 'ml',
  site: 'mla',
  webview: false,
};

const getModule = (reject = false) => {
  const postMock = reject ? jest.fn().mockRejectedValue() : jest.fn().mockResolvedValue();
  jest.doMock('frontend-restclient', () => () => ({ post: postMock }));
  // eslint-disable-next-line global-require
  const { recordMetric } = require('../buffer-metrics');

  const assertCallback = () => {
    expect(postMock).toHaveBeenCalled();
    return postMock.mock.calls[0];
  };

  return {
    recordMetric,
    postMock,
    assertCallback,
  };
};

describe('Buffer metrics', () => {
  beforeEach(() => {
    jest.resetModules();
    jest.resetAllMocks();
  });

  test('missing tags', () => {
    const {
      recordMetric,
    } = getModule();

    expect(() => {
      recordMetric({}, { platform: 'ml' }, [], {});
    }).toThrow('some tags are missing');
  });

  test('recordMetric rejected', (done) => {
    const {
      recordMetric,
      assertCallback,
    } = getModule(true);

    const cookies = [{
      domain: null,
      expires: 'Fri, 19 Feb 2021 14:42:43 GMT',
      'max-age': null,
      name: 'rememberme',
      path: '/',
      samesite: 'None',
      secure: true,
      'unknown-metadata': ' HttpOnly',
    }];

    const config = {
      bufferSize: 1,
      flushTime: 1,
    };

    recordMetric(client, tags, cookies, config);

    setTimeout(() => {
      const call = assertCallback();
      expect(call[0]).toEqual('/v2/client-cookies');
      expect(call[1]).toMatchSnapshot();
      expect(call[1].data.cookies.length).toEqual(1);
      done();
    }, config.flushTime * 2);
  });

  test('recordMetric with timeout', (done) => {
    const {
      recordMetric,
      assertCallback,
    } = getModule();

    const cookies = [{
      domain: null,
      expires: 'Fri, 19 Feb 2021 14:42:43 GMT',
      'max-age': null,
      name: 'rememberme',
      path: '/',
      samesite: 'None',
      secure: true,
      'unknown-metadata': ' HttpOnly',
    }];

    const config = {
      bufferSize: 1,
      flushTime: 1,
    };

    recordMetric(client, tags, cookies, config);

    setTimeout(() => {
      const call = assertCallback();
      expect(call[0]).toEqual('/v2/client-cookies');
      expect(call[1]).toMatchSnapshot();
      expect(call[1].data.cookies.length).toEqual(1);
      done();
    }, config.flushTime * 2);
  });

  test('recordMetric with full buffer', () => {
    const {
      recordMetric,
      assertCallback,
    } = getModule();

    const cookiesA = [{
      domain: null,
      expires: 'Fri, 19 Feb 2021 14:42:43 GMT',
      'max-age': null,
      name: 'rememberme',
      path: '/',
      samesite: 'None',
      secure: true,
      'unknown-metadata': ' HttpOnly',
    }];

    const cookiesB = [{
      domain: null,
      expires: 'Fri, 19 Feb 2021 14:42:43 GMT',
      'max-age': null,
      name: 'authorization',
      path: '/',
      samesite: 'None',
      secure: true,
      'unknown-metadata': ' HttpOnly',
    }];

    const config = {
      bufferSize: 2,
      flushTime: 1000,
    };

    recordMetric(client, tags, cookiesA, config);
    recordMetric(client, tags, cookiesB, config);

    const call = assertCallback();
    expect(call[0]).toEqual('/v2/client-cookies');
    expect(call[1]).toMatchSnapshot();
    expect(call[1].data.cookies.length).toEqual(2);
  });
});
