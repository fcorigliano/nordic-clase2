const getModule = () => require('./cookies-preferences');
const { categories: requestConstants } = require('./constants/requests');
const { userPreferencesProperty } = require('./constants/namespaces');
const { admins } = require('./constants/domains');
const {
  loggedCookie,
  loggedFallbackCookie,
} = require('./constants/cookies');

const environmentName = 'prod';

const mockPersonalDataPreferences = (customEnvironmentName) => {
  const envName = customEnvironmentName || environmentName;
  const getPersonalDataPreferencesEnvironmentNameResult = customEnvironmentName || environmentName;
  const getPersonalDataPreferencesEnvironmentName = jest.fn().mockReturnValue(
    getPersonalDataPreferencesEnvironmentNameResult,
  );

  const someUrl = `/${envName}/some-url`;
  const getPersonalDataPreferencesUrlsResult = { userPreferences: someUrl };
  const getPersonalDataPreferencesUrls = jest.fn().mockReturnValue(getPersonalDataPreferencesUrlsResult);

  jest.doMock('./personal-data-preferences', () => ({
    getPersonalDataPreferencesEnvironmentName,
    getPersonalDataPreferencesUrls,
  }));

  const assertGetEnvironmentNameCalled = (req) => {
    expect(getPersonalDataPreferencesEnvironmentName).toHaveBeenCalledWith(req);
  };

  const assertGetUrlsCalled = (environment = envName) => {
    expect(getPersonalDataPreferencesUrls).toHaveBeenCalledWith(environment);
  };

  return {
    assertGetEnvironmentNameCalled,
    assertGetUrlsCalled,
  };
};

const mockGetCategories = (req, ...results) => {
  const get = jest.fn();

  if (results.length === 0) results[0] = null;

  results.forEach(result => get.mockReturnValue(result));

  jest.doMock('./categories', () => ({ get }));

  const assertCalled = ({ nthCall = 1, customEnvironmentName, platformId, siteId, domain }) => {
    expect(get).toHaveBeenNthCalledWith(nthCall, {
      environmentName: customEnvironmentName || environmentName,
      platformId,
      siteId,
      domain,
      req,
    });
  };

  return {
    assertCalled,
  };
};

const mockDpConfigService = (req, ...results) => {
  const getValue = jest.fn();

  if (results.length === 0) results[0] = null;

  results.forEach(result => getValue.mockReturnValueOnce(result));

  jest.doMock('data-privacy-config', () => ({
    getValue,
  }));

  const assertDpConfigCalled = ({ key, environment, nthCall = 1 }) => {
    expect(getValue).toHaveBeenNthCalledWith(nthCall, {
      key,
      req,
      environment,
    });
  };

  const assertDpConfigNotCalled = ({ key, nthCall = 1 }) => {
    expect(getValue).not.toHaveBeenNthCalledWith(nthCall, {
      key,
      req,
    });
  };

  return {
    assertDpConfigCalled,
    assertDpConfigNotCalled,
  };
};

const mockRestClient = ({
  getResults = [],
  getMockImplementation,
}) => {
  const get = jest.fn();
  getResults.forEach(result => get.mockResolvedValueOnce({
    data: {
      [userPreferencesProperty]: result,
    },
  }));
  if (getMockImplementation) {
    get.mockImplementation(getMockImplementation);
  }
  const restClient = jest.fn().mockReturnValue({ get });
  jest.doMock('frontend-restclient', () => restClient);

  const assertCalled = () => {
    expect(restClient).toHaveBeenCalledWith(requestConstants.restClientConfig);
  };

  return {
    assertCalled,
  };
};

const defaultCategories = {
  advertising: true,
  tracking: true,
};

const mockRequest = () => ({
  platform: {
    id: 'ML',
    siteId: 'MLA',
    domain: 'mercadolibre.com.ar',
  },
  device: {
    type: 'desktop',
  },
  headers: {
    'some-header-key': 'some-header-value',
  },
  cookies: {
    'some-cookie-key': 'some-cookie-value',
  },
  hostname: 'test',
  user: {
    id: 1,
  },
});

const mockResponse = () => {
  const res = {};
  res.cookie = jest.fn().mockReturnValue(res);
  return res;
};

const mockStatsd = () => {
  jest.doMock('./statsd', () => ({ send: () => {} }));
};

const mockLogger = () => {
  jest.doMock('./logger', () => ({ error: () => {} }));
};

describe('Get cookies categories', () => {
  beforeEach(() => {
    jest.resetModules();
  });

  describe('get', () => {
    mockStatsd();
    mockLogger();

    it('should create fallback and logged cookie when receive getCategoriesData from api user data preferences', () => {
      const req = mockRequest();
      const res = mockResponse();
      const ttlLogged = 100;
      const ttlFallback = 200;

      const {
        assertGetEnvironmentNameCalled,
        assertGetUrlsCalled,
      } = mockPersonalDataPreferences();
      const { assertDpConfigCalled } = mockDpConfigService(req, ttlLogged, ttlFallback);

      const { assertCalled: assertRestClientCalled } = mockRestClient({
        getResults: [defaultCategories],
      });

      const { get } = getModule();

      return get(req, res).then(categories => {
        assertGetEnvironmentNameCalled(req);
        assertGetUrlsCalled();
        assertDpConfigCalled({ environment: 'production', key: loggedCookie.ttlConfigKey, nthCall: 1 });
        assertDpConfigCalled({ environment: 'production', key: loggedFallbackCookie.ttlConfigKey, nthCall: 2 });
        expect(res.cookie).toHaveBeenCalledTimes(2);
        assertRestClientCalled();

        return expect(categories).toEqual({ categories: defaultCategories });
      });
    });

    it('should return null when host is admin and cookie fallback not exists', () => {
      const req = mockRequest();
      req.hostname = admins;

      const { get } = getModule();

      const res = mockResponse();

      return get(req, res).then(categories => expect(categories).toEqual(null));
    });

    it('should return null when host is admin and cookie fallback exists with different id', () => {
      const req = mockRequest();
      req.hostname = admins;
      const cookieData = { categories: defaultCategories, userId: 10 };
      req.cookies[loggedFallbackCookie.name] = JSON.stringify(cookieData);

      const { get } = getModule();

      const res = mockResponse();

      return get(req, res).then(categories => expect(categories).toEqual(null));
    });

    it('should return fallback cookie when host is admin and cookie fallback exists', () => {
      const req = mockRequest();
      req.hostname = admins;
      const cookieData = { categories: defaultCategories, userId: req.user.id };
      req.cookies[loggedFallbackCookie.name] = JSON.stringify(cookieData);

      const { get } = getModule();

      const res = mockResponse();

      return get(req, res).then(categories => expect(categories).toEqual({ categories: cookieData.categories }));
    });
    it('should return fallback cookie when plataform not exists and cookie fallback exists', () => {
      const req = mockRequest();
      const cookieData = { categories: defaultCategories, userId: req.user.id };
      req.cookies[loggedFallbackCookie.name] = JSON.stringify(cookieData);
      delete req.platform;

      const { get } = getModule();

      const res = mockResponse();

      return get(req, res).then(categories => expect(categories).toEqual({ categories: cookieData.categories }));
    });

    it('should return fallback cookie when siteId not exists and cookie fallback exists', () => {
      const req = mockRequest();
      const cookieData = { categories: defaultCategories, userId: req.user.id };
      req.cookies[loggedFallbackCookie.name] = JSON.stringify(cookieData);
      delete req.platform.siteId;

      const { get } = getModule();

      const res = mockResponse();

      return get(req, res).then(categories => expect(categories).toEqual({ categories: cookieData.categories }));
    });

    it('should return fallback cookie when domain not exists and cookie fallback exists', () => {
      const req = mockRequest();
      const res = mockResponse();
      const cookieData = { categories: defaultCategories, userId: req.user.id };

      req.cookies[loggedFallbackCookie.name] = JSON.stringify(cookieData);
      delete req.platform.domain;

      const { get } = getModule();

      return get(req, res).then(categories => expect(categories).toEqual({ categories: cookieData.categories }));
    });

    it('should use fallback cookie and refresh categories when cannot call user preferences api', () => {
      const res = mockResponse();
      const req = mockRequest();
      const error = 'error to fetch api';

      const { assertCalled: assertRestClientCalled } = mockRestClient({
        getMockImplementation: () => Promise.reject(error),
      });

      const { assertCalled: assertGetCategoriesCalled } = mockGetCategories(
        req,
        Promise.resolve(Object.keys(defaultCategories)),
      );

      const { get } = getModule();

      const cookieData = { categories: defaultCategories, userId: req.user.id };

      req.cookies[loggedFallbackCookie.name] = JSON.stringify(cookieData);

      return get(req, res).then(categories => {
        assertRestClientCalled();
        assertGetCategoriesCalled({
          nthCall: 1,
          platformId: req.platform.id,
          siteId: req.platform.siteId,
          domain: req.platform.domain,
        });

        return expect(categories).toEqual({ categories: defaultCategories });
      });
    });

    it('should try to use fallback cookie and return it when have any problem to mount categories', () => {
      const res = mockResponse();
      const req = mockRequest();
      const error = 'error to fetch api';

      const { assertCalled: assertRestClientCalled } = mockRestClient({
        getMockImplementation: () => Promise.reject(error),
      });

      const { assertCalled: assertGetCategoriesCalled } = mockGetCategories(
        req,
        Promise.resolve(null),
      );

      const { get } = getModule();

      const cookieData = { categories: defaultCategories, userId: req.user.id };

      req.cookies[loggedFallbackCookie.name] = JSON.stringify(cookieData);

      return get(req, res).then(categories => {
        assertRestClientCalled();
        assertGetCategoriesCalled({ nthCall: 1, platformId: req.platform.id, siteId: req.platform.siteId, domain: req.platform.domain });

        return expect(categories).toEqual({ categories: defaultCategories });
      });
    });

    it('should try to use fallback cookie and return null when have any problem to refresh categories', () => {
      const res = mockResponse();
      const req = mockRequest();
      const error = 'error to fetch api';

      const { assertCalled: assertRestClientCalled } = mockRestClient({
        getMockImplementation: () => Promise.reject(error),
      });

      const { assertCalled: assertGetCategoriesCalled } = mockGetCategories(req);

      const { get } = getModule();

      const cookieData = { categories: defaultCategories, userId: req.user.id };

      req.cookies[loggedFallbackCookie.name] = JSON.stringify(cookieData);

      return get(req, res).then(categories => {
        assertRestClientCalled();
        assertGetCategoriesCalled({ nthCall: 1, platformId: req.platform.id, siteId: req.platform.siteId, domain: req.platform.domain });

        return expect(categories).toEqual(null);
      });
    });

    it('should return fallback cookie with only valid categories when need to get fallback cookie', () => {
      const req = mockRequest();
      const res = mockResponse();

      const invalidCategories = {
        ...defaultCategories,
        invalidCategFunc: () => 1 + 1,
        invalidCategString: 'xpto',
        invalidCategInt: 123,
      };
      const cookieData = { categories: invalidCategories, userId: req.user.id };
      req.cookies[loggedFallbackCookie.name] = JSON.stringify(cookieData);
      req.hostname = admins;

      const { get } = getModule();

      return get(req, res).then(resultCategories => {
        expect(resultCategories.categories.invalidCategFunc).toEqual(undefined);
        expect(resultCategories.categories.invalidCategString).toEqual(null);
        expect(resultCategories.categories.invalidCategInt).toEqual(null);
        const expectedCategories = { ...defaultCategories, invalidCategInt: null, invalidCategString: null };
        return expect(resultCategories).toEqual({ categories: expectedCategories });
      });
    });
  });
});
