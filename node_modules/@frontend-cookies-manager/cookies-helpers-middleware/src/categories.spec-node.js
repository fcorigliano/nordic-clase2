const { categories: requestConstants } = require('./constants/requests');
const { categoriesProperty } = require('./constants/namespaces');
const { cookiesCategoriesAPIError } = require('./constants/statsd');

jest.useFakeTimers();

const getModule = () => require('./categories');

const environmentName = 'prod';
const platformId = 'ML';
const siteId = 'MLA';
const domain = 'mercadolibre.com.ar';
const req = {
  platform: {
    id: platformId,
    siteId,
    domain,
  },
};

const result1 = {
  value: 'some-response-value-1',
};
const result2 = {
  value: 'some-response-value-2',
};

const mockRestClient = ({
  getResults = [],
  getMockImplementation,
  customEnvironmentName,
}) => {
  const categoriesUrl = `/${customEnvironmentName || environmentName}/personal-data-preferences/preferences/categories`;
  const buildContextResult = { value: 'some-context' };
  const buildContext = jest.fn().mockReturnValue(buildContextResult);
  jest.doMock('frontend-restclient/src/build-context', () => buildContext);

  const buildFlowStarterContextResult = { value: 'some-flow-starter-context' };
  const buildFlowStarterContext = jest.fn().mockReturnValue(buildFlowStarterContextResult);
  jest.doMock('frontend-restclient/src/build-flow-context', () => buildFlowStarterContext);

  const get = jest.fn();
  getResults.forEach(result => get.mockResolvedValueOnce({
    data: {
      [categoriesProperty]: result,
    },
  }));
  if (getMockImplementation) {
    get.mockImplementation(getMockImplementation);
  }
  const restClient = jest.fn().mockReturnValue({ get });
  jest.doMock('frontend-restclient', () => restClient);

  const assertCalled = (updateCache) => {
    expect(restClient).toHaveBeenCalledWith(requestConstants.restClientConfig);
    expect(get).toHaveBeenCalledWith(categoriesUrl, {
      params: {
        platform_id: platformId,
        site_id: siteId,
        domain,
      },
      context: updateCache
        ? buildFlowStarterContextResult
        : buildContextResult,
    });
    if (updateCache) {
      expect(buildFlowStarterContext).toHaveBeenCalledWith();
    } else {
      expect(buildContext).toHaveBeenCalledWith(req);
    }
  };

  return {
    assertCalled,
  };
};
const mockStatsd = () => {
  const send = jest.fn();
  jest.doMock('./statsd', () => ({ send }));

  const assertCalled = () => {
    expect(send).toHaveBeenCalledWith(cookiesCategoriesAPIError, req);
  };

  return {
    assertCalled,
  };
};

const mockLogger = () => {
  const errorMock = jest.fn();
  jest.doMock('./logger', () => ({ error: errorMock }));

  const assertCalled = (error) => {
    expect(errorMock).toHaveBeenCalledWith('Error getting cookies preferences from API', {
      req,
      error,
    });
  };

  const assertNotCalled = () => {
    expect(errorMock).not.toHaveBeenCalled();
  };

  return {
    assertCalled,
    assertNotCalled,
  };
};

describe('Categories service', () => {
  beforeEach(() => jest.resetModules());

  describe('get', () => {
    it('should return data', (done) => {
      const { assertCalled } = mockRestClient({
        getResults: [result1],
        customEnvironmentName: 'stage',
      });
      const { assertNotCalled: assertNotCalledLogger } = mockLogger();

      const { get } = getModule();

      get({ environmentName: 'stage', platformId, siteId, domain, req })
        .then((data) => {
          expect(data).toBe(result1);
          assertCalled(false);
          assertNotCalledLogger();
          done();
        });
    });

    it('should return cached data', (done) => {
      const { assertCalled } = mockRestClient({
        getResults: [result1],
      });
      const { assertNotCalled: assertNotCalledLogger } = mockLogger();

      const { get } = getModule();

      Promise.all([
        get({ environmentName, platformId, siteId, domain, req }),
        get({ environmentName, platformId, siteId, domain, req }),
      ])
        .then(([data1, data2]) => {
          expect(data1).toBe(result1);
          expect(data2).toBe(result1);
          assertCalled(false);
          assertNotCalledLogger();
          done();
        });
    });

    it('should return cached data, schedule update, and return scheduled update data', (done) => {
      const { assertCalled } = mockRestClient({
        getResults: [result1, result2],
      });
      const { assertNotCalled: assertNotCalledLogger } = mockLogger();

      const { get } = getModule();

      Promise.all([
        get({ environmentName, platformId, siteId, domain, req }),
        get({ environmentName, platformId, siteId, domain, req }),
      ])
        .then(([data1, data2]) => {
          expect(data1).toBe(result1);
          expect(data2).toBe(result1);
          assertCalled(false);
          assertNotCalledLogger();

          // run scheduled update
          jest.runAllTimers();

          // Promise.resolve().then() is an horrible hack
          // to resolve the second response of restclient get mock
          Promise.resolve().then(() => get({ environmentName, platformId, siteId, domain, req })
            .then((data3) => {
              expect(data3).toBe(result2);
              assertCalled(true);
              assertNotCalledLogger();

              done();
            }));
        });
    });

    it('should return non-cached data', (done) => {
      const { assertCalled } = mockRestClient({
        getResults: [result1, result2],
      });
      const { assertNotCalled: assertNotCalledLogger } = mockLogger();

      const { get } = getModule();

      get({ environmentName, platformId, siteId, domain, req })
        .then((data1) => {
          expect(data1).toBe(result1);
          assertCalled(false);
          assertNotCalledLogger();

          jest.runAllTimers();

          get({ environmentName, platformId, siteId, domain, req })
            .then((data2) => {
              expect(data2).toBe(result2);
              assertCalled(false);
              assertNotCalledLogger();

              done();
            });
        });
    });

    it('should log and track errors and schedule a new update', (done) => {
      let counter = 0;
      const error = 'some error';

      const { assertCalled: assertCalledRestClient } = mockRestClient({
        getMockImplementation: () => {
          counter += 1;
          return counter === 1
            ? Promise.reject(error)
            : Promise.resolve({
              data: {
                [categoriesProperty]: result1,
              },
            });
        },
      });

      const { assertCalled: assertCalledStatsd } = mockStatsd();
      const { assertCalled: assertCalledLogger } = mockLogger();

      const { get } = getModule();

      get({ environmentName, platformId, siteId, domain, req })
        .catch((catchResult) => {
          expect(catchResult).toBe(error);
          assertCalledRestClient(false);
          assertCalledStatsd();
          assertCalledLogger(error);

          jest.runAllTimers();

          // Promise.resolve().then() is an horrible hack
          // to resolve the response of restclient get mock
          Promise.resolve().then(() => get({ environmentName, platformId, siteId, domain, req })
            .then((data2) => {
              expect(data2).toBe(result1);
              assertCalledRestClient(false);

              done();
            }));
        });
    });
  });
});
