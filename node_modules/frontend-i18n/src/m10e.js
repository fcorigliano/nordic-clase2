/**
 * Module dependencies
 */
const path = require('path');
const fs = require('fs');
const { finished } = require('stream');
const { promisify } = require('util');
const { RestClient, buildFlowStarterContext } = require('frontend-restclient');
const FormData = require('form-data');
const { GettextExtractor, JsExtractors } = require('gettext-extractor');
const logger = require('frontend-logger')('frontend-i18n');
const AdmZip = require('adm-zip');
const po2json = require('po2json');
const jsonfile = require('jsonfile');
const mkdirp = require('mkdirp');
const { exec } = require('child_process');
const cfg = require('frontend-config');
const { countries } = require('frontend-country_config');
const { I18N_SERVICE_HOST } = require('frontend-env');
const { reportLocales } = require('./locales');

const config = cfg.get('i18n') || {};

const finishedAsync = promisify(finished);

const restClient = RestClient();

class M10e {
  constructor() {
    this.translationsSite = Object.keys(countries);
    this.translationsAvailable = {};
    this.messagesFilename = 'messages.po';
    this.i18nDirName = 'i18n';
    this.serviceUrl = this.getI18nServiceHost();
    this.zipPath = `${process.cwd()}/${this.i18nDirName}/all.zip`;
    this.destinationFolder = 'app/translations';

    jsonfile.spaces = 2;
  }

  /**
   *
   */

  downloadTranslations(destinationFolder, callback) {
    if (!fs.existsSync(`./${this.i18nDirName}`)) {
      fs.mkdirSync(`./${this.i18nDirName}`);
    }
    this.cleanOldTranslations((cleanError) => {
      if (cleanError) {
        logger.error('Error cleaning up old translations.');
        callback(cleanError);
      } else {
        this.downloadTranslationsPackage((downloadError) => {
          if (downloadError) {
            logger.error('Error dowloading translations.');
            callback(downloadError);
          } else {
            this.unzipTranslations((unzipError) => {
              if (unzipError) {
                logger.error('Error Unziping translations.');
                callback(unzipError);
              } else {
                this.parseTranslations(destinationFolder, (parseError) => {
                  if (parseError) {
                    logger.error('Error parsing PO to JSON translations.');
                    callback(parseError);
                  }
                });
                this.report((reportError) => {
                  if (reportError) {
                    logger.error('Error getting the status report.');
                    callback(reportError);
                  }
                });
              }
            });
          }
        });
      }
    });
  }

  generateSources(_fileName, callback) {
    this.initPaths(_fileName);
    this.scanDirectory(config.srcPath, _fileName, config.extNames, callback);
  }

  uploadSources(_force, callback) {
    const force = (_force === true || _force === 'true');
    this.generateSources(this.messagesFilename, (error) => {
      logger.info('uploadSources::generateSources');
      if (error) {
        logger.error(`uploadSources::generateSources ${error}`);
        callback(error);
      } else {
        logger.info('uploadSources::zipAndUploadSources');
        try {
          this.zipAndUploadSources(this.messagesFilename, force, callback);
        } catch (e) {
          logger.error(`uploadSources::zipAndUploadSources ERR ===> ${e}`);
        }
      }
    });
  }

  // ////////////////////////////////////////////////////////////////////////

  downloadTranslationsPackage(callback) {
    logger.info('Downloading translation.');
    const url = `${this.serviceUrl}/apps/${config.app}/translations`;
    logger.info(`Downloading URL ${url}`);

    restClient.get(url, { context: buildFlowStarterContext(), responseType: 'stream' })
      .then((res) => {
        const writeStream = fs.createWriteStream(this.zipPath);
        res.data.pipe(writeStream);

        return finishedAsync(writeStream);
      })
      .then(() => {
        logger.info('Translations Downloaded.');
        callback();
      })
      .catch((err) => {
        logger.error(`Problem with request: ${err.message}`);
        callback(err);
      });
  }

  // Solo debo parsear los archivos .po
  parseTranslations(destinationFolder, callback) {
    logger.info('Parsing translation to JSON.');
    const poPath = `./${this.i18nDirName}`;
    const JsonPath = destinationFolder || `./${this.destinationFolder}`;
    console.log(JsonPath);
    mkdirp.sync(JsonPath);
    this.parsePoToJson(poPath, JsonPath, callback);
  }

  parsePoToJson(srcPath, destPath, callback) {
    logger.info(`Parsing .po to .json | src:${srcPath}, dest:${destPath}`);
    fs.readdir(srcPath, (err, files) => {
      files.forEach((item) => {
        const srcDir = `${srcPath}/${item}`;
        const fileStat = fs.statSync(srcDir);

        if (fileStat.isDirectory()) {
          const destDir = `${destPath}/${item}`;

          if (!fs.existsSync(destDir)) {
            try {
              fs.mkdirSync(destDir);
              logger.info(`Created ${destDir} ${fs.existsSync(destDir)}`);
            } catch (e) {
              logger.error(`Error making new directory ${destDir}`);
              logger.error(e);
            }
          }

          const translationAvailable = item.split('-')[1];

          this.translationsAvailable[translationAvailable] = item;
          this.parsePoToJson(srcDir, destDir, callback);
        } else if (path.extname(item) === '.po') {
          const destFile = ((filePath) => {
            const filePathData = path.parse(filePath);
            return `${filePathData.dir}/${filePathData.name}.json`;
          })(`${destPath}/${item}`);

          fs.readFile(srcDir, (readErr, buffer) => {
            const jsonData = po2json.parse(buffer);
            // Remove the metadata from the .po template
            delete jsonData[''];
            jsonfile.writeFile(destFile, jsonData, (writeErr) => {
              if (writeErr) {
                logger.info(`Parsing [Err] ........ src:${srcDir} dest:${destFile} ${writeErr}`);
              } else {
                logger.info(`Parsing [OK] ........ ${destFile}`);
              }
            });
          });
        }
      });

      callback();
    });
  }

  removeDirectory(pathToRemove) {
    exec(`rm -rf ${pathToRemove}`, (err) => {
      if (err) {
        logger.warn(`Error removing ${pathToRemove}. ${err}`);
      }
    });
  }

  cleanOldTranslations(callback) {
    const that = this;

    fs.unlink(`${this.zipPath}`, (unlinkError) => {
      logger.info(`Cleaning ${this.zipPath}`);
      if (!unlinkError || unlinkError.code === 'ENOENT') {
        const files = fs.readdirSync(`./${this.i18nDirName}`);
        files.forEach((file) => {
          const filePath = path.join(`./${this.i18nDirName}`, file);
          const stats = fs.statSync(filePath);
          if (stats.isDirectory()) {
            that.removeDirectory(filePath);
          }
        });
        callback();
      } else {
        callback(unlinkError);
      }
    });
  }

  unzipTranslations(callback) {
    logger.info('Extracting zip.');
    const zip = new AdmZip(this.zipPath);
    zip.extractAllTo(this.i18nDirName, true);
    callback();
  }

  zipAndUploadSources(filename, force, callback) {
    let url = `${this.serviceUrl}/apps/${config.app}/sources?project_name=${config.project}&force=${force}`;
    if (config.translationProject) {
      url += `&translation_project=${config.translationProject}`;
    }

    logger.info('Zipping sources...');
    const filePath = `./${this.i18nDirName}/${filename}`;
    const zippedFilePath = `${filePath}.zip`;
    // usage: https://www.npmjs.com/package/adm-zip
    const zip = new AdmZip();
    zip.addLocalFile(filePath);
    zip.writeZip(zippedFilePath);
    logger.info('Uploading sources...');
    logger.info(`Uploading URL ${url}`);

    const data = new FormData();
    data.append('sources.zip', fs.createReadStream(zippedFilePath));
    restClient.post(url, {
      data,
      context: buildFlowStarterContext(),
      headers: data.getHeaders(),
    })
      .then((res) => {
        this.writeUploadReport(res.data);
        logger.info('Sources uploaded successfully!');
        callback();
      })
      .catch((err) => {
        if (err.response?.status >= 500) {
          const { status, data: resData } = err.response;
          logger.error(new Error(`Upload failed: error from i18n API. statusCode: ${status}\n${resData}`));
        } else if (err.code === 'ENOTFOUND') {
          logger.error('Psst! Are you connected to the VPN? You need to be connected', err);
        } else {
          // log de error genÃ©rico
          logger.error(`Upload failed: ${err.message}`);
        }

        callback(err);
      });
  }

  writeUploadReport(data) {
    try {
      const uploaded = data;
      console.log('=================================');
      console.log('New uploaded messages');
      console.log('=================================');
      if (uploaded.length === 0) {
        console.log('There are no new messages to upload');
      }
      uploaded.forEach((entry) => {
        const context = entry.context ? `[${entry.context}]` : '';
        const plural = entry.plural ? `[${entry.plural}]` : '';
        console.log(` ${context}${entry.singular}${plural}`);
      });
    } catch (error) {
      logger.error(`An error has occurred at building the upload report: ${error}`);
    }
  }

  initPaths(filename) {
    logger.info('Initializing...');
    const i18nDir = `./${this.i18nDirName}`;
    const i18nPath = `${i18nDir}/${filename}`;
    if (!fs.existsSync(i18nDir)) {
      try {
        fs.mkdirSync(i18nDir);
      } catch (e) {
        logger.error(`Error making new directory ${i18nDir}`);
        logger.error(e);
      }
    }

    if (fs.existsSync(i18nPath)) {
      fs.truncateSync(i18nPath, 0);
    } else {
      fs.writeFileSync(i18nPath, ' ');
    }
  }

  scanDirectory(directory, fileName, extNames = ['js'], callback) {
    logger.info(`Scaning ${directory} for source messages.`);

    if (extNames.length === 0) {
      throw new Error('At least one extension is required, none was given');
    }

    const extquery = extNames.join('|');

    const extractor = new GettextExtractor();
    /**
     * Gettext [by default](https://www.gnu.org/software/gettext/manual/gettext.html#Language-specific-options) has
     * the next keywords configured:
     *   gettext, dgettext:2, dcgettext:2, ngettext:1,2, dngettext:2,3, pgettext:1c,2, dpgettext:2c,3
     * Also fontend-i18n using gettext as an extractor has configured the next keywords:
     *   tr:1, trd:1, trn:1,2, trnd:1,2, npgettext:1c,2,3
     * Furthermore gettext parses using expressions when gettext-extractor is based on AST, so for gettext-extractor
     * `i18n.gettext` and `gettext` are different things. As a result we need to replicate all these combinations for
     * backward compatibility
     */
    try {
      extractor
        .createJsParser([
          JsExtractors.callExpression(['i18n.gettext', 'i18n.jsx.gettext', 'jsx.gettext', 'gettext', 'tr', 'trd'], {
            arguments: {
              text: 0,
            },
          }),
          JsExtractors.callExpression(['i18n.ngettext', 'i18n.jsx.ngettext', 'jsx.ngettext', 'ngettext', 'trn', 'trnd'], {
            arguments: {
              text: 0,
              textPlural: 1,
            },
          }),
          JsExtractors.callExpression(['i18n.pgettext', 'i18n.jsx.pgettext', 'jsx.pgettext', 'pgettext'], {
            arguments: {
              context: 0,
              text: 1,
            },
          }),
          JsExtractors.callExpression(['i18n.npgettext', 'i18n.jsx.npgettext', 'jsx.npgettext', 'npgettext'], {
            arguments: {
              context: 0,
              text: 1,
              textPlural: 2,
            },
          }),
          JsExtractors.callExpression(['dgettext', 'dcgettext'], {
            arguments: {
              text: 1,
            },
          }),
          JsExtractors.callExpression(['dngettext'], {
            arguments: {
              text: 1,
              textPlural: 2,
            },
          }),
          JsExtractors.callExpression(['dpgettext'], {
            arguments: {
              context: 1,
              text: 2,
            },
          }),
        ])
        .parseFilesGlob(`${directory}/**/*.@(${extquery})`);
    } catch (err) {
      logger.error(`Error scaning directory "${directory}".`);
      callback(err);
      return;
    }

    extractor.savePotFile(path.join(`./${this.i18nDirName}`, fileName));
    callback();
  }

  report(callback) {
    /**
     * The second report has two requests, so we need to wait for the first report to finish before starting the second one, in order to avoid mixing results between them.
     */
    this.reportProgress(callback)
      .then(() => {
        this.reportUntranslated(callback);
      });
  }

  /**
   * Translations in progress report
   */
  reportProgress(callback) {
    const progressUrl = `${this.serviceUrl}/apps/${config.app}/info/progress`;

    return restClient.get(progressUrl, { context: buildFlowStarterContext() })
      .then((res) => {
        this.writeProgressReport(res.data);
      })
      .catch((err) => {
        logger.error(`Problem with request: ${err.message}`);
        callback(err);
      });
  }

  /**
   * Untranslated report
   */
  reportUntranslated(callback) {
    reportLocales.forEach((locale) => {
      const untranslatedUrl = `${this.serviceUrl}/apps/${config.app}/info/untranslated/${locale}`;

      restClient.get(untranslatedUrl, { context: buildFlowStarterContext() })
        .then((res) => {
          this.writeUntranslatedReport(res.data, locale);
        })
        .catch((err) => {
          logger.error(`Problem with request: ${err.message}`);
          callback(err);
        });
    });
  }

  /**
   * Write the translation in progress report in the console
   */
  writeProgressReport(data) {
    try {
      const reportData = data;
      console.log('=================================');
      console.log('Translations in progress report');
      console.log('=================================');
      if (Object.keys(reportData).length === 0) {
        console.log('There are no translations in progress.');
      } else {
        reportLocales.forEach((locale) => {
          console.log(` [${locale}] ${reportData[locale].progress}% (${reportData[locale].translated}/${reportData[locale].total})`);
        });
      }
    } catch (error) {
      logger.error(`An error has occurred at building the progress report: ${error}`);
    }
  }

  /**
  * Write the translation in progress report in the console
  */
  writeUntranslatedReport(data, locale) {
    try {
      const reportData = data;
      console.log('=================================');
      console.log(`Untranslated report for ${locale}`);
      console.log('=================================');
      if (reportData.length === 0) {
        console.log('There are no keys untranslated.');
      }
      reportData.forEach((untranslated) => {
        const context = untranslated.context ? `[${untranslated.context}]` : '';
        console.log(`   ${context}${untranslated.singular}`);
      });
    } catch (error) {
      logger.error(`An error has occurred at building the untranslated report: ${error}`);
    }
  }

  /**
   * Returns the host used to communicating with i18n service
   * May Be overridden with I18N_SERVICE_HOST env variable
   *
   * @returns {string}
   */
  getI18nServiceHost() {
    if (!I18N_SERVICE_HOST) {
      return 'https://i18n.adminml.com';
    }

    return I18N_SERVICE_HOST.startsWith('http') ? I18N_SERVICE_HOST : `https://${I18N_SERVICE_HOST}`;
  }
}

module.exports = new M10e();
