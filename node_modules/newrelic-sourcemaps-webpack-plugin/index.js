const { publishSourcemap } = require('@newrelic/publish-sourcemap');
const defaultStaticAssetUrlBuilder = require('./lib/default-asset-url-builder');
const getNewrelicCredentials = require('./lib/get-newrelic-credentials');
const getApplicationSourcemaps = require('./lib/get-application-sourcemaps');
const queue = require('async/queue');
const env = require('frontend-env');
const path = require('path');

class NewrelicSourcemapsPlugin {
  constructor(options = {}) {
    const noop = typeof options.noop === 'undefined'
      ? !env.PRODUCTION || !env.IS_CI
      : options.noop;

    if (noop) {
      this.apply = () => {};
      return;
    }

    this.publicPath = options.publicPath;
    this.staticAssetUrlBuilder = options.staticAssetUrlBuilder || defaultStaticAssetUrlBuilder;
    this.applicationName = options.applicationName;
    this.applicationId = options.applicationId;
    this.apiKey = options.apiKey;
    this.extensionRegex = options.extensionRegex || /\.js$/;
    this.releaseName = options.releaseName || null;
    this.releaseId = options.releaseId || null;

    if (!this.publicPath) {
      throw new Error('publicPath is required');
    }
  }

  /* istanbul ignore next */
  apply(compiler) {
    // done is an asynchronous hook that triggers at the end of queue and always after the compilation
    compiler.hooks.done.tapPromise('NewrelicSourcemapsPlugin', async (stats) => {
      const credentials = await getNewrelicCredentials(this.applicationName, this.applicationId, this.apiKey);

      // Do not try to do anything when there is no credentials
      if (!credentials.apiKey || !credentials.applicationId) {
        return Promise.resolve();
      }

      const { compilation } = stats;
      // Only when devtool is set to 'source-map' Webpack writes sourcemaps output to file
      if (!compilation.options.devtool || compilation.options.devtool !== 'source-map') {
        return Promise.resolve();
      }

      const assetsList = Object.keys(compilation.assets).filter(name => this.extensionRegex.test(name));

      return new Promise(async (resolve) => { // eslint-disable-line no-async-promise-executor
        const sourcemaps = new Map();
        const appSourcemaps = new Map();

        const q = queue((task, callback) => {
          publishSourcemap({
            sourcemapPath: sourcemaps.get(task.javascriptUrl),
            javascriptUrl: task.javascriptUrl,
            apiKey: credentials.apiKey,
            applicationId: task.applicationId,
            releaseName: this.releaseName,
            releaseId: this.releaseId,
          }, (err) => {
            if (err) {
              // NewRelic responds with 409 when sourcemap is already uploaded, it's ok since we are using content-dependent checksum in the filenames
              if (err.status !== 409) {
                console.warn(`NewRelic sourcemap upload error. File: ${task.javascriptUrl}, application ID: ${task.applicationId}:
    Error: ${err.status} ${err.message}`);
                callback(err);
              } else {
                callback();
              }
            } else {
              callback();
            }
          });
        }, 25);

        q.drain(() => {
          console.log('All sourcempas have been uploaded to NewRelic');
          resolve();
        });

        q.pause();

        for (const filename of assetsList) { // eslint-disable-line no-restricted-syntax
          const sm = `${filename}.map`;

          if (!compilation.assets[sm]) {
            continue; // eslint-disable-line no-continue
          }

          const sourcemapPath = path.join(compilation.compiler.outputPath, sm);
          const appIds = Array.isArray(credentials.applicationId) ? credentials.applicationId : [credentials.applicationId];

          for (const applicationId of appIds) { // eslint-disable-line no-restricted-syntax
            const javascriptUrl = this.staticAssetUrlBuilder(this.publicPath, filename);

            if (!appSourcemaps.has(applicationId)) {
              const applicationSourcemaps = await getApplicationSourcemaps({ applicationId, apiKey: credentials.apiKey }); // eslint-disable-line no-await-in-loop
              appSourcemaps.set(applicationId, applicationSourcemaps);
            }

            if (!appSourcemaps.get(applicationId).has(javascriptUrl)) {
              if (!sourcemaps.has(javascriptUrl)) {
                sourcemaps.set(javascriptUrl, sourcemapPath);
              }

              q.push({
                javascriptUrl,
                applicationId,
              });
            }
          }
        }

        if (q.length() === 0) {
          console.log('All sourcempas are already on New Relic servers, nothing to upload.');
          q.kill();
          resolve();
        } else {
          q.resume();
        }
      });
    });
  }
}

module.exports = NewrelicSourcemapsPlugin;
