const { resolve } = require('path');
const env = require('frontend-env');
const get = require('lodash/get');
const deepMerge = require('./services/deep-merge');
const createHandler = require('./services/cluster-messages/message-handlers');
const getEnvironment = require('./services/get-environment');
const mergeConfiguration = require('./services/merge-config');
const sendUsedKeys = require('./services/properties-traceability');
const { production } = require('./constants/environment-variables');
const { SEPARATOR } = require('./constants/properties-traceability');
const { RES_CONFIG_HEADER } = require('./constants/environment-header');
const { FETCH_REMOTE_ERROR, GET_PROPERTY_ERROR } = require('./constants/stats');

/**
 * Returns full property key to fetch values from configData
 *
 * @param {string} key - Key of property inside global configurations
 * @returns {string} - Full property key in ConfigData
 */
const getGlobalConfigKey = key => `configurations.${key}`;

/**
 * Returns full property key to fetch values from configData[platform]
 * If given platformId doesn't exist in configData, returns a globalConfigKey
 *
 * @param {string} key - Key of property inside platform  configurations
 * @param {object} configData - Current config Data
 * @param {string} platformId - Id of selected platform
 * @returns {string} - Full property key in ConfigData
 */
const getPlatformConfigKey = (key, configData, platformId) => {
  const platformConfigurations = (configData.platforms[platformId] || {}).configurations;
  if (!platformConfigurations) {
    return getGlobalConfigKey(key);
  }
  return `platforms.${platformId}.configurations.${key}`;
};

/**
 * Returns full property key to fetch values from configData[platform][site]
 * 1.- If platformId doesn't exist return globalConfigKey
 * 2.- If platformId exists but siteId doesn't exist return platformConfigKey
 *
 * @param {string} key - Key of property inside site configurations
 * @param {object} configData - Current config Data
 * @param {string} platformId - Id of selected platform
 * @param {string} siteId - Id of selected site
 * @returns {string} - Full property key in ConfigData
 */
const getSiteConfigKey = (key, configData, platformId, siteId) => {
  if (!configData.platforms[platformId]) {
    return getGlobalConfigKey(key);
  }
  const siteConfigurations = configData.platforms[platformId].sites[siteId];
  if (!siteConfigurations) {
    return getPlatformConfigKey(key, configData, platformId);
  }
  return `platforms.${platformId}.sites.${siteId}.${key}`;
};

/**
 * Get property from current config
 *
 * @param {object} params - Params used for get a key
 * @param {object} params.configData - Current config data (required)
 * @param {string} params.key - Property key being asked (required)
 * @param {object} params.req - Req object (optional)
 * @param {object} params.platform - Platform asked (optional)
 * @param {object} params.logger - Logger object used to track errors
 * @param {object} params.packageInfo - Package info for logger
 *
 */
// eslint-disable-next-line
const getProperty = ({ configData, key, req, platform, logger, packageInfo, addKeyToMap, environment }) => {
  try {
    const platformIdAux = platform && platform.id;
    const platformId = platformIdAux === null
      ? null
      : platformIdAux || (((req || {}).platform || {}).id) || null;
    const siteIdAux = platform && platform.siteId;
    const siteId = siteIdAux === null
      ? null
      : siteIdAux || (((req || {}).platform || {}).siteId) || null;
    if (environment === production) {
      // Add trace for used key
      addKeyToMap({ key, platformId, siteId });
    }
    if (!platformId) {
      // Global
      return get(configData, getGlobalConfigKey(key));
    }
    if (!siteId) {
      // Platform
      return get(configData, getPlatformConfigKey(key, configData, platformId));
    }
    return get(configData, getSiteConfigKey(key, configData, platformId, siteId));
  } catch (err) {
    logger.error({ message: err.message, statName: GET_PROPERTY_ERROR, extraTags: { ...packageInfo, key } });
    throw err;
  }
};

/**
 * Prepare config for being used.
 * First using the local config data, and then
 * calling remote config file every x seconds searching any update
 * @param {object} params.data - Config data which will be readed or updated
 * @param {object} params.modulePackage - Namespace and version of the config module
 * @param {object} params.restClientConfig - Params used in rest request to get remote config
 * @param {object} params.envVariables - ENV variable names
 * @param {string} params.envVariables.update - ENV variable name used to make or not a fetchRemoteConfig
 * @param {string} params.envVariables.loadEnvironmentAtStartUp - ENV variable name used to load an environment on module creation
 * @param {object} params.update - Update configuration
 * @param {number} params.update.intervalInMs - Time between each request to get remote config
 * @param {string} params.update.environmentHeader - env variable to search for a specific config version on headers
 * @param {boolean} params.update.updateStaticFilesOnRelease - If true, create a new config file when release
 * @returns {function} - Function to get a property value from config
 */
const getFactory = ({
  data,
  modulePackage,
  restClientConfig,
  envVariables,
  update,
  logger,
  notifyHandlers,
}) => {
  const packageInfo = {
    name: modulePackage.name,
    version: modulePackage.version,
  };
  const configData = {};
  const keysSet = new Set();
  configData[production] = mergeConfiguration({
    version: modulePackage.version,
    ...data,
  });
  const setOnDevelopmentData = [];
  let handler;
  const onFetched = (props, response) => {
    const { environment, autoUpdate } = props;
    if (!configData[environment] || configData[environment].version !== response.data.version) {
      configData[environment] = mergeConfiguration(response.data);
      setOnDevelopmentData.forEach((setOnDevelopmentDataItem) => {
        configData[environment] = deepMerge(configData[environment], setOnDevelopmentDataItem);
      });
      notifyHandlers(environment);
    }
    if (environment === production && autoUpdate) {
      setTimeout(() => {
        handler.getFile({
          environment: production,
          autoUpdate,
        });
      }, update.intervalInMs);
    }
  };

  const onFetchError = (props, err) => {
    const { environment, autoUpdate } = props;
    logger.error({ message: err.message, statName: FETCH_REMOTE_ERROR, extraTags: { environment } });
    if (autoUpdate) {
      setTimeout(() => handler.getFile({
        environment,
        autoUpdate,
      }), update.intervalInMs);
    }
  };

  handler = createHandler(configData, {
    logger,
    update,
    restClientConfig,
    onFetched,
    onFetchError,
    packageName: packageInfo.name,
  });

  const useUpdates = env[envVariables.update] === 'true'
    || (env.PRODUCTION && !env.IS_CI && env.FURY && env[envVariables.update] !== 'false');

  if (useUpdates) {
    handler.getFile({
      environment: production,
    });
  }

  // load environments at startup
  Array.from(new Set((env[envVariables.loadEnvironmentAtStartUp] || '')
    .split(',')
    .map(text => text.trim())
    .filter(text => text)))
    .forEach(environment => {
      configData[environment] = null;
      handler.getFile({ environment });
    });

  /**
   * Return a promise resolved when the config file is fetched
   * (usefull for devs who wants to force an update)
   *
   * @param {string} environment - env to fetch
   * @returns {Promise}
   */
  const updateConfig = ({
    environment = production,
    req,
  } = {}) => handler.updateConfig({
    environment,
    req: (req && {
      headers: req.headers,
      cookies: req.cookies,
    }) || null,
    autoUpdate: false,
    catchError: false,
  });

  /**
   * Detect if response header has info for current config
   * @param {string|Array} configHeader
   * @returns {Boolean}
   */
  const configHeaderHasEnvironment = (configHeader = '') => []
    .concat(configHeader)
    .some(header => header
      .split(',')
      .some(prop => prop.split('=')[0] === packageInfo.name));

  /**
   * Add config header data
   * @param {Object} req
   */
  const setConfigHeader = (req = {}) => {
    if (req.cookies && req.cookies.meliLab) {
      const environment = getEnvironment({
        req,
        environment: null,
        environmentHeader: update.environmentHeader,
      });
      const { res = {} } = req;
      if (!!res.get && !!res.header) {
        const configHeader = res.get(RES_CONFIG_HEADER);
        if (!configHeaderHasEnvironment(configHeader)) {
          const moduleVersion = `${packageInfo.name}=${configData[environment] ? environment : production}`;
          const newConfigHeader = configHeader ? [configHeader, moduleVersion].join(',') : moduleVersion;
          res.header(RES_CONFIG_HEADER, newConfigHeader);
        }
      }
    }
  };

  /**
   * Add a string to keysSet including platform and site data
   *
   * @param {object} - platformId, siteId, key (all String)
   */
  const addKeyToMap = ({ platformId = '', siteId = '', key }) => {
    keysSet.add(`${platformId || ''}${SEPARATOR}${siteId || ''}${SEPARATOR}${key}`);
  };
  // service used for keys traceability
  if (env.PRODUCTION && !env.IS_CI && env.FURY) {
    sendUsedKeys({ keysSet, logger });
  }

  /**
   * Check environment and get a property from config file related
   * @param {*} params (see getProperty)
   * @returns {*} property value
   */
  const getValue = (params) => {
    const environment = getEnvironment({
      ...params,
      environmentHeader: update.environmentHeader,
    });
    if (useUpdates && !(environment in configData)) {
      configData[environment] = null;
      const { headers, cookies } = params.req || {};
      const req = { headers, cookies };
      handler.getFile({
        environment,
        req,
      });
    }
    // Add config headers (runs only on test scopes)
    setConfigHeader(params.req);
    return getProperty({
      ...params,
      configData: configData[environment] || configData[production],
      logger,
      packageInfo,
      addKeyToMap,
      environment,
    });
  };

  const setOnDevelopment = (setOnDevelopmentDataItem) => {
    if (env.FURY) {
      throw new Error('setOnDevelopment should not be called in a Fury environment');
    }
    setOnDevelopmentData.push(setOnDevelopmentDataItem);

    Object
      .keys(configData)
      .forEach(environment => {
        if (configData[environment]) {
          configData[environment] = deepMerge(configData[environment], setOnDevelopmentDataItem);
        }
      });
  };

  const loadDevelopmentData = () => {
    if (env.FURY) {
      return;
    }

    const envValue = env[envVariables.loadDevelopmentDataAtStartUp];
    if (envValue) {
      try {
        /* eslint-disable-next-line */
        const developmentData = require(resolve(envValue));
        setOnDevelopment(developmentData);
      } catch (e) {
        logger.error({
          log: true,
          message: `Error loading the "${envValue}" file declarated on the "${envVariables.loadDevelopmentDataAtStartUp}" variable`,
        });
      }
    }
  };

  loadDevelopmentData();

  return {
    updateConfig,
    getValue,
    setOnDevelopment,
  };
};

module.exports = getFactory;
