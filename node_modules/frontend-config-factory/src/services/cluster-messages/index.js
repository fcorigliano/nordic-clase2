/**
 * This service is used to communicate process in a nodejs cluster application using IPC
 * Facts:
 *  - A cluster master and a single process without using cluster, both response true to "cluster.isMaster"
 *  - In a cluster environment, the property cluster.workers in cluster master
 *    could be an empty array if its called before forking workers
 *
 * To check how to determinate when we are using cluster in our apps
 * today (February 2022), check Ragnar module in
 * https://github.com/mercadolibre/fury_frontend-ragnar/blob/master/lib/Ragnar.js
 */

const cluster = require('cluster');
const { CLUSTER_MESSAGE } = require('../../constants/cluster-variables');

const { hasOwnProperty } = Object.prototype;
const isEmptyValidate = (value, message) => {
  if (!value) {
    throw new Error(message);
  }
};

const messageHandlersFromWorkers = {};
const messageHandlersFromMaster = {};

/**
 * Handle a send message request using IPC messages in cluster module
 * Sets a messageBody with a "type" property for avoid process message
 * sended whitout this cluster-message service.
 *
 *
 * @param {string} subject - Name of the message to being sended (must be very unique)
 * @param {object} message - Params sended to listener
 * @returns {object} - If using cluster, it returns an object with
 *                     the trigger function to send the message to
 *                     worker or master. Else {}
 */
const sendMessage = (packageName, subject, message) => {
  isEmptyValidate(subject, 'Subject of the message is required');
  isEmptyValidate(message, 'Message is required'); // TODO: maybe is not required?

  const messageBody = {
    type: CLUSTER_MESSAGE,
    packageName,
    subject,
    message,
  };
  const toMaster = () => {
    process.send(messageBody);
  };
  const toWorkers = () => {
    Object.keys(cluster.workers).map(id => cluster.workers[id].send(messageBody));
  };

  return {
    toMaster: () => (cluster.isWorker ? toMaster() : () => { }),
    toWorkers: () => (cluster.isMaster ? toWorkers() : () => { }),
  };
};

/**
 * Handle a response for a message sended using this service (detected by
 * the "type" property added on sendMessage function).
 * It sends only the message as parameter to the callback function
 *
 *
 * @param {string} subjectToHandle - Name of the message to being received (must be very unique)
 * @param {function} cb - Callback function
 * @returns {object} If using cluster, it returns an object with
 *                   the trigger function to set the message handler in
 *                   worker or master. Else {}
 */
const handleMessage = (packageName, subjectToHandle, cb) => {
  isEmptyValidate(subjectToHandle, 'subjectToHandle is required');
  isEmptyValidate(cb, 'cb is required');

  const fromMaster = () => {
    if (hasOwnProperty.call(messageHandlersFromMaster, packageName)) {
      messageHandlersFromMaster[packageName][subjectToHandle] = cb;
    } else {
      messageHandlersFromMaster[packageName] = { [subjectToHandle]: cb };
    }
  };
  const fromWorker = () => {
    if (hasOwnProperty.call(messageHandlersFromWorkers, packageName)) {
      messageHandlersFromWorkers[packageName][subjectToHandle] = cb;
    } else {
      messageHandlersFromWorkers[packageName] = { [subjectToHandle]: cb };
    }
  };
  return {
    fromMaster: () => (cluster.isWorker ? fromMaster() : () => { }),
    fromWorker: () => (cluster.isMaster ? fromWorker() : () => { }),
  };
};

/**
 * Get all master handlers and excecute what is on call
 */
const handleMessagesGetter = (props, from) => {
  const { packageName, subject } = props;
  let messageHandler;
  if (from === 'MASTER') {
    messageHandler = messageHandlersFromMaster[packageName]?.[subject];
  } else if (from === 'WORKER') {
    messageHandler = messageHandlersFromWorkers[packageName]?.[subject];
  }
  if (typeof messageHandler === 'function') {
    return messageHandler(props.message);
  }
  return () => { };
};

/**
 * online listener for all new worker's messages
 * @returns
 */
if (cluster.isMaster) {
  cluster.on('online', (worker) => {
    worker.on('message', (props) => {
      handleMessagesGetter(props, 'WORKER');
    });
  });
} else if (cluster.isWorker) {
  cluster.worker.on('message', (props) => {
    handleMessagesGetter(props, 'MASTER');
  });
}
/**
 * Determinates if the current process is master and has workers
 * Its usefull for determinates if master has workers to share messages
 * @returns {boolean} True if its master and has workers
 */
const hasWorkers = () => !!Object.keys(cluster.workers).length;

/**
 * Destructuring properties used from cluster module
 */
const { isWorker, isMaster } = cluster;

const startMessaging = (packageName) => {
  const send = (subject, message) => sendMessage(packageName, subject, message);

  const handle = (subject, cb) => handleMessage(packageName, subject, cb);

  return { send, handle };
};

/**
 * Get the current ammount of event listeners in the eventEmmiter instance
 * @returns {Number} - Ammount of listeners in master or worker
 */
const listenerCount = () => {
  if (isMaster) {
    return cluster.listenerCount('online');
  }
  return process.listenerCount('message');
};

/**
 * Get the max ammount of event listeners in the eventEmmiter instance
 * @returns {Number} - Ammount of Max listeners in master or worker
 */
const getMaxListeners = () => {
  if (isMaster) {
    return cluster.getMaxListeners();
  }
  return process.getMaxListeners();
};
/**
 * Determinates if the subprocess (master or worker, dependening on who call it)
 * has passed a threshold of listeners defined by the developer
 *
 * This function does not blocking anything, but could be used for managing the use of
 * cluster messages or not
 * @param {*} threshold - A 0 to 100 number to determinate the percentage of listeners inside the
 *                        max ammount of listeners allowed (defalut 70% of the max ammount of listeners)
 * @returns {Boolean} - true if exceed the threshold
 */
const overThreshold = (threshold = 70) => ((listenerCount() * 100) / getMaxListeners()) > threshold;
module.exports = { startMessaging, isWorker, isMaster, hasWorkers, overThreshold };
