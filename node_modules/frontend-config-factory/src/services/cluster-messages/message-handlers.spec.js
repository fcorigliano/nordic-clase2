/* eslint-disable no-unused-vars */
const { production } = require('../../constants/environment-variables');

const update = {
  intervalInMs: 5 * 60 * 1000,
};

const mockEnv = (toReturn) => jest.doMock('frontend-env', () => toReturn);
const mockClusterM = (toReturn) => jest.doMock('.', () => toReturn);
const mockFetch = (toReturn, reject = false) => {
  const mock = { fetchRemoteConfigFile: reject ? jest.fn().mockRejectedValue({ data: toReturn }) : jest.fn().mockResolvedValue({ data: toReturn }) };
  jest.doMock('../fetch-remote-config-file', () => mock);
};

describe('message-handlers testing', () => {
  beforeEach(() => jest.resetModules());
  jest.useFakeTimers();

  test('getFile master fetch ok - mkdir, write ok ', () => {
    const { CONFIG_SAVED } = require('../../constants/cluster-variables');
    const configData = { production: null, test: null };
    const packageName = 'testmodule';
    const handlerProps = { packageName, update, onFetched: () => { }, onFetchError: () => { }, logger: { info: () => { }, error: () => { } } };
    const send = jest.fn(() => ({ toWorkers: () => { }, toMaster: () => { } }));
    const startMessaging = () => ({
      handle: () => ({ fromWorker: () => { }, fromMaster: () => { } }),
      send,
    });
    mockClusterM({ isMaster: true, hasWorkers: () => true, startMessaging, overThreshold: () => { } });
    mockFetch({
      version: 'test',
      configurations: {
        test: false,
      },
    });
    const mockUnlink = jest.fn((a, b) => b());
    jest.mock('fs', () => ({
      unlink: mockUnlink,
      mkdir: (a, b, c) => { c(); },
      writeFile: (a, b, c, d) => { d(); },
    }));
    const createHandler = require('./message-handlers');
    const handler = createHandler(configData, handlerProps);
    expect(configData.test).toBeFalsy();
    handler.getFile({ environment: 'test' });


    return Promise.resolve().then(() => {
      jest.runAllTimers();
      expect(mockUnlink).toHaveBeenCalled();
      expect(send).toHaveBeenCalledWith(CONFIG_SAVED, {
        environment: 'test',
        module: packageName,
      });
    });
  });

  test('getFile master fetch ok - mkdir, write ok - unlink fail', () => {
    const { ERROR_DELETING_FILE_FROM_DISK } = require('../../constants/stats');
    const configData = { production: null, test: null };
    const handlerProps = { update, onFetched: () => { }, onFetchError: () => { }, logger: { info: () => { }, error: jest.fn() } };
    const startMessaging = () => ({
      handle: () => ({ fromWorker: () => { }, fromMaster: () => { } }),
      send: () => ({ toWorkers: () => { }, toMaster: () => { } }),
    });
    mockClusterM({ isMaster: true, hasWorkers: () => true, startMessaging, overThreshold: () => { } });
    mockFetch({
      version: 'test',
      configurations: {
        test: false,
      },
    });
    const mockUnlink = jest.fn((a, b) => b(true));
    jest.mock('fs', () => ({
      unlink: mockUnlink,
      mkdir: (a, b, c) => { c(); },
      writeFile: (a, b, c, d) => { d(); },
    }));
    const createHandler = require('./message-handlers');
    const handler = createHandler(configData, handlerProps);
    expect(configData.test).toBeFalsy();
    handler.getFile({ environment: 'test' });

    return Promise.resolve().then(() => {
      jest.runAllTimers();
      expect(mockUnlink).toHaveBeenCalled();
      expect(handlerProps.logger.error).toHaveBeenCalledWith({ message: expect.any(String), statName: ERROR_DELETING_FILE_FROM_DISK, extraTags: { environment: 'test' } });
    });
  });

  test('getFile master fetch error', async () => {
    const configData = { production: null, test: null };
    const handlerProps = { update, onFetched: () => { }, onFetchError: jest.fn(), logger: { info: () => { }, error: () => { } } };
    const startMessaging = () => ({
      handle: () => ({ fromWorker: () => { }, fromMaster: () => { } }),
      send: () => ({ toWorkers: () => { }, toMaster: () => { } }),
    });
    mockClusterM({ isMaster: true, hasWorkers: () => true, startMessaging, overThreshold: () => { } });
    mockFetch({
      version: 'test',
      configurations: {
        test: false,
      },
    }, true);
    const createHandler = require('./message-handlers');
    const handler = createHandler(configData, handlerProps);
    expect(configData.test).toBeFalsy();
    await handler.getFile({ environment: 'test' });
    expect(handlerProps.onFetchError).toHaveBeenCalled();
  });

  test('getFile master - fetch ok - mkdir fail', () => {
    const { MASTER_FAIL_WRITING_FILE } = require('../../constants/cluster-variables');
    const configData = { production: null, test: null };
    const packageName = 'testmodule';
    const handlerProps = { packageName, update, onFetched: () => { }, onFetchError: () => { }, logger: { info: () => { }, error: () => { } } };
    const send = jest.fn(() => ({ toWorkers: () => { }, toMaster: () => { } }));
    const startMessaging = () => ({
      handle: () => ({ fromWorker: () => { }, fromMaster: () => { } }),
      send,
    });
    mockClusterM({ isMaster: true, hasWorkers: () => true, startMessaging, overThreshold: () => { } });
    mockFetch({
      version: 'test',
      configurations: {
        test: false,
      },
    });
    const mockUnlink = jest.fn((a, b) => b());
    jest.mock('fs', () => ({
      unlink: mockUnlink,
      mkdir: (a, b, c) => { c(true); },
      writeFile: (a, b, c, d) => { d(); },
    }));
    const createHandler = require('./message-handlers');
    const handler = createHandler(configData, handlerProps);
    expect(configData.test).toBeFalsy();
    handler.getFile({ environment: 'test' });

    return Promise.resolve().then(() => {
      expect(send).toHaveBeenCalledWith(MASTER_FAIL_WRITING_FILE, {
        environment: 'test',
        module: packageName,
      });
      jest.runAllTimers();
      expect(mockUnlink).toHaveBeenCalled();
    });
  });

  test('getFile master - fetch ok - writing fail', () => {
    const { MASTER_FAIL_WRITING_FILE } = require('../../constants/cluster-variables');
    const configData = { production: null, test: null };
    const packageName = 'testmodule';
    const handlerProps = { packageName, update, onFetched: () => { }, onFetchError: () => { }, logger: { info: () => { }, error: () => { } } };
    const send = jest.fn(() => ({ toWorkers: () => { }, toMaster: () => { } }));
    const startMessaging = () => ({
      handle: () => ({ fromWorker: () => { }, fromMaster: () => { } }),
      send,
    });
    mockClusterM({ isMaster: true, hasWorkers: () => true, startMessaging, overThreshold: () => { } });
    mockFetch({
      version: 'test',
      configurations: {
        test: false,
      },
    });
    const mockUnlink = jest.fn((a, b) => b());
    jest.mock('fs', () => ({
      unlink: mockUnlink,
      mkdir: (a, b, c) => { c(); },
      writeFile: (a, b, c, d) => { d(true); },
    }));
    const createHandler = require('./message-handlers');
    const handler = createHandler(configData, handlerProps);
    expect(configData.test).toBeFalsy();
    handler.getFile({ environment: 'test' });

    return Promise.resolve().then(() => {
      expect(send).toHaveBeenCalledWith(MASTER_FAIL_WRITING_FILE, {
        environment: 'test',
        module: packageName,
      });
      jest.runAllTimers();
      expect(mockUnlink).toHaveBeenCalled();
    });
  });

  test('getFile worker ask to master', () => {
    const { MASTER_FETCH_NEW_ENVIRONMENT } = require('../../constants/cluster-variables');
    const configData = { production: null };
    const packageName = 'testmodule';
    const handlerProps = { packageName, update, onFetched: jest.fn(), onFetchError: () => { }, logger: { info: () => { }, error: () => { } } };
    const send = jest.fn(() => ({ toWorkers: () => { }, toMaster: () => { } }));
    const startMessaging = () => ({
      handle: () => ({ fromWorker: () => { }, fromMaster: () => { } }),
      send,
    });
    mockClusterM({ isWorker: true, startMessaging, overThreshold: () => { } });
    mockFetch({
      version: 'test',
      configurations: {
        test: false,
      },
    });
    const mockUnlink = jest.fn((a, b) => b());
    jest.mock('fs', () => ({
      unlink: mockUnlink,
      mkdir: (a, b, c) => { c(); },
      writeFile: (a, b, c, d) => { d(); },
    }));
    const createHandler = require('./message-handlers');
    const handler = createHandler(configData, handlerProps);
    handler.getFile({ environment: 'test' });
    expect(send).toHaveBeenCalledWith(MASTER_FETCH_NEW_ENVIRONMENT, {
      environment: 'test',
      module: packageName,
      pid: expect.any(String),
      req: null,
    });
    // expect(configData["test"]).toBeFalsy();
    // return Promise.resolve().then(() => {
    //   Promise.resolve().then(() => {
    //     jest.runAllTimers();
    //     expect(handlerProps.onFetched).toHaveBeenCalled();
    //   });
    // });
  });

  test('Worker - READING CONFIG OK', () => {
    const { CONFIG_SAVED } = require('../../constants/cluster-variables');
    const configData = { production: null, test: null };
    const handlerProps = { packageName: 'testmodule', update, onFetched: jest.fn(), onFetchError: () => { }, logger: { info: () => { }, error: () => { } } };
    mockEnv({
      PRODUCTION: 'true',
      DISABLE_NODEJS_CLUSTER: 'FALSE',
      ML_NAVIGATION_CONFIG_UPDATE: 'true',
    });
    mockFetch({
      version: 'test',
      configurations: {},
    });
    mockClusterM({
      isMaster: false,
      isWorker: true,
      startMessaging: () => ({
        send: (a, b) => ({
          toMaster: () => { },
          toWorkers: () => { },
        }),
        handle: (a, b) => ({
          fromMaster: () => {
            if (a === CONFIG_SAVED) {
              b({ environment: production, module: 'testmodule' });
            }
          },
          fromWorker: () => { },
        }),
      }),
      overThreshold: () => { },
    });
    // mock folder create ok, writefile ok
    jest.mock('fs', () => ({
      mkdir: (a, b, c) => c(),
      writeFile: (a, b, c, d) => d(),
      readFile: (a, b, c) => c(null, 'true'),
      access: (a, b, c) => c(),
    }));
    const createHandler = require('./message-handlers');
    const handler = createHandler(configData, handlerProps);
    handler.getFile({ environment: 'test' });
    expect(handlerProps.onFetched).toHaveBeenCalled();
  });

  test('Worker - READING CONFIG fails', () => {
    const { CONFIG_SAVED } = require('../../constants/cluster-variables');
    const configData = { production: null, test: null };
    const handlerProps = { packageName: 'testmodule', update, onFetched: jest.fn(), onFetchError: () => { }, logger: { info: () => { }, error: () => { } } };
    mockEnv({
      PRODUCTION: 'true',
      DISABLE_NODEJS_CLUSTER: 'FALSE',
      ML_NAVIGATION_CONFIG_UPDATE: 'true',
    });
    mockFetch({
      version: 'test',
      configurations: {},
    });
    mockClusterM({
      isMaster: false,
      isWorker: true,
      startMessaging: () => ({
        send: (a, b) => ({
          toMaster: () => { },
          toWorkers: () => { },
        }),
        handle: (a, b) => ({
          fromMaster: () => {
            if (a === CONFIG_SAVED) {
              b({ environment: production, module: 'testmodule' });
            }
          },
          fromWorker: () => { },
        }),
      }),
      overThreshold: () => { },
    });
    // mock folder create ok, writefile ok
    jest.mock('fs', () => ({
      mkdir: (a, b, c) => c(),
      writeFile: (a, b, c, d) => d(),
      readFile: (a, b, c) => c(true),
      access: (a, b, c) => c(),
    }));
    const createHandler = require('./message-handlers');
    const handler = createHandler(configData, handlerProps);
    handler.getFile({ environment: 'test' });
    return Promise.resolve().then(() => {
      expect(handlerProps.onFetched).toHaveBeenCalled();
    });
  });

  test('Worker - MASTER_FAIL_WRITING_FILE message received', async () => {
    const { MASTER_FAIL_WRITING_FILE } = require('../../constants/cluster-variables');
    const configData = { production: null, test: null };
    const handlerProps = { packageName: 'testmodule', update, onFetched: jest.fn(), onFetchError: () => { }, logger: { info: () => { }, error: () => { } } };
    mockEnv({
      PRODUCTION: 'true',
      DISABLE_NODEJS_CLUSTER: 'FALSE',
      ML_NAVIGATION_CONFIG_UPDATE: 'true',
    });
    mockFetch({
      version: 'test',
      configurations: {},
    });
    mockClusterM({
      isMaster: false,
      isWorker: true,
      startMessaging: () => ({
        send: (a, b) => ({
          toMaster: () => { },
          toWorkers: () => { },
        }),
        handle: (a, b) => ({
          fromMaster: () => {
            if (a === MASTER_FAIL_WRITING_FILE) {
              b({ environment: production, module: 'testmodule' });
            }
          },
          fromWorker: () => { },
        }),
      }),
      overThreshold: () => { },
    });
    const createHandler = require('./message-handlers');
    const handler = createHandler(configData, handlerProps);
    await handler.getFile({ environment: 'test' });
    expect(handlerProps.onFetched).toHaveBeenCalled();
  });

  describe('MASTER - MASTER_FETCH_NEW_ENVIRONMENT message received', () => {
    test('master have in memory but not in disk', async () => {
      const { MASTER_FETCH_NEW_ENVIRONMENT } = require('../../constants/cluster-variables');
      const packageName = 'testmodule';
      const configData = { production: null, test: { version: 1 } };
      const handlerProps = { packageName, update, onFetched: jest.fn(), onFetchError: () => { }, logger: { info: () => { }, error: () => { } } };
      mockEnv({
        PRODUCTION: 'true',
        DISABLE_NODEJS_CLUSTER: 'FALSE',
        ML_NAVIGATION_CONFIG_UPDATE: 'true',
      });
      mockFetch({
        version: 'test',
        configurations: {},
      });
      const send = jest.fn(() => ({ toWorkers: () => { }, toMaster: () => { } }));
      mockClusterM({
        isMaster: true,
        isWorker: false,
        startMessaging: () => ({
          send,
          handle: (a, b) => ({
            fromWorker: () => {
              if (a === MASTER_FETCH_NEW_ENVIRONMENT) {
                b({ environment: 'test', module: packageName, req: {}, pid: 1 });
              }
            },
            fromMaster: () => { },
          }),
        }),
        overThreshold: () => { },
      });
      const mockWriteFile = jest.fn();
      jest.mock('fs', () => ({
        access: (a, b, c) => { c(true); },
        mkdir: (a, b, c) => { c(); },
        writeFile: mockWriteFile,
      }));
      const createHandler = require('./message-handlers');
      createHandler(configData, handlerProps);
      expect(mockWriteFile).toHaveBeenCalled();
    });

    test('master have it on memory and disk, worker must be new asking production', async () => {
      const { MASTER_FETCH_NEW_ENVIRONMENT, FETCH_ALL_ENVS } = require('../../constants/cluster-variables');
      const packageName = 'testmodule';
      const configData = { production: { ok: 1 }, test: { version: 1 } };
      const handlerProps = { packageName, update, onFetched: jest.fn(), onFetchError: () => { }, logger: { info: () => { }, error: () => { } } };
      mockEnv({
        PRODUCTION: 'true',
        DISABLE_NODEJS_CLUSTER: 'FALSE',
        ML_NAVIGATION_CONFIG_UPDATE: 'true',
      });
      mockFetch({
        version: 'test',
        configurations: {},
      });
      const send = jest.fn(() => ({ toWorkers: () => { }, toMaster: () => { } }));
      mockClusterM({
        isMaster: true,
        isWorker: false,
        startMessaging: () => ({
          send,
          handle: (a, b) => ({
            fromWorker: () => {
              if (a === MASTER_FETCH_NEW_ENVIRONMENT) {
                b({ environment: production, module: packageName, req: {}, pid: '1' });
              }
            },
            fromMaster: () => { },
          }),
        }),
        overThreshold: () => { },
      });
      const mockWriteFile = jest.fn();
      jest.mock('fs', () => ({
        access: (a, b, c) => { c(false); },
        mkdir: (a, b, c) => { c(); },
        writeFile: mockWriteFile,
      }));
      const createHandler = require('./message-handlers');
      await createHandler(configData, handlerProps);
      expect(send).toHaveBeenCalledWith(FETCH_ALL_ENVS, { pid: '1', module: packageName, envs: [production, 'test'] });
    });

    test('master have it on memory and disk, worker asking pre-release', async () => {
      const { MASTER_FETCH_NEW_ENVIRONMENT, CONFIG_SAVED } = require('../../constants/cluster-variables');
      const packageName = 'testmodule';
      const configData = { production: { ok: 1 }, test: { version: 1 } };
      const handlerProps = { packageName, update, onFetched: jest.fn(), onFetchError: () => { }, logger: { info: () => { }, error: () => { } } };
      mockEnv({
        PRODUCTION: 'true',
        DISABLE_NODEJS_CLUSTER: 'FALSE',
        ML_NAVIGATION_CONFIG_UPDATE: 'true',
      });
      mockFetch({
        version: 'test',
        configurations: {},
      });
      const send = jest.fn(() => ({ toWorkers: () => { }, toMaster: () => { } }));
      mockClusterM({
        isMaster: true,
        isWorker: false,
        startMessaging: () => ({
          send,
          handle: (a, b) => ({
            fromWorker: () => {
              if (a === MASTER_FETCH_NEW_ENVIRONMENT) {
                b({ environment: 'test', module: packageName, req: {}, pid: '1' });
              }
            },
            fromMaster: () => { },
          }),
        }),
        overThreshold: () => { },
      });
      const mockWriteFile = jest.fn();
      jest.mock('fs', () => ({
        access: (a, b, c) => { c(false); },
        mkdir: (a, b, c) => { c(); },
        writeFile: mockWriteFile,
      }));
      const createHandler = require('./message-handlers');
      await createHandler(configData, handlerProps);
      expect(send).toHaveBeenCalledWith(CONFIG_SAVED, { environment: 'test', module: packageName });
    });

    test('master doesnt have it', async () => {
      const { MASTER_FETCH_NEW_ENVIRONMENT, CONFIG_SAVED } = require('../../constants/cluster-variables');
      const packageName = 'testmodule';
      const configData = { production: { ok: 1 } };
      const handlerProps = { packageName, update, onFetched: jest.fn(), onFetchError: () => { }, logger: { info: () => { }, error: () => { } } };
      mockEnv({
        PRODUCTION: 'true',
        DISABLE_NODEJS_CLUSTER: 'FALSE',
        ML_NAVIGATION_CONFIG_UPDATE: 'true',
      });
      mockFetch({
        version: 'test',
        configurations: {},
      });
      const send = jest.fn(() => ({ toWorkers: () => { }, toMaster: () => { } }));
      mockClusterM({
        isMaster: true,
        isWorker: false,
        hasWorkers: () => true,
        startMessaging: () => ({
          send,
          handle: (a, b) => ({
            fromWorker: () => {
              if (a === MASTER_FETCH_NEW_ENVIRONMENT) {
                b({ environment: 'test', module: packageName, req: {}, pid: '1' });
              }
            },
            fromMaster: () => { },
          }),
        }),
        overThreshold: () => { },
      });
      const mockWriteFile = jest.fn();
      jest.mock('fs', () => ({
        access: (a, b, c) => { c(false); },
        mkdir: (a, b, c) => { c(); },
        writeFile: mockWriteFile,
      }));
      const createHandler = require('./message-handlers');
      await createHandler(configData, handlerProps);
      expect(handlerProps.onFetched).toHaveBeenCalled();
    });
  });

  test('Worker - REMOVE_ENV_DATA received message ', async () => {
    const { REMOVE_ENV_DATA } = require('../../constants/cluster-variables');
    const packageName = 'testmodule';
    const configData = { production: { ok: 1 }, test: { ok: 1 } };
    const handlerProps = { packageName, update, onFetched: jest.fn(), onFetchError: () => { }, logger: { info: () => { }, error: () => { } } };
    mockEnv({
      PRODUCTION: 'true',
      DISABLE_NODEJS_CLUSTER: 'FALSE',
      ML_NAVIGATION_CONFIG_UPDATE: 'true',
    });
    mockFetch({
      version: 'test',
      configurations: {},
    });
    mockClusterM({
      isMaster: false,
      isWorker: true,
      startMessaging: () => ({
        send: (a, b) => ({
          toMaster: () => { },
          toWorkers: () => { },
        }),
        handle: (a, b) => ({
          fromMaster: () => {
            if (a === REMOVE_ENV_DATA) {
              b({ environment: 'test', module: 'testmodule' });
            }
          },
          fromWorker: () => { },
        }),
      }),
      overThreshold: () => { },
    });
    const createHandler = require('./message-handlers');
    expect(configData.test).toBeTruthy();
    createHandler(configData, handlerProps);
    expect(configData.test).toBeFalsy();
  });

  test('Worker - FETCH_ALL_ENVS received message ', async () => {
    const { FETCH_ALL_ENVS } = require('../../constants/cluster-variables');
    const packageName = 'testmodule';
    const configData = {};
    const handlerProps = { packageName, update, onFetched: jest.fn(), onFetchError: () => { }, logger: { info: () => { }, error: () => { } } };
    mockEnv({
      PRODUCTION: 'true',
      DISABLE_NODEJS_CLUSTER: 'FALSE',
      ML_NAVIGATION_CONFIG_UPDATE: 'true',
    });
    mockFetch({
      version: 'test',
      configurations: {},
    });
    mockClusterM({
      isMaster: false,
      isWorker: true,
      startMessaging: () => ({
        send: (a, b) => ({
          toMaster: () => { },
          toWorkers: () => { },
        }),
        handle: (a, b) => ({
          fromMaster: () => {
            if (a === FETCH_ALL_ENVS) {
              b({ envs: [production, 'test'], module: packageName, pid: process.pid.toString() });
            }
          },
          fromWorker: () => { },
        }),
      }),
      overThreshold: () => { },
    });

    const mockReadFile = jest.fn();
    jest.mock('fs', () => ({
      access: (a, b, c) => { c(); },
      mkdir: (a, b, c) => { c(); },
      readFile: mockReadFile,
    }));
    const createHandler = require('./message-handlers');
    createHandler(configData, handlerProps);
  });
  test('Update', () => {
    const configData = { production: { version: '1', configurations: { test: false } } };
    const packageName = 'testmodule';
    const handlerProps = {
      packageName,
      update,
      onFetched: ({ environment }, response) => {
        configData[environment] = response.data;
      },
      onFetchError: () => { },
      logger: { info: () => { }, error: () => { } },
    };
    mockFetch({
      version: '2',
      configurations: {
        test: true,
      },
    });
    const createHandler = require('./message-handlers');
    const handler = createHandler(configData, handlerProps);
    expect(configData.production.version).toBe('1');
    expect(configData.production.configurations.test).toBeFalsy();
    return handler.updateConfig({ environment: production }).then(() => {
      expect(configData.production.version).toBe('2');
      expect(configData.production.configurations.test).toBeTruthy();
    });
  });
});
