# FRONTEND-CONFIG-FACTORY
*A module for create config modules*

# Getting started

This documentation explains basic concepts of frontend-config-factory applied on a config module created by using it. Please visit [Docs page](DOCS.md) for full documentation about frontend-config-factory.

Maintaining a Config module using Frontend-config-factory can be easy following these steps, but first please be aware of these two warnings.

> :warning: **Changes in the config file must be retrocompatible with apps using previous config module**:
> please read [Retrocompatibility](#Retrocompatibility)

> :warning: **Creating a release of a navigation config module may impact production resources**:
> please check how to [create new version of your config module](#create-new-version)

# Table of Contents

- [Maintianing your config](#Maintaining-your-config)
  - [JSON schema](#JSON-schema)
  - [Retrocompatibility](#Retrocompatibility)
- [Using your config](#using-your-config)
  - [getValue](#getvalue)
- [Testing your changes](#testing-your-changes)
  - [Locally](#locally)
    - [setOnDevelopment](#setondevelopment)
    - [loaddevelopmentdataatstartup](#loaddevelopmentdataatstartup)
  - [Remote (On Fury)](#remote-on-fury)
- [Create new version](#create-new-version)

# Maintaining your config

An usual task maintaining a config module is to add/delete/update some value, please consider the following schema to do it:

## JSON schema

A configuration file (usually saved in `config/` folder) follows the following schema:

```json
{
  "configurations": {
    "someGlobalConfig": 1
  },
  "platforms": {
    "ML": {
      "configurations": {
        "somePlatformConfig": 2
      },
      "sites": {
        "MLA": {
          "someSiteConfig": 3
        }
      }
    }
  }
}
```

Any change on config file must consider its **level of specificity** (global, platform, site).

> Platforms configurations inherits global configurations and site configurations inherits platforms configurations (and global ones by transitive). **This inheritance is made by making a deep merge on configuration objects (arrays are not merged)**.

## Retrocompatibility

As previous versions of consumer modules (eg: navigation module < v5.4.0) will consume new configurations, so changes on this module should be retrocompatible. That means you should not change any configuration schema or remove a configuration unless you are pretty sure the consumer is prepared for that or there's no consumer using that configuration.

Eg:
`some-consumer-module@1.0.0` depends on `some-configuration-module@1.0.0` and does something like:

```js
const { getValue } = require('some-configuration-module');

const someKeyValue = getValue({ key: 'someKey' });

const links = someKeyValue.map((item) => item.link);
```

Then `some-consumer-module@1.0.1` does not need `someKey` anymore and remove previous code. Probably a developer tends to remove the `someKey`configuration from a new `some-configuration-module@1.0.1`, let's see what happens if we do it.

As some application didn't updated the `some-configuration-module` dependency it will have the `1.0.0` version, but as this configuration is auto-updateable at some point it will update its data to the `1.0.1` one without the `someKey` configuration. Let's run the code again in our minds:

```js
const { getValue } = require('some-configuration-module'); // `some-configuration-module@1.0.0` with data from `some-configuration-module@1.0.1`

const someKeyValue = getValue({ key: 'someKey' });
// someKeyValue is `undefined` as a developer removed that configuration on some-configuration-module@1.0.1

const links = someKeyValue.map((item) => item.link);
// kaboom!!!
```

So take this into account when modifying or removing configurations.

# Using your config

Frontend-config-factory exports a series of methods (read [this docs](/DOCS.md?id=returned-methods) for a complete list with a full description of them) but the most needed its `getValue` method.

## getValue

```js
const { getValue } = require('some-configuration-module');

const someValue = getValue({
  key: 'some.nested.key',
});
```

### `key` parameter

When the key contains words separated by a dot, it will lookup over objects until reach the last word.

Eg:

```
some: {
  nested: {
    key: {
      configuration: 1,
    },
  },
},
```

Getting `some.nested.key` will return the `{ configuration: 1 }` object.

### Specificity

As was said before, there are 3 levels of specificity; global, platform, and site configurations.

For getting value of a key on a specific level you can use `platform` parameter, or `req` express object parameter (in that order of priority).

#### Platform parameter

```
const someValue = getValue({
  key: 'companyName',
  platform: {id: 'ML', siteId: 'MLA'}
});
```

#### req object

```
const someValue = getValue({
  key: 'companyName',
  req: {
    platform: {id: 'ML', siteId: 'MLA'}
  }
});
```

> Platform property on `req` object its filled on a middleware

# Testing your changes

## Locally

### setOnDevelopment

In order to test some changes when developing the navigation module you can use the `setOnDevelopment` method that allows you to pass some configuration to the consumer module. It only works on development environments (does not work on when running on fury).

Eg:

```js
const { setOnDevelopment } = require('some-configuration-module');

setOnDevelopment({
  configurations: {
    // global configurations
    someGlobalConfig: 1,
  },
  platforms: {
    ML: {
      configurations: {
        // platform configurations
        somePlatformConfig: 2,
      },
      sites: {
        MLA: {
          // site configurations
          someSiteConfig: 3,
        },
      },
    },
  },
});
```

If you have many instances of the configuration module you may being passing the development data to a instance you are not using or you do not want to pass the development data to it. In order to avoid this scenario you can use the `loadDevelopmentDataAtStartUp` configuration.

### loadDevelopmentDataAtStartUp

You can pass an environment variable name in the `envVariables.loadDevelopmentDataAtStartUp` parameter at the configuration initialization (please read [this docs](/DOCS.md?id=params-used) for initialization parameters), if not passed the `{MODULE_NAME}_DEVELOPMENT_DATA` environment variable will be used (eg: `ML_NAVIGATION_CONFIG_DEVELOPMENT_DATA` for the `ml-navigation-config` module).

Passing a path of a `js` or `json` file in this environment variable allow to load that configuration on development environments.

Eg:

```js
// some-path/some-file.js file

module.exports = {
  configurations: {
    // global configurations
    someGlobalConfig: 1,
  },
  platforms: {
    ML: {
      configurations: {
        // platform configurations
        somePlatformConfig: 2,
      },
      sites: {
        MLA: {
          // site configurations
          someSiteConfig: 3,
        },
      },
    },
  },
};
```

```shell
export ML_NAVIGATION_CONFIG_DEVELOPMENT_DATA="some-path/some-file.js"
npm run start-dev
```

>Note that these injected configurations works different than normal configurations in many ways:
>- They are loaded only in development environments (not in fury).
>- Development configurations will not be overriden by configuration updates
>- Global configrations are not inherited by platforms/sites and platform configurations are not inherited by sites. If you need a value to be available in a development environment you have to declare it in the place you will use it (platform if you are requesting a platform configuration, or site if you are requesting site configuration).

## Remote (on Fury)

Passing the req object to the getValue function allows you to get a test environment configuration if the request contains a meliLab cookie with some value and the `x-{name-of-your-configuration}-environment` (eg: `x-ml-navigation-config-environment`) header with the test environment version (eg: 0.0.1-test.1).

For adding meliLab cookie you should use [Meli Lab Chrome extension](https://chrome.google.com/webstore/detail/meli-lab/echkhjdfnneoflgbalglfagemmpdbcie) and for adding the header value you can use [ModHeader Chrome extension](https://chrome.google.com/webstore/detail/modheader/idgpnmonknjnojddfkpgkljpfnnfcklj?src=modheader-com)

> Test environments are lazy, so when getting a configuration from a test environment the module will return a productive configuration first, and when the test environment configuration is fetched by the instance a few seconds later it will return the test environment configuration. Taken this into account, if your scope has many instances it will be hard to reach the one that already fetch the test scope.

# Create new version

The release process for config modules follows the [LibFlow](https://furydocs.io/release-process/4.16.0/guide/#/lang-es/workflows/04_libflow). And the biggest difference between how we release apps and libs using Fury CLI  is that when create a lib version, **we don't need to pass the version number as an argument on command line because Fury gets it from the package.json file**.

For example, for a package.json like this on a config module
```jsonc
//package.json
{
  //...
  "name": "ml-navigation-config",
  "version": "1.1.9-beta.0",
  //...

```
Running `fury create-version` will create a pre-release version called `1.1.9-beta.0` that can be used following [Remote testing](#remote-on-fury)

On the other hand, for a package.json like this
```jsonc
//package.json
{
  //...
  "name": "ml-navigation-config",
  "version": "1.1.9",
  //...

```
Running `fury create-version` **will create a production release that will overwrite the actual config file fetched on config consumer modules**.


>The environment is determined on release process by the version number. Productive version numbers with the form {major}.{minor}.{patch} ends up in the production environment while pre-release version numbers with the form {major}.{minor}.{patch}-{pre-release} ends up in the {major}.{minor}.{patch}-{pre-release} test environment.
