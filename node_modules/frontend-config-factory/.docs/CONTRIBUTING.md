## How to contribute

### Configuration schema
Please read the [Specificity section on USAGE.md file](./USAGE.md#specificity) before reading this section.

A configuration follows the following schema:
```json
{
  "configurations": {
    "someGlobalConfig": 1,
  },
  "platforms": {
    "ML": {
      "configurations": {
        "somePlatformConfig": 2,
      },
      "sites": {
        "MLA": {
          "someSiteConfig": 3,
        },
      },
    },
  },
}
```

### Retrocompatibility
As previous versions of consumer modules (eg: navigation module) will consume new configurations, changes on this module should be retrocompatible. That means you should not change any configuration schema or remove a configuration unless you are pretty sure the consumer is prepared for that or there's no consumer using that configuration.

Eg:
`some-consumer-module@1.0.0` depends on `some-configuration-module@1.0.0` and does something like:

```js
const { getValue } = require('some-configuration-module');

const someKeyValue = getValue({ key: 'someKey' })

const links = someKeyValue.map(item => item.link);
```

Then `some-consumer-module@1.0.1` does not need `someKey` anymore and remove previous code. Probably a developer tends to remove the `someKey`configuration from a new `some-configuration-module@1.0.1`, let's see what happens if we do it.

As some application didn't updated the `some-configuration-module` dependency it will have the `1.0.0` version, but as this configuration is auto-updateable at some point it will update its data to the `1.0.1` one without the `someKey` configuration. Let's run the code again in our minds:

```js
const { getValue } = require('some-configuration-module'); // `some-configuration-module@1.0.0` with data from `some-configuration-module@1.0.1`

const someKeyValue = getValue({ key: 'someKey' });
// someKeyValue is `undefined` as a developer removed that configuration on some-configuration-module@1.0.1

const links = someKeyValue.map(item => item.link);
// kaboom!!!
```

So take this into account when modifying or removing configurations.

### frontend-config retrocompatibility
Some of the configurations on these configuration modules came from a migration from a configuration module called `frontend-config`. In order to reflect changes made on this repository on the `frontend-config` configuration we use a list of configuration keys to migrate for [each configuration](https://github.com/mercadolibre/fury_frontend-config/tree/master/utils/migration/configurations). These migration takes care about auto-referencing, so `frontend-config` will migrate the listed configurations and related ones (eg: if `desktopFooterLinks` refers to a `someNewLink` then `url.someNewLink` will be also migrated).

### Testing your changes
#### Local development
##### setOnDevelopment
In order to test some changes when developing the navigation module you can use the `setOnDevelopment` method that allows you to pass some configuration. It only works on development environments (does not work on when running on fury).

Eg:
```js
const { setOnDevelopment } = require('some-configuration-module');

setOnDevelopment({
  configurations: {
    // global configurations
    someGlobalConfig: 1,
  },
  platforms: {
    ML: {
      configurations: {
        // platform configurations
        somePlatformConfig: 2,
      },
      sites: {
        MLA: {
          // site configurations
          someSiteConfig: 3,
        },
      },
    },
  },
});
```

Note that these configurations work different than normal configurations in many ways:
 - They are loaded only in development environments (not in fury).
 - Development configurations will not be overriden by configuration updates
 - Global configrations are not inherited by platforms/sites and platform configurations are not inherited by sites. If you need a value to be available in a development environment you have to declare it in the place you will use it (platform if you are requesting a platform configuration, or site if you are requesting site configuration).

If you have many instances of the configuration module you may being passing the development data to a instance you are not using or you do not want to pass the development data to it. In order to avoid this scenario you can use the `loadDevelopmentDataAtStartUp` configuration.

##### loadDevelopmentDataAtStartUp
You can pass an environment variable name in the `envVariables.loadDevelopmentDataAtStartUp` parameter at the configuration initialization, if not passed the `{MODULE_NAME}_DEVELOPMENT_DATA` environment variable will be used (eg: `ML_NAVIGATION_CONFIG_DEVELOPMENT_DATA` for the `ml-navigation-config` module).

Passing a path of a `js` or `json` file in this environment variable allow to load that configuration on development environments.

Eg:

```js
// some-path/some-file.js file

module.exports = {
  configurations: {
    // global configurations
    someGlobalConfig: 1,
  },
  platforms: {
    ML: {
      configurations: {
        // platform configurations
        somePlatformConfig: 2,
      },
      sites: {
        MLA: {
          // site configurations
          someSiteConfig: 3,
        },
      },
    },
  },
};
```

```shell
export ML_NAVIGATION_CONFIG_DEVELOPMENT_DATA="some-path/some-file.js"
npm run start-dev
```

Note that these configurations work different than normal configurations in many ways:
 - They are loaded only in development environments (not in fury).
 - Development configurations will not be overriden by configuration updates
 - Global configrations are not inherited by platforms/sites and platform configurations are not inherited by sites. If you need a value to be available in a development environment you have to declare it in the place you will use it (platform if you are requesting a platform configuration, or site if you are requesting site configuration).

#### Beta release
Please read the [Environment section on USAGE.md file](./USAGE.md#environment) in order to use test environments.

### Pull request
Please follow these steps in order to contribute with a configuration:
 - Update the CHANGELOG.md file adding the PR changes.
 - Ask some of the maintainers team to review the PR and create a beta version of your changes.
 - Once validated and reviewed merge the PR.

### Productive release
As configurations are commonly used on many applications though libraries it is very important to:
 - Notify the NOC team before releasing a new version, that way they will contact you or at least know you are making changes if some error occurs.
 - Schedule the release on non-critical time ranges (eg: after 0am and before 7am).